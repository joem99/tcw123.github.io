<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>剑指Offer Test02-Test30 | Yuwen Mi's Space</title><meta name="description" content="Test212345678910111213141516171819202122232425262728293031&#x2F;&#x2F; Test02 设计一个类，我们只能生成该类的一个实例。&#x2F;* 饿汉式 *&#x2F;class A &amp;#123;    private A() &amp;#123;    &amp;#125;    private static final A instance &amp;"><meta name="keywords" content="剑指Offer"><meta name="author" content="Yuwen Mi,mywjyw@foxmail.com"><meta name="copyright" content="Yuwen Mi"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/08/24/%E5%89%91%E6%8C%87Offer-Test02-Test30/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="剑指Offer Test02-Test30"><meta property="og:url" content="http://yoursite.com/2020/08/24/%E5%89%91%E6%8C%87Offer-Test02-Test30/"><meta property="og:site_name" content="Yuwen Mi's Space"><meta property="og:description" content="Test212345678910111213141516171819202122232425262728293031&#x2F;&#x2F; Test02 设计一个类，我们只能生成该类的一个实例。&#x2F;* 饿汉式 *&#x2F;class A &amp;#123;    private A() &amp;#123;    &amp;#125;    private static final A instance &amp;"><meta property="og:image" content="https://i.loli.net/2020/08/19/e6uyhEqAtD8sxHB.png"><meta property="article:published_time" content="2020-08-24T13:41:47.000Z"><meta property="article:modified_time" content="2020-08-24T13:45:40.388Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-08-24 21:45:40'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.1"><link rel="alternate" href="/atom.xml" title="Yuwen Mi's Space" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">6</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Test2"><span class="toc-number">1.</span> <span class="toc-text">Test2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test3"><span class="toc-number">2.</span> <span class="toc-text">Test3</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test4"><span class="toc-number">3.</span> <span class="toc-text">Test4</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test5"><span class="toc-number">4.</span> <span class="toc-text">Test5</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test6"><span class="toc-number">5.</span> <span class="toc-text">Test6</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test7"><span class="toc-number">6.</span> <span class="toc-text">Test7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test8"><span class="toc-number">7.</span> <span class="toc-text">Test8</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test9"><span class="toc-number">8.</span> <span class="toc-text">Test9</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test10"><span class="toc-number">9.</span> <span class="toc-text">Test10</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test11"><span class="toc-number">10.</span> <span class="toc-text">Test11</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test12"><span class="toc-number">11.</span> <span class="toc-text">Test12</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test13"><span class="toc-number">12.</span> <span class="toc-text">Test13</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test14"><span class="toc-number">13.</span> <span class="toc-text">Test14</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test15"><span class="toc-number">14.</span> <span class="toc-text">Test15</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test16"><span class="toc-number">15.</span> <span class="toc-text">Test16</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test17"><span class="toc-number">16.</span> <span class="toc-text">Test17</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test18"><span class="toc-number">17.</span> <span class="toc-text">Test18</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test19"><span class="toc-number">18.</span> <span class="toc-text">Test19</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test20"><span class="toc-number">19.</span> <span class="toc-text">Test20</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test21"><span class="toc-number">20.</span> <span class="toc-text">Test21</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test22"><span class="toc-number">21.</span> <span class="toc-text">Test22</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test23"><span class="toc-number">22.</span> <span class="toc-text">Test23</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test24"><span class="toc-number">23.</span> <span class="toc-text">Test24</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test25"><span class="toc-number">24.</span> <span class="toc-text">Test25</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test26"><span class="toc-number">25.</span> <span class="toc-text">Test26</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test27"><span class="toc-number">26.</span> <span class="toc-text">Test27</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test28"><span class="toc-number">27.</span> <span class="toc-text">Test28</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test29"><span class="toc-number">28.</span> <span class="toc-text">Test29</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test30"><span class="toc-number">29.</span> <span class="toc-text">Test30</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/08/19/e6uyhEqAtD8sxHB.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Yuwen Mi's Space</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">剑指Offer Test02-Test30</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-24T13:41:47.000Z" title="发表于 2020-08-24 21:41:47">2020-08-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-24T13:45:40.388Z" title="更新于 2020-08-24 21:45:40">2020-08-24</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Test2"><a href="#Test2" class="headerlink" title="Test2"></a>Test2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Test02 设计一个类，我们只能生成该类的一个实例。</span><br><span class="line"></span><br><span class="line">&#x2F;* 饿汉式 *&#x2F;</span><br><span class="line">class A &#123;</span><br><span class="line">    private A() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private static final A instance &#x3D; new A();</span><br><span class="line"></span><br><span class="line">    public static A getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 懒汉式 *&#x2F;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">    private B() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static B instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static getInstance() &#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null) </span><br><span class="line">            instance &#x3D; new B();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Test3"><a href="#Test3" class="headerlink" title="Test3"></a>Test3</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test03 在一个二维数组中，每一行都按照从左到右递增的顺序排序，</span><br><span class="line">    每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的</span><br><span class="line">    一个二维数组和一个整数，判断数组中是否函数该整数。*&#x2F;</span><br><span class="line"></span><br><span class="line">class Test03 &#123;</span><br><span class="line">    public boolean search(int target, int[][] array) &#123;</span><br><span class="line">        int length1 &#x3D; array[0].length; &#x2F;&#x2F; 列数</span><br><span class="line">        int length2 &#x3D; array.length; &#x2F;&#x2F; 行数</span><br><span class="line"></span><br><span class="line">        int row &#x3D; 0;</span><br><span class="line">        int col &#x3D; length1 - 1;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 从第一行最后一列找起</span><br><span class="line">        while (row &lt; length2 &amp;&amp; col &gt;&#x3D; 0) &#123;</span><br><span class="line">            if(array[row][col] &#x3D;&#x3D; target)</span><br><span class="line">                return true;</span><br><span class="line">            else if (target &lt; array[row][col]) &#123;</span><br><span class="line">                col --;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                row ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test4"><a href="#Test4" class="headerlink" title="Test4"></a>Test4</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test04 请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。</span><br><span class="line">    例如输入&quot;We are happy&quot;，则输出&quot;We%20are%20happy&quot; *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test04 &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">        StringBuffer tmp &#x3D; new StringBuffer();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">            char c &#x3D; str.charAt(i);</span><br><span class="line">            if (c &#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">                tmp.append(&quot;%20&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tmp.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test5"><a href="#Test5" class="headerlink" title="Test5"></a>Test5</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test05 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 *&#x2F;</span><br><span class="line">public class Test05 &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">        while (listNode !&#x3D; null) &#123;</span><br><span class="line">            arraylist.add(0, listNode.val);</span><br><span class="line">            listNode &#x3D; listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return arraylist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test6"><a href="#Test6" class="headerlink" title="Test6"></a>Test6</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test06 根据某二叉树前序遍历和中序遍历的结果重建二叉树 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays</span><br><span class="line"></span><br><span class="line">public class Test06 &#123;</span><br><span class="line">    public TreeNode reConstructBinaryTree(int [] pre, int [] in) &#123;</span><br><span class="line">        if (pre.length &#x3D;&#x3D; 0 || in.length &#x3D;&#x3D; 0) </span><br><span class="line">            return null;</span><br><span class="line">        TreeNode root &#x3D; new TreeNode(pre[0]);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; in.length; i ++) &#123;</span><br><span class="line">            if (pre[0] &#x3D;&#x3D; in[i]) &#123;</span><br><span class="line">                &#x2F;&#x2F; copyOfRange函数左闭右开</span><br><span class="line">                root.left &#x3D; reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));</span><br><span class="line"></span><br><span class="line">                root.right &#x3D; reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test7"><a href="#Test7" class="headerlink" title="Test7"></a>Test7</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test07 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 *&#x2F;</span><br><span class="line">&#x2F;* Push直接push到stack1中，</span><br><span class="line">    Pop：若stack2中没有数据，则先将stack1中数据都push进去再pop stack2；</span><br><span class="line">    若stack2中有数据则直接Pop stack2 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Test07 &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    public void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if (stack2.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            while (stack1.size() !&#x3D; 0) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test8"><a href="#Test8" class="headerlink" title="Test8"></a>Test8</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test08 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</span><br><span class="line">输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</span><br><span class="line">例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为1。</span><br><span class="line">NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 二分法：</span><br><span class="line">    右断点看作target，mid与target比较，</span><br><span class="line">    mid &lt; target，last &#x3D; mid</span><br><span class="line">    mid &gt; target，first &#x3D; mid+1</span><br><span class="line">    *&#x2F;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test08 &#123;</span><br><span class="line">    public int minNumberInRotateArray(int[] array) &#123;</span><br><span class="line">        if (array.length &#x3D;&#x3D; 0) return 0;</span><br><span class="line"></span><br><span class="line">        int target &#x3D; array[array.length - 1];</span><br><span class="line">        int first &#x3D; 0;</span><br><span class="line">        int last &#x3D; array.length - 1;</span><br><span class="line">        int mid &#x3D; (first + last) &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F; 不能等</span><br><span class="line">        while (first &lt; last) &#123;</span><br><span class="line">            if (array[first] &lt; array[last]) </span><br><span class="line">                return array[first];</span><br><span class="line">            if (array[mid] &lt; target) &#123;</span><br><span class="line">                last &#x3D; mid;</span><br><span class="line">            &#125; else if (array[mid] &gt; target) &#123;</span><br><span class="line">                first &#x3D; mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                last --;</span><br><span class="line">            &#125;</span><br><span class="line">            mid &#x3D; (first + last) &#x2F; 2;</span><br><span class="line">            target &#x3D; array[last];</span><br><span class="line">        &#125;</span><br><span class="line">        return array[first];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test9"><a href="#Test9" class="headerlink" title="Test9"></a>Test9</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test09 现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</span><br><span class="line">n&lt;&#x3D;39 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 递归法，时间 复杂度 O(n2)。*&#x2F;</span><br><span class="line">public class Test09 &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        if (n &#x3D;&#x3D; 0) return 0;</span><br><span class="line">        if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">        return Fibonacci(n - 2) + Fibonacci(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 递归法会重复计算，因此可以迭代计算，每次保存下次需要的数据</span><br><span class="line">    sum 存储第 n 项的值</span><br><span class="line">    one 存储第 n-1 项的值</span><br><span class="line">    two 存储第 n-2 项的值</span><br><span class="line"> *&#x2F;</span><br><span class="line">public in Fibonacci(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1) return n;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    int one &#x3D; 1;</span><br><span class="line">    int two &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        sum &#x3D; one + two;</span><br><span class="line">        two &#x3D; one;</span><br><span class="line">        one &#x3D; sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Test10"><a href="#Test10" class="headerlink" title="Test10"></a>Test10</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test10 一只青蛙一次可以跳上1级台阶，也可以跳上2级。</span><br><span class="line">求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 上n层台阶有f(n)种，</span><br><span class="line">    第一步有两种选择：1.先上1层再上n-1层有f(n-1)</span><br><span class="line">                  2.先上2层再上n-2层有f(n-2)</span><br><span class="line">    所以f(n) &#x3D; f(n-1) + f(n-2)是个斐波那契</span><br><span class="line">    f(1)&#x3D;1 f(2)&#x3D;2 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test10 &#123;</span><br><span class="line">    public int JumpFloor(int target) &#123;</span><br><span class="line">        if (target &#x3D;&#x3D; 1 || target &#x3D;&#x3D; 2) return n;</span><br><span class="line">        return JumpFloor(target-1) + JumpFloor(target-2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test11"><a href="#Test11" class="headerlink" title="Test11"></a>Test11</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test11 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。</span><br><span class="line">    求该青蛙跳上一个n级的台阶总共有多少种跳法。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设跳上n级台阶有f(n)种跳法，</span><br><span class="line">    跳上n级可以分为n种，在第1级跳n-1步，...在第n-1级跳1步</span><br><span class="line">    所以f(n) &#x3D; f(1) + f(2)+...+f(n-1) *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test11 &#123;</span><br><span class="line">    public int JumpFloorII(int target) &#123;</span><br><span class="line">        if (target &#x3D;&#x3D; 1 || target &#x3D;&#x3D; 2)  return target;</span><br><span class="line">        return 2*JumpFloorII(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="Test12"><a href="#Test12" class="headerlink" title="Test12"></a>Test12</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test12 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。</span><br><span class="line">请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* f(n)&#x3D;f(n-1)+f(n-2) f(1)&#x3D;1 f(2)&#x3D;2 *&#x2F;</span><br><span class="line">public class Test12 &#123;</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">        if (target &#x3D;&#x3D; 0 || target &#x3D;&#x3D; 1 || target &#x3D;&#x3D; 2) return target;</span><br><span class="line">        return RectCover(target - 1) + RectCover(target - 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test13"><a href="#Test13" class="headerlink" title="Test13"></a>Test13</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test13 输入一个整数，输出该数32位二进制表示中1的个数。</span><br><span class="line">    其中负数用补码表示。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* val &amp; (val-1) 得到的值的二进制形式正好是val最低位的1变为0 </span><br><span class="line">    例：val :1101000, val-1: 1100111 那么val &amp; （val-1） : 1100000</span><br><span class="line">    *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test13 &#123;</span><br><span class="line">    public int NumberOf1(int n) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while (n !&#x3D; 0) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            n &#x3D; n &amp; (n - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test14"><a href="#Test14" class="headerlink" title="Test14"></a>Test14</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test14 给定一个double类型的浮点数base和int类型的整数exponent。</span><br><span class="line">求base的exponent次方。保证base和exponent不同时为0 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 递归法快速幂 </span><br><span class="line">    偶数直接平方，奇数再乘上base *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test14 &#123;</span><br><span class="line">    public double Power(double base, int exponent) &#123;</span><br><span class="line">        &#x2F;&#x2F; 考虑e &lt; 0的情况</span><br><span class="line">        if (exponent &lt; 0) &#123;</span><br><span class="line">            base &#x3D; 1 &#x2F; base;</span><br><span class="line">            exponent &#x3D;  - exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        if (exponent &#x3D;&#x3D; 0) return 1;</span><br><span class="line">        if (exponent &#x3D;&#x3D; 1) return base;</span><br><span class="line"></span><br><span class="line">        double res;</span><br><span class="line">        res &#x3D; Power(base, exponent &gt;&gt; 1);</span><br><span class="line">        res *&#x3D; res;</span><br><span class="line">        if  (exponent &#x2F; 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            res *&#x3D; base;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test15"><a href="#Test15" class="headerlink" title="Test15"></a>Test15</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test15 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，</span><br><span class="line">所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 1.用一个临时数组，遍历原数组向新数组中存奇数和偶数，时间复杂度O(n) 空间O(n)</span><br><span class="line">   2.in-place算法</span><br><span class="line">初始化操作：记录一个变量i表示已经将奇数放好的下一个位置，显然最开始i&#x3D;0,表示还没有一个奇数放好。</span><br><span class="line">j 表示数组的下标，初始值为0， 表示从下标0开始遍历。</span><br><span class="line">如果遇到偶数，j++</span><br><span class="line">如果遇到奇数,假设位置为j，就将此奇数插入到i所指的位置，然后i往后移动一个位置，在插入之前，显然会涉及到数据的移动，也就是将[i,j-1]整体往后移动。</span><br><span class="line">直到整个数组遍历完毕，结束 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test15 &#123;</span><br><span class="line">    public void reOrderArray(int [] array) &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int tmp;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; array.length; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F; j索引位置为奇数</span><br><span class="line">            if ((array[j] &amp; 0x01) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                tmp &#x3D; array[j];</span><br><span class="line">                for (int k &#x3D; j; k &gt; i; k --) &#123;</span><br><span class="line">                    array[k] &#x3D; array[k - 1];</span><br><span class="line">                &#125;</span><br><span class="line">                array[i] &#x3D; tmp;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test16"><a href="#Test16" class="headerlink" title="Test16"></a>Test16</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test16 输入一个链表，输出该链表中倒数第k个结点。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 倒数第k个节点与null节点间有k个指针。所以构造两个指针，slow指针到fast指针间也有k个指针，</span><br><span class="line">    这样当fast指针指向null节点时，slow指针正好指向目标节点 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test16 &#123;</span><br><span class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow &#x3D; head;</span><br><span class="line">        ListNode fast &#x3D; head;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; k; i ++) &#123;</span><br><span class="line">            if (fast &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            fast &#x3D; fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while (fast !&#x3D; null) &#123;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">            fast &#x3D; fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test17"><a href="#Test17" class="headerlink" title="Test17"></a>Test17</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test17 输入一个链表，反转链表后，输出新链表的表头。 *&#x2F;</span><br><span class="line">&#x2F;*</span><br><span class="line">初始化：3个指针</span><br><span class="line">1）pre指针指向已经反转好的链表的最后一个节点，最开始没有反转，所以指向null</span><br><span class="line">2）cur指针指向待反转链表的第一个节点，最开始第一个节点待反转，所以指向head</span><br><span class="line">3）nxt指针指向待反转链表的第二个节点，目的是保存链表，因为cur改变指向后，后面的链表则失效了，所以需要保存</span><br><span class="line"></span><br><span class="line">循环执行：</span><br><span class="line">nxt&#x3D;cur.next</span><br><span class="line">cur.next&#x3D;pre</span><br><span class="line">pre&#x3D;cur cur&#x3D;nxt</span><br><span class="line">循环条件是cur!&#x3D;null</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test17 &#123;</span><br><span class="line">    public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode pre &#x3D; null;</span><br><span class="line">        ListNode nxt;</span><br><span class="line">        while (head !&#x3D; null) &#123;</span><br><span class="line">            nxt &#x3D; head.next;</span><br><span class="line">            head.next &#x3D; pre;</span><br><span class="line">            pre &#x3D; head;</span><br><span class="line">            head &#x3D; nxt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test18"><a href="#Test18" class="headerlink" title="Test18"></a>Test18</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test18 输入两个单调递增的链表，输出两个链表合成后的链表，</span><br><span class="line">    当然我们需要合成后的链表满足单调不减规则。*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test18 &#123;</span><br><span class="line">    public ListNode Merge(ListNode list1,ListNode list2) &#123;</span><br><span class="line">        ListNode head &#x3D;  new ListNode(-1);</span><br><span class="line">        ListNode tmp &#x3D; head;</span><br><span class="line"></span><br><span class="line">        while (list1 !&#x3D; null &amp;&amp; list2 !&#x3D; null) &#123;</span><br><span class="line">            if (list1.val &lt; list2.val) &#123;</span><br><span class="line">                tmp.next &#x3D; list1;</span><br><span class="line">                list1 &#x3D; list1.next;</span><br><span class="line">            &#125; else if (list1.val &gt; list2.val) &#123;</span><br><span class="line">                tmp.next &#x3D; list2;</span><br><span class="line">                list2 &#x3D; list2.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tmp.next &#x3D; list1;</span><br><span class="line">                list1 &#x3D; list1.next;</span><br><span class="line">                tmp &#x3D; tmp.next;</span><br><span class="line">                tmp.next &#x3D; list2;</span><br><span class="line">                list2 &#x3D; list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp &#x3D; tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (list1 !&#x3D; null) tmp.next &#x3D; list1;</span><br><span class="line">        if (list2 !&#x3D; null) tmp.next &#x3D; list2;</span><br><span class="line"></span><br><span class="line">        return head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test19"><a href="#Test19" class="headerlink" title="Test19"></a>Test19</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test19 输入两棵二叉树A，B，判断B是不是A的子结构。</span><br><span class="line">（ps：我们约定空树不是任意一个树的子结构）*&#x2F;</span><br><span class="line">&#x2F;* 递归 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test19 &#123;</span><br><span class="line">    public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123;</span><br><span class="line">        boolean res &#x3D; false;</span><br><span class="line">        if (root1 !&#x3D; null &amp;&amp; root2 !&#x3D; null) &#123;</span><br><span class="line">            if (root1.val &#x3D;&#x3D; root2.val) &#123;</span><br><span class="line">                res &#x3D; doesTree1HaveTree2(root1, root2);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!res) &#123;</span><br><span class="line">                res &#x3D; HasSubtree(root1.left, root2);</span><br><span class="line">            &#125; </span><br><span class="line">            if (!res) &#123;</span><br><span class="line">                res &#x3D; HasSubtree(root1.right, root2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean doesTree1HaveTree2(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">        if (root2 &#x3D;&#x3D; null) </span><br><span class="line">            return true;</span><br><span class="line">        if (root1 &#x3D;&#x3D; null)</span><br><span class="line">            return false;</span><br><span class="line">        if (root1.val !&#x3D; root2.val) </span><br><span class="line">            return false;</span><br><span class="line">        return doesTree1HaveTree2(root1.left, root2.left) &amp;&amp; doesTree1HaveTree2(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Test20"><a href="#Test20" class="headerlink" title="Test20"></a>Test20</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test20 操作给定的二叉树，将其变换为源二叉树的镜像。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 递归 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test20 &#123;</span><br><span class="line">    public void Mirror(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) return ;</span><br><span class="line">        TreeNode tmp &#x3D; root.left;</span><br><span class="line">        root.left &#x3D; root.right;</span><br><span class="line">        root.right &#x3D; tmp;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test21"><a href="#Test21" class="headerlink" title="Test21"></a>Test21</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test21 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，</span><br><span class="line">如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字</span><br><span class="line">1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 把矩阵外层看成一个圈，打印每个圈；</span><br><span class="line"></span><br><span class="line">定义四个变量代表范围，top、bottom、left、right</span><br><span class="line"></span><br><span class="line">向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 top 加一，同时判断是否和代表下边界的 bottom 交错</span><br><span class="line">向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错</span><br><span class="line">向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 bottom 减一，同时判断是否和代表上边界的 top 交错</span><br><span class="line">向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test21 &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList(); </span><br><span class="line">        if (matrix &#x3D;&#x3D; null || matrix.length &#x3D;&#x3D; 0 || matrix[0].length &#x3D;&#x3D; 0)</span><br><span class="line">            return list;</span><br><span class="line">        int top &#x3D; 0;</span><br><span class="line">        int bottom &#x3D; matrix.length - 1;</span><br><span class="line">        int left &#x3D; 0;</span><br><span class="line">        int right &#x3D; matrix[0].length - 1;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F; 最顶一行</span><br><span class="line">            for (int i &#x3D; left; i &lt;&#x3D; right; i ++) &#123;</span><br><span class="line">                list.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (++ top &gt; bottom)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 最右侧一行</span><br><span class="line">            for (int i &#x3D; top; i &lt;&#x3D; bottom; i ++) &#123;</span><br><span class="line">                list.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (--right &lt; left)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 最底层一行</span><br><span class="line">            for (int i &#x3D; right; i &gt;&#x3D; left; i --) &#123;</span><br><span class="line">                list.add(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (--bottom &lt; top)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 最左侧一行</span><br><span class="line">            for (int i &#x3D; bottom; i &gt;&#x3D; top; i  --) &#123;</span><br><span class="line">                list.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (++ left &gt; right)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test22"><a href="#Test22" class="headerlink" title="Test22"></a>Test22</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的</span><br><span class="line">min函数（时间复杂度应为O（1））*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 需要创建一个辅助栈来实现呢min函数，如果仅仅使用一个辅助变量min，</span><br><span class="line">则其值可能因为min元素被出栈而失效.</span><br><span class="line">    辅助栈中成员数量与栈中相同，对应着栈的最小值 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Test22 &#123;</span><br><span class="line">    private Stack&lt;Integer&gt; stack1 &#x3D; new Stack();</span><br><span class="line">    private Stack&lt;Integer&gt; stackSupport &#x3D; new Stack();</span><br><span class="line"></span><br><span class="line">    public void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        if (stackSupport.empty() || node &lt; stackSupport.peek()) &#123;</span><br><span class="line">            stackSupport.push(node);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stackSupport.push(stackSupport.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pop() &#123;</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stackSupport.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int min() &#123;</span><br><span class="line">        return stackSupport.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test23"><a href="#Test23" class="headerlink" title="Test23"></a>Test23</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test23 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为</span><br><span class="line">该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是</span><br><span class="line">某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，</span><br><span class="line">但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 新建一个栈，将数组A压入栈中，当栈顶元素等于数组B时，就将其出栈，</span><br><span class="line">当循环结束时，判断栈是否为空，若为空则返回true. *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Test23 &#123;</span><br><span class="line">    public boolean IsPopOrder(int [] pushA,int [] popA) &#123;</span><br><span class="line">        if (pushA.length &#x3D;&#x3D; 0 || popA.length &#x3D;&#x3D; 0 || pushA.length !&#x3D; popA.length)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack &#x3D; new Stack();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0, j &#x3D; 0; i &lt; pushA.length; i ++) &#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line"></span><br><span class="line">            while (!stack.empty() &amp;&amp; stack.peek() &#x3D;&#x3D; popA[j]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test24"><a href="#Test24" class="headerlink" title="Test24"></a>Test24</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test24 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。</span><br><span class="line">如果是则返回true,否则返回false。</span><br><span class="line">假设输入的数组的任意两个数字都互不相同。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 后序遍历 左-&gt;右-&gt;根，所以最后一个元素是根元素，BST要求所有左子树元素小于根，右子树元素大于根。</span><br><span class="line">那么，只需要不断地确定出左子树区间和右子树区间，并且判断：左子树区间的所有结点值 &lt; 根结点值 &lt; 右子树区间所有结点值，</span><br><span class="line">这个条件是否满足即可 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test24 &#123;</span><br><span class="line">    public boolean VerifySquenceOfBST(int [] sequence) &#123;</span><br><span class="line">        if (sequence &#x3D;&#x3D; null || sequence.length &#x3D;&#x3D; 0)</span><br><span class="line">            return false;</span><br><span class="line">        return helpVerify(sequence, 0, sequence.length - 1); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean helpVerify(int [] sequence, int start, int end) &#123;</span><br><span class="line">        &#x2F;&#x2F; 左子树空的话会&gt;</span><br><span class="line">        if (start &gt;&#x3D; end)</span><br><span class="line">            return true;</span><br><span class="line">        int root &#x3D; sequence[end];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; start - i-1为左子树</span><br><span class="line">        int i &#x3D; start;</span><br><span class="line">        for (; i &lt; end; i ++) &#123;</span><br><span class="line">            if (sequence[i] &gt; root)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j &#x3D; i; j &lt; end; j ++) &#123;</span><br><span class="line">            if (sequence[j] &lt; root)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断左右子树是否符合BST</span><br><span class="line">        return helpVerify(sequence, start, i - 1) &amp;&amp; </span><br><span class="line">                helpVerify(sequence, i, end - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test25"><a href="#Test25" class="headerlink" title="Test25"></a>Test25</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*Test25 输入一颗二叉树的根节点和一个整数，</span><br><span class="line">按字典序打印出二叉树中结点值的和为输入整数的所有路径。</span><br><span class="line">路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* </span><br><span class="line">递归三要素</span><br><span class="line">1.明白递归函数的功能：FindPath(TreeNode* root,int sum)，从root节点出发，找和为sum的路径</span><br><span class="line">2.递归终止条件：当root节点为叶子节点并且target-root.val&#x3D;&#x3D;0, 表示找到了一条符合条件的路径</span><br><span class="line">3.下一次递归：如果左子树不空，递归左子树FindPath(root-&gt;left, target),如果右子树不空，递归右子树，FindPath(root-&gt;right, target)</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test25 &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list &#x3D; new ArrayList();</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll &#x3D; new ArrayList();</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null)</span><br><span class="line">            return listAll;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target -&#x3D; root.val;</span><br><span class="line">        &#x2F;&#x2F; 当前节点为叶节点且target&#x3D;0</span><br><span class="line">        if (target &#x3D;&#x3D; 0 &amp;&amp; root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) </span><br><span class="line">            listAll.add(new ArrayList(list));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 继续递归左右子树</span><br><span class="line">        FindPath(root.left, target);</span><br><span class="line">        FindPath(root.right, target);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 删除list中最后一个节点，回退到当前节点状态</span><br><span class="line">        list.remove(list.size() - 1);</span><br><span class="line"></span><br><span class="line">        return listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test26"><a href="#Test26" class="headerlink" title="Test26"></a>Test26</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test26 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，</span><br><span class="line">另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。</span><br><span class="line">（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* step1 在旧链表中创建新链表（如1&#96;在1号节点后），不处理新链表的兄弟节点</span><br><span class="line">    step2 遍历链表，初始化新节点中的兄弟节点</span><br><span class="line">    step3 从旧链表中拆分得到新链表 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test26 &#123;</span><br><span class="line">    public RandomListNode Clone(RandomListNode pHead) &#123;</span><br><span class="line">        if (pHead &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        RandomListNode curNode &#x3D; pHead;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; step 1</span><br><span class="line">        while (curNode !&#x3D; null) &#123;</span><br><span class="line">            RandomListNode cloneNode &#x3D; new RandomListNode(curNode.label);</span><br><span class="line">            cloneNode.next &#x3D; curNode.next;</span><br><span class="line">            curNode.next &#x3D; cloneNode;</span><br><span class="line">            curNode &#x3D; cloneNode.next;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; step 2</span><br><span class="line">        curNode &#x3D; pHead;</span><br><span class="line">        while (curNode !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里要注意复制节点的random应该指向复制节点，别指向原节点了</span><br><span class="line">            curNode.next.random &#x3D; curNode.random&#x3D;&#x3D;null ? null : curNode.random.next;</span><br><span class="line">            curNode &#x3D; curNode.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; step3</span><br><span class="line">        curNode &#x3D; pHead;</span><br><span class="line">        RandomListNode pCloneHead &#x3D; pHead.next; &#x2F;&#x2F; 复制链表的头节点</span><br><span class="line">        while (curNode !&#x3D; null) &#123;</span><br><span class="line">            RandomListNode cloneNode &#x3D; curNode.next;</span><br><span class="line">            curNode.next &#x3D; cloneNode.next;</span><br><span class="line">            &#x2F;&#x2F; 尾节点的话next会是null，要进行判断</span><br><span class="line">            cloneNode.next &#x3D; cloneNode.next&#x3D;&#x3D;null ? null : cloneNode.next.next;</span><br><span class="line">            curNode &#x3D; curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test27"><a href="#Test27" class="headerlink" title="Test27"></a>Test27</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test27 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</span><br><span class="line">要求不能创建任何新的结点，只能调整树中结点指针的指向。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 中序遍历一棵二叉搜索树得到的序列是从小到大排列的</span><br><span class="line">    中序遍历链表后再添加指针构成双向链表 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test27 &#123;</span><br><span class="line">    public TreeNode Convert(TreeNode pRootOfTree) &#123;</span><br><span class="line">        if (pRootOfTree &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; list &#x3D; new ArrayList();</span><br><span class="line">        &#x2F;&#x2F; 中序遍历，结果保存到list中</span><br><span class="line">        Convert(pRootOfTree, list);</span><br><span class="line">        return Convert(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Convert(TreeNode pRootOfTree, ArrayList list) &#123;</span><br><span class="line">        if (pRootOfTree.left !&#x3D;null) &#123;</span><br><span class="line">            Convert(pRootOfTree.left, list);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(pRootOfTree);</span><br><span class="line">        if (pRootOfTree.right !&#x3D; null) &#123;</span><br><span class="line">            Convert(pRootOfTree.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode Convert(ArrayList&lt;TreeNode&gt; list) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; list.size() - 1; i ++) &#123;</span><br><span class="line">            list.get(i).right &#x3D; list.get(i+1);</span><br><span class="line">            list.get(i+1).left &#x3D; list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return list.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test28"><a href="#Test28" class="headerlink" title="Test28"></a>Test28</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test28 输入一个字符串,按字典序打印出该字符串中字符的所有排列。</span><br><span class="line">例如输入字符串abc,则按字典序打印出由字符a,b,c</span><br><span class="line">所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。*&#x2F;</span><br><span class="line"></span><br><span class="line">还没做</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Test29"><a href="#Test29" class="headerlink" title="Test29"></a>Test29</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test29 数组中有一个数字出现的次数超过数组长度的一半，</span><br><span class="line">请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。</span><br><span class="line">由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：对数组进行顺序排列，目标数若存在肯定位于中间位置。</span><br><span class="line">    获得该数后遍历数组判断是否符合要求 *&#x2F;</span><br><span class="line">&#x2F;* 时间复杂度O(nlgn) 空间复杂度O(1) *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Test29 &#123;</span><br><span class="line">    public int MoreThanHalfNum_Solution(int [] array) &#123;</span><br><span class="line">           Arrays.sort(array);</span><br><span class="line">           int target &#x3D; array[array.length &#x2F; 2];</span><br><span class="line">           int count &#x3D; 0;</span><br><span class="line">           for (int i &#x3D; 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">               if (array[i] &#x3D;&#x3D; target)</span><br><span class="line">                   count ++;</span><br><span class="line">           &#125;</span><br><span class="line">           if (count &gt; array.length &#x2F; 2)</span><br><span class="line">               return target;</span><br><span class="line">           return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二：</span><br><span class="line">加入数组中存在众数，那么众数一定大于数组的长度的一半。</span><br><span class="line">思想就是：如果两个数不相等，就消去这两个数，最坏情况下，</span><br><span class="line">每次消去一个众数和一个非众数，那么如果存在众数，最后留下的数肯定是众数。</span><br><span class="line"></span><br><span class="line">具体做法：</span><br><span class="line"></span><br><span class="line">初始化：候选人cond &#x3D; -1， 候选人的投票次数cnt &#x3D; 0</span><br><span class="line">遍历数组，如果cnt&#x3D;0， 表示没有候选人，则选取当前数为候选人，++cnt</span><br><span class="line">否则，如果cnt &gt; 0, 表示有候选人，如果当前数&#x3D;cond，则++cnt，否则--cnt</span><br><span class="line">直到数组遍历完毕，最后检查cond是否为众数</span><br><span class="line"></span><br><span class="line">时间复杂度O(n) 空间O(1)</span><br><span class="line">*&#x2F;</span><br><span class="line">    public int MoreThanHalfNum_Solution(int [] array) &#123;</span><br><span class="line">        int cond &#x3D; -1, cnt &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">            if (cnt &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                cond &#x3D; array[i];</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (array[i] &#x3D;&#x3D; cond) </span><br><span class="line">                    ++ cnt;</span><br><span class="line">                else</span><br><span class="line">                    -- cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">               if (array[i] &#x3D;&#x3D; cond)</span><br><span class="line">                   count ++;</span><br><span class="line">           &#125;</span><br><span class="line">           if (count &gt; array.length &#x2F; 2)</span><br><span class="line">               return target;</span><br><span class="line">           return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test30"><a href="#Test30" class="headerlink" title="Test30"></a>Test30</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test30 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，</span><br><span class="line">    则最小的4个数字是1,2,3,4。 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：排序后输出前k个数 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test30 &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123;</span><br><span class="line">        if (k &gt; input.length)</span><br><span class="line">            return null;</span><br><span class="line">        Arrays.sort(input);</span><br><span class="line">        ArrayList&lt;Integer&gt; list&#x3D; new ArrayList();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; k; i ++) &#123;</span><br><span class="line">            list.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二：优先队列PriorityQueue *&#x2F;</span><br></pre></td></tr></table></figure>


<p>#剑指Offer</p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/08/19/e6uyhEqAtD8sxHB.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/02/%E5%89%91%E6%8C%87Offer-Test31-Test68-md/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/08/19/7RT1GzjxUreymK2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">剑指Offer Test31 Test68</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/19/JavaGuide%E7%AC%94%E8%AE%B0/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/08/19/zAVSTgHkaJmCjoy.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaGuide笔记</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/09/02/剑指Offer-Test31-Test68-md/" title="剑指Offer Test31 Test68"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/19/7RT1GzjxUreymK2.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-02</div><div class="relatedPosts_title">剑指Offer Test31 Test68</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Yuwen Mi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>