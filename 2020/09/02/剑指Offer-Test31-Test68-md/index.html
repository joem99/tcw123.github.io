<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>剑指Offer-Test31-Test68.md | Yuwen Mi's Space</title><meta name="description" content="Test311234567891011121314151617181920212223&#x2F;* Test31 给一个数组，返回它的最大连续子序列的和 例如:&amp;#123;6,-3,-2,7,-15,1,2,2&amp;#125;,连续子向量的最大和为8(从第0个开始,到第3个为止)。 *&#x2F;&#x2F;*状态定义：dp[i]表示以array[i]结尾的连续子数组的最大和。所以最终要求dp[n]"><meta name="keywords" content="剑指Offer"><meta name="author" content="Yuwen Mi,mywjyw@foxmail.com"><meta name="copyright" content="Yuwen Mi"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/09/02/%E5%89%91%E6%8C%87Offer-Test31-Test68-md/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="剑指Offer-Test31-Test68.md"><meta property="og:url" content="http://yoursite.com/2020/09/02/%E5%89%91%E6%8C%87Offer-Test31-Test68-md/"><meta property="og:site_name" content="Yuwen Mi's Space"><meta property="og:description" content="Test311234567891011121314151617181920212223&#x2F;* Test31 给一个数组，返回它的最大连续子序列的和 例如:&amp;#123;6,-3,-2,7,-15,1,2,2&amp;#125;,连续子向量的最大和为8(从第0个开始,到第3个为止)。 *&#x2F;&#x2F;*状态定义：dp[i]表示以array[i]结尾的连续子数组的最大和。所以最终要求dp[n]"><meta property="og:image" content="https://i.loli.net/2020/08/19/zAVSTgHkaJmCjoy.png"><meta property="article:published_time" content="2020-09-02T06:59:13.000Z"><meta property="article:modified_time" content="2020-09-02T07:01:32.400Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-02 15:01:32'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.1"><link rel="alternate" href="/atom.xml" title="Yuwen Mi's Space" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">3</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Test31"><span class="toc-number">1.</span> <span class="toc-text">Test31</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test32"><span class="toc-number">2.</span> <span class="toc-text">Test32</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test33"><span class="toc-number">3.</span> <span class="toc-text">Test33</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test34"><span class="toc-number">4.</span> <span class="toc-text">Test34</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test35"><span class="toc-number">5.</span> <span class="toc-text">Test35</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test36"><span class="toc-number">6.</span> <span class="toc-text">Test36</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test37"><span class="toc-number">7.</span> <span class="toc-text">Test37</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test38"><span class="toc-number">8.</span> <span class="toc-text">Test38</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test39"><span class="toc-number">9.</span> <span class="toc-text">Test39</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test40"><span class="toc-number">10.</span> <span class="toc-text">Test40</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test41"><span class="toc-number">11.</span> <span class="toc-text">Test41</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test42"><span class="toc-number">12.</span> <span class="toc-text">Test42</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test43"><span class="toc-number">13.</span> <span class="toc-text">Test43</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test44"><span class="toc-number">14.</span> <span class="toc-text">Test44</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test45"><span class="toc-number">15.</span> <span class="toc-text">Test45</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test46"><span class="toc-number">16.</span> <span class="toc-text">Test46</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test47"><span class="toc-number">17.</span> <span class="toc-text">Test47</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test48"><span class="toc-number">18.</span> <span class="toc-text">Test48</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test49"><span class="toc-number">19.</span> <span class="toc-text">Test49</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test50"><span class="toc-number">20.</span> <span class="toc-text">Test50</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test51"><span class="toc-number">21.</span> <span class="toc-text">Test51</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test52"><span class="toc-number">22.</span> <span class="toc-text">Test52</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test53"><span class="toc-number">23.</span> <span class="toc-text">Test53</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test54"><span class="toc-number">24.</span> <span class="toc-text">Test54</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test55"><span class="toc-number">25.</span> <span class="toc-text">Test55</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test56"><span class="toc-number">26.</span> <span class="toc-text">Test56</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test57"><span class="toc-number">27.</span> <span class="toc-text">Test57</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test58"><span class="toc-number">28.</span> <span class="toc-text">Test58</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test59"><span class="toc-number">29.</span> <span class="toc-text">Test59</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test60"><span class="toc-number">30.</span> <span class="toc-text">Test60</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test61"><span class="toc-number">31.</span> <span class="toc-text">Test61</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test62"><span class="toc-number">32.</span> <span class="toc-text">Test62</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test63"><span class="toc-number">33.</span> <span class="toc-text">Test63</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test64"><span class="toc-number">34.</span> <span class="toc-text">Test64</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test65"><span class="toc-number">35.</span> <span class="toc-text">Test65</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test66"><span class="toc-number">36.</span> <span class="toc-text">Test66</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test67"><span class="toc-number">37.</span> <span class="toc-text">Test67</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test68"><span class="toc-number">38.</span> <span class="toc-text">Test68</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/08/19/zAVSTgHkaJmCjoy.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Yuwen Mi's Space</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">剑指Offer-Test31-Test68.md</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-02T06:59:13.000Z" title="发表于 2020-09-02 14:59:13">2020-09-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-02T07:01:32.400Z" title="更新于 2020-09-02 15:01:32">2020-09-02</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Test31"><a href="#Test31" class="headerlink" title="Test31"></a>Test31</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test31 给一个数组，返回它的最大连续子序列的和 </span><br><span class="line">例如:&#123;6,-3,-2,7,-15,1,2,2&#125;,连续子向量的最大和为8(从第0个开始,到第3个为止)。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">状态定义：dp[i]表示以array[i]结尾的连续子数组的最大和。所以最终要求dp[n]</span><br><span class="line">状态转移方程：dp[i] &#x3D; max(array[i], dp[i-1]+array[i])</span><br><span class="line">解释：如果当前元素为整数，并且dp[i-1]为负数，那么当然结果就是只选当前元素</span><br><span class="line">*&#x2F;</span><br><span class="line">import java.lang.Math;</span><br><span class="line"></span><br><span class="line">public class Test31 &#123;</span><br><span class="line">    public int FindGreatestSumOfSubArray(int[] array) &#123;</span><br><span class="line">        int[] dp &#x3D; new int[array.length];</span><br><span class="line">        dp[0] &#x3D; array[0];</span><br><span class="line">        int res &#x3D; array[0];</span><br><span class="line">        for (int i &#x3D; 1; i &lt; dp.length; i ++) &#123;</span><br><span class="line">            dp[i] &#x3D; Math.max(dp[i - 1] + array[i], array[i]);</span><br><span class="line">            res &#x3D; Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Test32"><a href="#Test32" class="headerlink" title="Test32"></a>Test32</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">未完成</span><br></pre></td></tr></table></figure>

<h1 id="Test33"><a href="#Test33" class="headerlink" title="Test33"></a>Test33</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test33 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</span><br><span class="line">    例如输入数组&#123;3，32，321&#125;，则打印出这三个数字能排成的最小数字为321323。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 遍历整个数组进行从小到大的排序，数组元素a、b间的比较通过比较ab和ba的大小 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test33 &#123;</span><br><span class="line">    public String PrintMinNumber(int [] numbers) &#123;</span><br><span class="line">        if (numbers &#x3D;&#x3D; null || numbers.length &#x3D;&#x3D; 0)</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numbers.length; i ++) &#123;</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; numbers.length; j ++) &#123;</span><br><span class="line">                int ab &#x3D; Integer.valueOf(numbers[i]+&quot;&quot;+numbers[j]);</span><br><span class="line">                int ba &#x3D; Integer.valueOf(numbers[j]+&quot;&quot;+numbers[i]);</span><br><span class="line">                if (ab &gt; ba) &#123;</span><br><span class="line">                    int tmp &#x3D; numbers[j];</span><br><span class="line">                    numbers[j] &#x3D; numbers[i];</span><br><span class="line">                    numbers[i] &#x3D; tmp; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numbers.length; i ++) &#123;</span><br><span class="line">            str &#x3D; str + numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test34"><a href="#Test34" class="headerlink" title="Test34"></a>Test34</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test34 把只包含质因子2、3和5的数称作丑数（Ugly Number）。</span><br><span class="line">例如6、8都是丑数，但14不是，因为它包含质因子7。 </span><br><span class="line">习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 只包含质因子2、3、5，所以丑数可以表示为2^x3^y5^z</span><br><span class="line">    所以可以把已得到的丑数乘以2、3、5来得到新的丑数。</span><br><span class="line">    维持三个指针来记录当前乘以2、乘以3、乘以5的最小值，</span><br><span class="line">    然后当其被选为新的最小值后，要把相应的指针+1； *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.lang.Math;</span><br><span class="line"></span><br><span class="line">public class Test34 &#123;</span><br><span class="line">    public int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">        if (index &lt;&#x3D; 0)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; p2指向的数*2是所有*2可以得到的数最小的</span><br><span class="line">        int p2 &#x3D; 0, p3 &#x3D; 0, p5 &#x3D; 0;</span><br><span class="line">        int[] res &#x3D; new int [index];</span><br><span class="line">        res[0] &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; index; i ++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到当前最小的丑数</span><br><span class="line">            res[i] &#x3D; Math.min(res[p2] * 2, Math.min(res[p3] * 3, res[p5] * 5));</span><br><span class="line">            &#x2F;&#x2F; 更新三个指针</span><br><span class="line">            if (res[i] &#x3D;&#x3D; res[p2] * 2) p2++;</span><br><span class="line">            if (res[i] &#x3D;&#x3D; res[p3] * 3) p3++;</span><br><span class="line">            if (res[i] &#x3D;&#x3D; res[p5] * 5) p5++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[index - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test35"><a href="#Test35" class="headerlink" title="Test35"></a>Test35</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test35 在一个字符串(0&lt;&#x3D;字符串长度&lt;&#x3D;10000，全部由字母组成)中找到第一个</span><br><span class="line">只出现一次的字符,并返回它的位置, 如果没有则返回 -1</span><br><span class="line">（需要区分大小写）.（从0开始计数） *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* hash法，创建一个数组，索引表示字符，对应的数据表示出现的次数 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test35 &#123;</span><br><span class="line">    public int FirstNotRepeatingChar(String str) &#123;</span><br><span class="line">        if (str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D; 0)</span><br><span class="line">            return -1;</span><br><span class="line"></span><br><span class="line">        int[] count &#x3D; new int[256]; &#x2F;&#x2F; 256 ASC码种类数</span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length(); i ++) &#123;</span><br><span class="line">            count[str.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 查找有没有只出现一次的</span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length(); i ++) &#123;</span><br><span class="line">            if (count[str.charAt(i)] &#x3D;&#x3D; 1)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test36"><a href="#Test36" class="headerlink" title="Test36"></a>Test36</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test36 在数组中的两个数字，如果前面一个数字大于后面的数字，</span><br><span class="line">则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。</span><br><span class="line">并将P对1000000007取模的结果输出。 即输出P%1000000007 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：固定一个元素，遍历之后的元素找逆序对 O(n2) *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*方法二：进行归并排序的同时统计逆序对的个数 *&#x2F;</span><br></pre></td></tr></table></figure>

<h1 id="Test37"><a href="#Test37" class="headerlink" title="Test37"></a>Test37</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test37 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，</span><br><span class="line">所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一 固定第一个链表，遍历第二个O(n2) *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test37 &#123;</span><br><span class="line">    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;</span><br><span class="line">        ListNode node1 &#x3D; pHead1;</span><br><span class="line">        ListNode node2;</span><br><span class="line"></span><br><span class="line">        while (node1 !&#x3D; null) &#123;</span><br><span class="line">            node2 &#x3D; pHead2;</span><br><span class="line">            while (node2 !&#x3D; null) &#123;</span><br><span class="line">                if (node2 &#x3D;&#x3D; node1)</span><br><span class="line">                    return node1;</span><br><span class="line">                node2 &#x3D; node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node1 &#x3D; node1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二 双指针法，两链表有公共节点，所以公共节点后的链表相同。</span><br><span class="line">    想办法让公共节点前的节点数相同。a+b&#x3D;b+a，让b+a作为新的链表A，a+b作为新的B</span><br><span class="line">    此时对两个新链表来说，目标公共节点在两新链表相同的位置 *&#x2F;</span><br><span class="line"></span><br><span class="line">    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;</span><br><span class="line">        if (pHead1 &#x3D;&#x3D; null || pHead2 &#x3D;&#x3D; null) return null;</span><br><span class="line">        ListNode node1 &#x3D; pHead1;</span><br><span class="line">        ListNode node2 &#x3D; pHead2;</span><br><span class="line"></span><br><span class="line">        while (node1 !&#x3D; node2) &#123;</span><br><span class="line">            node1 &#x3D; node1.next;</span><br><span class="line">            node2 &#x3D; node2.next;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 公共节点可能 为null，所以这里要判断一下</span><br><span class="line">            if (node1 !&#x3D; node2) &#123;</span><br><span class="line">                if (node1 &#x3D;&#x3D; null) node1 &#x3D; pHead2;</span><br><span class="line">                if (node2 &#x3D;&#x3D; null) node2 &#x3D; pHead1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return node1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test38"><a href="#Test38" class="headerlink" title="Test38"></a>Test38</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test38 统计一个数字在非降序数组中出现的次数。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 有序的数组，所以采用二分法，找到开头的k和最后的k *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test38 &#123;</span><br><span class="line">    public int GetNumberOfK(int [] array , int k) &#123;</span><br><span class="line">       if (array.length &#x3D;&#x3D; 0)</span><br><span class="line">           return 0;</span><br><span class="line">       int firstK &#x3D; findFirstK(array, k, 0, array.length - 1);</span><br><span class="line">       int lastK &#x3D; findLastK(array, k, 0, array.length - 1);</span><br><span class="line">       int count &#x3D; 0;</span><br><span class="line">       if (firstK !&#x3D; -1 &amp;&amp; lastK !&#x3D; -1) &#123;</span><br><span class="line">           count &#x3D; lastK - firstK + 1;</span><br><span class="line">       &#125;</span><br><span class="line">       return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用递归实现二分查找第一个k</span><br><span class="line">    public int findFirstK(int [] array, int k, int start, int end) &#123;</span><br><span class="line">        if (start &gt; end)</span><br><span class="line">            return -1;</span><br><span class="line">        int mid &#x3D; (start + end) &gt;&gt; 1;</span><br><span class="line">        if (k &lt; array[mid]) &#123;</span><br><span class="line">            return findFirstK(array, k, start, mid - 1);</span><br><span class="line">        &#125; else if (k &gt; array[mid]) &#123;</span><br><span class="line">            return findFirstK(array, k, mid + 1, end);</span><br><span class="line">        &#125; else if (mid - 1 &gt;&#x3D; 0 &amp;&amp; array[mid - 1] &#x3D;&#x3D; k) &#123;</span><br><span class="line">            return findFirstK(array, k , start, mid - 1);</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; mid位置就是第一个k</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用循环实现二分查找最后一个k</span><br><span class="line">    public int findLastK(int [] array, int k, int start, int end) &#123;</span><br><span class="line">        int mid &#x3D; (start + end) &gt;&gt; 1;        </span><br><span class="line">        while (start &lt;&#x3D; end) &#123;</span><br><span class="line">            if (k &lt; array[mid]) &#123;</span><br><span class="line">                end &#x3D; mid - 1;</span><br><span class="line">            &#125; else if (k &gt; array[mid]) &#123;</span><br><span class="line">                start &#x3D; mid + 1;</span><br><span class="line">            &#125; else if (mid + 1 &lt; array.length &amp;&amp; array[mid + 1] &#x3D;&#x3D; k) &#123; &#x2F;&#x2F; 注意这里跟上一个函数的区别</span><br><span class="line">                start &#x3D; mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">            mid &#x3D; (start + end) &gt;&gt; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test39"><a href="#Test39" class="headerlink" title="Test39"></a>Test39</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test39 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点</span><br><span class="line">（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 递归，树深度&#x3D;左子树深度和右子树深度的较大值+1 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.lang.Math;</span><br><span class="line"></span><br><span class="line">public class Test39 &#123;</span><br><span class="line">    public int TreeDepth(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null)</span><br><span class="line">            return 0;</span><br><span class="line">        int leftDepth &#x3D; TreeDepth(root.left);</span><br><span class="line">        int rightDepth &#x3D; TreeDepth(root.right);</span><br><span class="line"></span><br><span class="line">        int depth &#x3D; Math.max(leftDepth, rightDepth) + 1;</span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test40"><a href="#Test40" class="headerlink" title="Test40"></a>Test40</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test40 输入一棵二叉树，判断该二叉树是否是平衡二叉树。</span><br><span class="line">在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 平衡二叉树的左右子树高度差不超过1，且左右子树也应为平衡二叉树；</span><br><span class="line">    在上一题实现了计算二叉树高度的函数，对其进行改进, 若不为平衡二叉树则返回-1 *&#x2F;</span><br><span class="line">import java.lang.Math;</span><br><span class="line"></span><br><span class="line">public class Test40 &#123;</span><br><span class="line"></span><br><span class="line">    public int depth(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null)</span><br><span class="line">            return 0;</span><br><span class="line">        int leftDepth &#x3D; depth(root.left);</span><br><span class="line">        if (leftDepth &#x3D;&#x3D; -1) &#x2F;&#x2F; 左子树不是平衡二叉树</span><br><span class="line">            return -1;</span><br><span class="line">        int rightDepth &#x3D; depth(root.right);</span><br><span class="line">        if (rightDepth &#x3D;&#x3D; -1)</span><br><span class="line">            return -1;</span><br><span class="line">        &#x2F;&#x2F; 判断当前树是否为平衡二叉树</span><br><span class="line">        int diff &#x3D; Math.abs(leftDepth - rightDepth);</span><br><span class="line">        if (diff &gt; 1) </span><br><span class="line">            return -1;</span><br><span class="line">        else &#123;</span><br><span class="line">            return 1 + Math.max(leftDepth, rightDepth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean IsBalanced_Solution(TreeNode root) &#123;</span><br><span class="line">        &#x2F;&#x2F; 非平衡二叉树depth返回-1</span><br><span class="line">        return depth(root) !&#x3D; -1;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="Test41"><a href="#Test41" class="headerlink" title="Test41"></a>Test41</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test41 一个整型数组里除了两个数字之外，其他的数字都出现了两次。</span><br><span class="line">请写程序找出这两个只出现一次的数字。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：用HashMap *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二：相同的数异或结果为0，所以该数组中所有元素异或后的结果</span><br><span class="line">    应为两个目标数异或的结果。根据异或结果可以知道两个目标数的哪一位</span><br><span class="line">    不相同（该位为1）。此时再根据这一位为0&#x2F;1将原数组分为两组，相同的数都在</span><br><span class="line">    同一组，两目标数在不同组。分别异或可以得到两个目标数 *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test41 &#123;</span><br><span class="line">    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123;</span><br><span class="line">        int xor &#x3D; 0; &#x2F;&#x2F; 所有数的异或结果</span><br><span class="line">        for (int i &#x3D; 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">            xor &#x3D; xor ^ array[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 找到两数不同的位</span><br><span class="line">        int index &#x3D; 1;</span><br><span class="line">        while ((index &amp; xor) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            index &#x3D; index &lt;&lt; 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 保存两类数组异或的结果</span><br><span class="line">        int res1 &#x3D; 0;</span><br><span class="line">        int res2 &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">            if ((index &amp; array[i]) &#x3D;&#x3D; 0)</span><br><span class="line">                res1 &#x3D; res1 ^ array[i];</span><br><span class="line">            else </span><br><span class="line">                res2 &#x3D; res2 ^ array[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        num1[0] &#x3D; res1;</span><br><span class="line">        num2[0] &#x3D; res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test42"><a href="#Test42" class="headerlink" title="Test42"></a>Test42</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test42 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,</span><br><span class="line">他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种</span><br><span class="line">连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:</span><br><span class="line">18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：算出从1到i之和sum[i]，则m到n之和为 sum[m]-sum[n] *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二：滑动窗口</span><br><span class="line">扩大窗口，j +&#x3D; 1</span><br><span class="line">缩小窗口，i +&#x3D; 1</span><br><span class="line">算法步骤：</span><br><span class="line">初始化，i&#x3D;1,j&#x3D;1, 表示窗口大小为0</span><br><span class="line">如果窗口中值的和小于目标值sum， 表示需要扩大窗口，j +&#x3D; 1</span><br><span class="line">否则，如果狂口值和大于目标值sum，表示需要缩小窗口，i +&#x3D; 1</span><br><span class="line">否则，等于目标值，存结果，缩小窗口，继续进行步骤2,3,4 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test42 &#123;</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll &#x3D; new ArrayList();</span><br><span class="line">        &#x2F;&#x2F; 初始化两个窗口</span><br><span class="line">        int i &#x3D; 1;</span><br><span class="line">        int j &#x3D; 2;</span><br><span class="line">        int sumCur &#x3D; i + j; &#x2F;&#x2F; 当前窗口所有数之和</span><br><span class="line"></span><br><span class="line">        while (i &lt;&#x3D; sum &#x2F; 2) &#123;</span><br><span class="line">            if (sumCur &lt; sum) &#123;</span><br><span class="line">                j ++;</span><br><span class="line">                sumCur +&#x3D; j;</span><br><span class="line">            &#125; else if (sumCur &gt; sum) &#123;</span><br><span class="line">                sumCur -&#x3D; i;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; 当前窗口值之和&#x3D;sum</span><br><span class="line">                ArrayList&lt;Integer&gt; list &#x3D; new ArrayList();</span><br><span class="line">                for (int m &#x3D; i; m &lt;&#x3D; j; m ++) &#123;</span><br><span class="line">                    list.add(m);</span><br><span class="line">                &#125;</span><br><span class="line">                listAll.add(list);</span><br><span class="line"></span><br><span class="line">                j ++;</span><br><span class="line">                sumCur +&#x3D; j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test43"><a href="#Test43" class="headerlink" title="Test43"></a>Test43</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test43 输入一个递增排序的数组和一个数字S，在数组中查找两个数，</span><br><span class="line">使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 双指针 分别指向首尾*&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 暴力 *&#x2F;</span><br><span class="line">public class Test43 &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList();</span><br><span class="line"></span><br><span class="line">        int sumCur &#x3D; 0;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int j &#x3D; 1;</span><br><span class="line">        for (i &#x3D; 0; i &lt; j; i ++) &#123;</span><br><span class="line">            for (j &#x3D; i + 1; j &lt; array.length; j ++) &#123;</span><br><span class="line">                sumCur &#x3D; array[i] + array[j];</span><br><span class="line">                if (sumCur &#x3D;&#x3D; sum) &#123;</span><br><span class="line">                    list.add(array[i]);</span><br><span class="line">                    list.add(array[j]);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sumCur &#x3D;&#x3D; sum) break;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 双指针分别指向首位 *&#x2F;</span><br><span class="line">    public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList();</span><br><span class="line">        if (array &#x3D;&#x3D; null  || array.length &#x3D;&#x3D; 0) </span><br><span class="line">            return list;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int j &#x3D; array.length - 1;</span><br><span class="line">        int sumCur &#x3D; array[i] + array[j];</span><br><span class="line"></span><br><span class="line">        while (array[i] &lt;&#x3D; sum &#x2F; 2) &#123;</span><br><span class="line">            if (sumCur &gt; sum) &#123;</span><br><span class="line">                j --;</span><br><span class="line">                sumCur &#x3D; array[i] + array[j];</span><br><span class="line">            &#125; else if (sumCur &lt; sum) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">                sumCur &#x3D; array[i] + array[j];                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                   list.add(array[i]);</span><br><span class="line">                   list.add(array[j]);</span><br><span class="line">                   break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test44"><a href="#Test44" class="headerlink" title="Test44"></a>Test44</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test44 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，</span><br><span class="line">就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，</span><br><span class="line">请你把其循环左移K位后的序列输出。例如，字符序列S&#x3D;”abcXYZdef”,</span><br><span class="line">要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test44 &#123;</span><br><span class="line">    public String LeftRotateString(String str,int n) &#123;</span><br><span class="line">        if (str &#x3D;&#x3D; null || n &gt; str.length())</span><br><span class="line">            return str;</span><br><span class="line"></span><br><span class="line">        return str.substring(n) + str.substring(0, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test45"><a href="#Test45" class="headerlink" title="Test45"></a>Test45</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test45 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，</span><br><span class="line">写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，</span><br><span class="line">但却读不懂它的意思。例如，“student. a am I”。后来才意识到，</span><br><span class="line">这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。</span><br><span class="line">Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 先对整个字符串进行反转，在对反转后的每个单词进行反转 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test45 &#123;</span><br><span class="line">    public String ReverseSentence(String str) &#123;</span><br><span class="line">        if (str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D; 0)</span><br><span class="line">            return str;</span><br><span class="line"></span><br><span class="line">        char[] chars &#x3D; str.toCharArray();</span><br><span class="line">        &#x2F;&#x2F; 对原字符串进行翻转</span><br><span class="line">        reverse(chars, 0, chars.length - 1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 分别指向一个单词的最后一个字母和最后一个字母</span><br><span class="line">        int start &#x3D; 0;</span><br><span class="line">        int end &#x3D; 0;</span><br><span class="line">        while (start &lt; chars.length) &#123;</span><br><span class="line">            if (end &#x3D;&#x3D; chars.length || chars[end] &#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 遇到空格或最后说明当前start到end为一个单词</span><br><span class="line">                reverse(chars, start, end - 1);</span><br><span class="line">                start &#x3D; ++ end; &#x2F;&#x2F; 指向下一个单词</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                end ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reverse(char[] chars, int begin, int end) &#123;</span><br><span class="line">        while (begin &lt; end) &#123;</span><br><span class="line">            char tmp &#x3D; chars[end];</span><br><span class="line">            chars[end] &#x3D; chars[begin];</span><br><span class="line">            chars[begin] &#x3D; tmp;</span><br><span class="line">            begin ++;</span><br><span class="line">            end --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test46"><a href="#Test46" class="headerlink" title="Test46"></a>Test46</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test46 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,</span><br><span class="line">2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,</span><br><span class="line">看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,</span><br><span class="line">小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王</span><br><span class="line">可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”</span><br><span class="line">(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,</span><br><span class="line">要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， </span><br><span class="line">如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 输入数组需要满足以下几个条件：</span><br><span class="line">    1.数组长度为5</span><br><span class="line">    2.max-min&lt;5</span><br><span class="line">    3.数组元素除大小王外不重复</span><br><span class="line">    用TreeSet顺序保存元素 *&#x2F;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class Test46 &#123;</span><br><span class="line">    public boolean isContinuous(int [] numbers) &#123;</span><br><span class="line">        if (numbers.length !&#x3D; 5)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        int sum &#x3D; 0; &#x2F;&#x2F; 大小王个数</span><br><span class="line">        TreeSet&lt;Integer&gt; set &#x3D; new TreeSet();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; numbers.length; i ++) &#123;</span><br><span class="line">            if (numbers[i] &#x3D;&#x3D; 0)</span><br><span class="line">                sum++;</span><br><span class="line">            else </span><br><span class="line">                set.add(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (sum + set.size() !&#x3D; 5) </span><br><span class="line">            return false;</span><br><span class="line">        if (set.last() - set.first() &gt;&#x3D; 5)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test47"><a href="#Test47" class="headerlink" title="Test47"></a>Test47</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test47 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,</span><br><span class="line">今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,</span><br><span class="line">有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,</span><br><span class="line">让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,</span><br><span class="line">然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,</span><br><span class="line">继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,</span><br><span class="line">并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,</span><br><span class="line">哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</span><br><span class="line"></span><br><span class="line">如果没有小朋友，请返回-1 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：数学公式推导 *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二：用LinkedList模拟游戏过程 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class Test47 &#123;</span><br><span class="line">    public int LastRemaining_Solution(int n, int m) &#123;</span><br><span class="line">        if (n &#x3D;&#x3D; 0)</span><br><span class="line">            return -1;</span><br><span class="line">        LinkedList&lt;Integer&gt; list &#x3D; new LinkedList();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; list初始化小朋友编号</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i ++) &#123;</span><br><span class="line">             list.add(i);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        int del &#x3D; 0; &#x2F;&#x2F; 每次出队的小朋友</span><br><span class="line">        while (list.size() !&#x3D; 1) &#123;</span><br><span class="line">            del &#x3D; (del + m - 1) % list.size();</span><br><span class="line">            list.remove(del);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test48"><a href="#Test48" class="headerlink" title="Test48"></a>Test48</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test48 求1+2+3+...+n，要求不能使用乘除法、</span><br><span class="line">for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 求累加一般需要通过求和公式或者循环求和，但根据题目要求这两种都不能用，</span><br><span class="line">    所以需要用到递归,</span><br><span class="line">    很容易实现递归 当n&#x3D;1时返回n 其他情况返回n+sum(n-1)。但是考虑到不能用if语句，</span><br><span class="line">    所以需要用到短路求值，即&amp;&amp;语句，以a&amp;&amp;b为例，若a已经为0，则不会执行b*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test48 &#123;</span><br><span class="line">    public int Sum_Solution(int n) &#123;</span><br><span class="line">        boolean tmp;</span><br><span class="line">        tmp &#x3D; (n &gt; 1) &amp;&amp; ((n +&#x3D; Sum_Solution(n - 1)) &gt; 0);</span><br><span class="line">        return n; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Test49"><a href="#Test49" class="headerlink" title="Test49"></a>Test49</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test49 写一个函数，求两个整数之和，要求在函数体内</span><br><span class="line">不得使用+、-、*、&#x2F;四则运算符号。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 不能用加减乘除，所以肯定是用位操作，考虑到加法的过程，</span><br><span class="line">    x^y执行加法,(x&amp;y)&lt;&lt;1执行进位操作 ；</span><br><span class="line">    每次加法操作相当于进行位加法和进行操作，知道进位为0为止 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test49 &#123;</span><br><span class="line">    public int Add(int num1,int num2) &#123;</span><br><span class="line">        int res &#x3D; 0; &#x2F;&#x2F; 位加法结果</span><br><span class="line">        int carry &#x3D; 0; &#x2F;&#x2F; 进位结果</span><br><span class="line"></span><br><span class="line">        do &#123;</span><br><span class="line">            res &#x3D; num1 ^ num2;</span><br><span class="line">            carry &#x3D; (num1 &amp; num2) &lt;&lt; 1;</span><br><span class="line"></span><br><span class="line">            num1 &#x3D; res;</span><br><span class="line">            num2 &#x3D; carry;</span><br><span class="line">        &#125; while (carry !&#x3D; 0);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test50"><a href="#Test50" class="headerlink" title="Test50"></a>Test50</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test50 将一个字符串转换成一个整数，</span><br><span class="line">要求不能使用字符串转换整数的库函数。 </span><br><span class="line">数值为0或者字符串不是一个合法的数值则返回0 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test50 &#123;</span><br><span class="line">    public int StrToInt(String str) &#123;</span><br><span class="line">        if (str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D; 0)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        boolean negative &#x3D; false; &#x2F;&#x2F; 输入是否为负数</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        int limit &#x3D; Integer.MAX_VALUE; &#x2F;&#x2F; 允许的正数的最大值</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        int digit; &#x2F;&#x2F; 循环时的当前位</span><br><span class="line">        &#x2F;&#x2F; 进行正负判断</span><br><span class="line">        char signal &#x3D; str.charAt(0);</span><br><span class="line">        if (signal &lt; &#39;0&#39;) &#123; &#x2F;&#x2F; 为&#39;+&#39;&#x2F;&#39;-&#39;</span><br><span class="line">            if (signal &#x3D;&#x3D; &#39;-&#39;) &#123; &#x2F;&#x2F; 负数</span><br><span class="line">                negative &#x3D; true;</span><br><span class="line">                limit &#x3D; Integer.MIN_VALUE;</span><br><span class="line">            &#125; else if (signal !&#x3D; &#39;+&#39;) &#123; &#x2F;&#x2F; 不是合法的 数</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (str.length() &#x3D;&#x3D; 1)</span><br><span class="line">                return 0;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int multmin &#x3D; limit &#x2F; 10; </span><br><span class="line">        while (i &lt; str.length()) &#123;</span><br><span class="line">            digit &#x3D; str.charAt(i) - &#39;0&#39;;</span><br><span class="line">            if (digit &lt; 0 || digit &gt; 9)</span><br><span class="line">                return 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 对是否溢出进行判断</span><br><span class="line">            if (negative) &#123;</span><br><span class="line">                if (res &lt; multmin)</span><br><span class="line">                    return 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (res &gt; multmin)</span><br><span class="line">                    return 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res *&#x3D; 10;</span><br><span class="line"></span><br><span class="line">            if (negative) &#123;</span><br><span class="line">                if (res - digit &lt; limit)</span><br><span class="line">                    return 0;</span><br><span class="line">                res -&#x3D; digit;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (res + digit &gt; limit)</span><br><span class="line">                    return 0;</span><br><span class="line">                res +&#x3D; digit;</span><br><span class="line">            &#125;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test51"><a href="#Test51" class="headerlink" title="Test51"></a>Test51</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test51 在一个长度为n的数组里的所有数字都在0到n-1的范围内。</span><br><span class="line">数组中某些数字是重复的，但不知道有几个数字是重复的。</span><br><span class="line">也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</span><br><span class="line"> 例如，如果输入长度为7的数组&#123;2,3,1,0,2,5,3&#125;，</span><br><span class="line"> 那么对应的输出是第一个重复的数字2。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 用lenth长度的boolen表示数组中的各元素有没有重复出现 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test51 &#123;</span><br><span class="line">    public boolean duplicate(int numbers[],int length,int [] duplication) &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认初始化都为false</span><br><span class="line">        boolean[] status &#x3D; new boolean[length];</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i ++) &#123;</span><br><span class="line">            if (status[numbers[i]]) &#123;&#x2F;&#x2F; 重复遇见第i个元素</span><br><span class="line">                duplication[0] &#x3D; numbers[i];</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            status[numbers[i]] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test52"><a href="#Test52" class="headerlink" title="Test52"></a>Test52</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test52 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],</span><br><span class="line">其中B中的元素B[i]&#x3D;A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。</span><br><span class="line">不能使用除法。（注意：规定B[0] &#x3D; A[1] * A[2] * ... * A[n-1]，</span><br><span class="line">B[n-1] &#x3D; A[0] * A[1] * ... * A[n-2];）</span><br><span class="line">对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 下三角用连乘可以很容求得，上三角，从下向上也是连乘。</span><br><span class="line">因此我们的思路就很清晰了，先算下三角中的连乘，</span><br><span class="line">即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，</span><br><span class="line">把另一部分也乘进去。 *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test52 &#123;</span><br><span class="line">    public int[] multiply(int[] A) &#123;</span><br><span class="line">        int[] B &#x3D; new int[A.length];</span><br><span class="line"></span><br><span class="line">        if (A.length !&#x3D; 0) &#123;</span><br><span class="line">            B[0] &#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F; B的下三角部分</span><br><span class="line">            for (int i &#x3D; 1; i &lt; B.length; i ++) &#123;</span><br><span class="line">                B[i] &#x3D; B[i - 1] * A[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 计算B的上三角部分</span><br><span class="line">            int tmp &#x3D; 1;</span><br><span class="line">            for (int i &#x3D; B.length - 2; i &gt;&#x3D; 0; i --) &#123;</span><br><span class="line">                tmp *&#x3D; A[i + 1];</span><br><span class="line">                B[i] *&#x3D; tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return B;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test53"><a href="#Test53" class="headerlink" title="Test53"></a>Test53</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test53 请实现一个函数用来匹配包括&#39;.&#39;和&#39;*&#39;的正则表达式。模式中的字符&#39;.&#39;表示任意一个字符，</span><br><span class="line">而&#39;*&#39;表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。</span><br><span class="line">例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* </span><br><span class="line">当模式中的第二个字符是“*”时：</span><br><span class="line">如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：</span><br><span class="line">1、模式后移2字符，相当于x*被忽略；</span><br><span class="line">2、字符串后移1字符，模式后移2字符；</span><br><span class="line">3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；</span><br><span class="line"></span><br><span class="line">当模式中的第二个字符不是“*”时：</span><br><span class="line">1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。</span><br><span class="line">2、如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test53 &#123;</span><br><span class="line">    public boolean match(char[] str, char[] pattern) &#123;</span><br><span class="line">        if (str &#x3D;&#x3D; null || pattern &#x3D;&#x3D; null)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        return match(str, 0, pattern, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean match(char[] str, int strIndex, char[] pattern, int patternIndex) &#123;</span><br><span class="line">        &#x2F;&#x2F; 同时到达末尾则匹配成功</span><br><span class="line">        if (strIndex &#x3D;&#x3D; str.length &amp;&amp; patternIndex &#x3D;&#x3D; pattern.length) </span><br><span class="line">            return true;</span><br><span class="line">        if (strIndex !&#x3D; str.length &amp;&amp; patternIndex &#x3D;&#x3D; pattern.length)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 当前pattern的第二个字符是 *</span><br><span class="line">        if (patternIndex + 1 &lt; pattern.length &amp;&amp; pattern[patternIndex + 1] &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 第一个字符相同</span><br><span class="line">            if (strIndex !&#x3D; str.length &amp;&amp; (str[strIndex] &#x3D;&#x3D; pattern[patternIndex] || pattern[patternIndex] &#x3D;&#x3D; &#39;.&#39;)) &#123;</span><br><span class="line">                return match(str, strIndex, pattern, patternIndex + 2) &#x2F;&#x2F; *不匹配字符</span><br><span class="line">                    || match(str, strIndex + 1, pattern, patternIndex + 2) &#x2F;&#x2F; *匹配1个字符</span><br><span class="line">                    || match(str, strIndex + 1, pattern, patternIndex); &#x2F;&#x2F; *匹配后继续匹配str中的下一个</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; 第一个字符不相同</span><br><span class="line">                return match(str, strIndex, pattern, patternIndex + 2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 当前pattern第二个字符不是 *,且str第一个字符和pattern第一个 字符匹配，都后移一位</span><br><span class="line">        if (strIndex !&#x3D; str.length &amp;&amp; (str[strIndex] &#x3D;&#x3D; pattern[patternIndex] || pattern[patternIndex] &#x3D;&#x3D; &#39;.&#39;)) &#123;</span><br><span class="line">            return match(str, strIndex + 1, pattern, patternIndex + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test54"><a href="#Test54" class="headerlink" title="Test54"></a>Test54</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test54 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</span><br><span class="line">例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-16&quot;都表示数值。</span><br><span class="line"> 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：正则表达式 *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二：明确几个约束条件</span><br><span class="line"></span><br><span class="line">+-号后面必定为数字或后面为.（-.123 &#x3D; -0.123）</span><br><span class="line">+-号只出现在第一位或在eE的后一位</span><br><span class="line">.后面必定为数字或为最后一位（233. &#x3D; 233.0）</span><br><span class="line">eE后面必定为数字或+-号</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test54 &#123;</span><br><span class="line">    public boolean isNumeric(char[] str) &#123;</span><br><span class="line">        if (str.length &#x3D;&#x3D; 0)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        boolean point &#x3D; false, exp &#x3D; false; &#x2F;&#x2F; 是否已出现小数点&#x2F;指数</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length; i ++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 符号为+&#x2F;-</span><br><span class="line">            if (str[i] &#x3D;&#x3D; &#39;+&#39; || str[i] &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; + -后必须为数字或.</span><br><span class="line">                if (i + 1 &#x3D;&#x3D; str.length || !(str[i + 1] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[i + 1] &lt;&#x3D; &#39;9&#39; || str[i + 1] &#x3D;&#x3D; &#39;.&#39;))</span><br><span class="line">                    return false;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; +- 号只能出现在第一位或eE的下一位</span><br><span class="line">                if (i !&#x3D; 0 &amp;&amp; str[i - 1] !&#x3D; &#39;e&#39; &amp;&amp; str[i - 1] !&#x3D; &#39;E&#39;)</span><br><span class="line">                    return false;</span><br><span class="line">            &#125; else if (str[i] &#x3D;&#x3D; &#39;.&#39;) &#123; &#x2F;&#x2F; 符号为.</span><br><span class="line">                &#x2F;&#x2F; 不能出现在e后，有下一位且下一位不是数字则错</span><br><span class="line">                if (point || exp || !(i + 1 &lt; str.length &amp;&amp; str[i+1] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[i+1] &lt;&#x3D;&#39;9&#39;)) </span><br><span class="line">                    return false;</span><br><span class="line">                point &#x3D; true;</span><br><span class="line">            &#125; else if (str[i] &#x3D;&#x3D; &#39;e&#39; || str[i] &#x3D;&#x3D; &#39;E&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; 之前有过e&#x2F;e是最后一位&#x2F;下一位不是数字或+ -   则报错</span><br><span class="line">                if (exp || i + 1 &#x3D;&#x3D; str.length || !(str[i+1] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[i+1] &lt;&#x3D; &#39;9&#39; || str[i+1] &#x3D;&#x3D; &#39;+&#39; || str[i+1] &#x3D;&#x3D; &#39;-&#39;))</span><br><span class="line">                    return false;</span><br><span class="line">                exp &#x3D; true;</span><br><span class="line">            &#125; else if (str[i] &gt;&#x3D;  &#39;0&#39; &amp;&amp; str[i] &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; else </span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test55"><a href="#Test55" class="headerlink" title="Test55"></a>Test55</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*Test55 请实现一个函数用来找出字符流中第一个只出现一次的字符。</span><br><span class="line">例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。</span><br><span class="line">当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Test55 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 储存字符流的字符及其出现的次数 </span><br><span class="line">    HashMap&lt;Character, Integer&gt; map &#x3D; new HashMap(); </span><br><span class="line">    &#x2F;&#x2F; 储存字符流的字符</span><br><span class="line">    LinkedList&lt;Character&gt; list &#x3D; new LinkedList();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Insert one char from stringstream</span><br><span class="line">    public void Insert(char ch)  &#123;</span><br><span class="line">        if (map.containsKey(ch)) &#123;</span><br><span class="line">            map.put(ch, map.get(ch) + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.put(ch, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(ch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F;return the first appearence once char in current stringstream</span><br><span class="line">    public char FirstAppearingOnce()  &#123;</span><br><span class="line">        for(char ch : list) &#123;</span><br><span class="line">            if (map.get(ch) &#x3D;&#x3D; 1)</span><br><span class="line">                return ch;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#39;#&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test56"><a href="#Test56" class="headerlink" title="Test56"></a>Test56</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*  Test56 给一个链表，若其中包含环，</span><br><span class="line">请找出该链表的环的入口结点，否则，输出null。*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 1.判断链表中有环 -&gt; 2.得到环中节点的数目 -&gt; 3.找到环中的入口节点 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test56 &#123;</span><br><span class="line">    public ListNode EntryNodeOfLoop(ListNode pHead) &#123;</span><br><span class="line">        if (pHead &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        ListNode l &#x3D; pHead, r &#x3D; pHead; &#x2F;&#x2F; 快慢指针</span><br><span class="line">        boolean ring &#x3D; false;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断链表中是否存在环</span><br><span class="line">        while (r !&#x3D; null &amp;&amp; r.next !&#x3D; null) &#123;</span><br><span class="line">            l &#x3D; l.next;</span><br><span class="line">            r &#x3D; r.next.next;</span><br><span class="line">            if (l &#x3D;&#x3D; r) &#123;</span><br><span class="line">                ring &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!ring)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        int n &#x3D; 1; &#x2F;&#x2F; 环中节点个数 </span><br><span class="line">        r &#x3D; r.next;</span><br><span class="line">        while (r !&#x3D; l) &#123;</span><br><span class="line">            r &#x3D; r.next;</span><br><span class="line">            n ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 在得知环节点个数后，先让快指针走n个节点；</span><br><span class="line">        &#x2F;&#x2F; 再快慢指针一起走，因为环有n个节点。所以两指针会在入口处相遇</span><br><span class="line">        l &#x3D; pHead;</span><br><span class="line">        r &#x3D; pHead;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i ++) &#123;</span><br><span class="line">            r &#x3D; r.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (r !&#x3D; l) &#123;</span><br><span class="line">            l &#x3D; l.next;</span><br><span class="line">            r &#x3D; r.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test57"><a href="#Test57" class="headerlink" title="Test57"></a>Test57</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test57 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，</span><br><span class="line">重复的结点不保留，返回链表头指针。 </span><br><span class="line">例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 新增一个节点head，便于处理第一个节点就重复的情况</span><br><span class="line"></span><br><span class="line">指针l指向当前最后一个只出现一次的节点，指针r为工作节点，向后移动 *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 这题需要在好好看看 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test57 &#123;</span><br><span class="line">    public ListNode deleteDuplication(ListNode pHead) &#123;</span><br><span class="line">        if (pHead &#x3D;&#x3D; null || pHead.next &#x3D;&#x3D; null) </span><br><span class="line">            return pHead;</span><br><span class="line">        &#x2F;&#x2F; 换表头</span><br><span class="line">        ListNode head &#x3D; new ListNode(0);</span><br><span class="line">        ListNode l &#x3D; head, r &#x3D; pHead;</span><br><span class="line">        head.next &#x3D; pHead;</span><br><span class="line"></span><br><span class="line">        while (r !&#x3D; null) &#123;</span><br><span class="line">            if (r.next !&#x3D; null &amp;&amp; r.val &#x3D;&#x3D; r.next.val) &#123;</span><br><span class="line">                while (r.next !&#x3D; null &amp;&amp; r.val &#x3D;&#x3D; r.next.val) &#123;</span><br><span class="line">                    r &#x3D; r.next;</span><br><span class="line">                &#125;</span><br><span class="line">                l.next &#x3D; r.next;</span><br><span class="line">                r &#x3D; r.next;</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; r指向的节点只出现一次</span><br><span class="line">                l &#x3D; l.next;</span><br><span class="line">                r &#x3D; r.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Test58"><a href="#Test58" class="headerlink" title="Test58"></a>Test58</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test58 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。</span><br><span class="line">注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 中序遍历的下一个节点可以分为如下几种情况：</span><br><span class="line">    1.当前有点有右子树，则遍历的下一个节点为其右子树的最左侧树节点</span><br><span class="line">    2.当前节点没有右子树时，若当前节点是其父节点的左孩子，则下一个节点为父节点</span><br><span class="line">                       否则为父节点的父节点...知道当前节点作为左子树 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test58 &#123;</span><br><span class="line">    public TreeLinkNode GetNext(TreeLinkNode pNode) &#123;</span><br><span class="line">        if (pNode &#x3D;&#x3D; null) </span><br><span class="line">            return null;</span><br><span class="line">        TreeLinkNode tmp &#x3D; new TreeLinkNode(0);</span><br><span class="line">        if (pNode.right !&#x3D; null) &#123;</span><br><span class="line">            tmp &#x3D; pNode.right;</span><br><span class="line">            while (tmp.left !&#x3D; null)</span><br><span class="line">                tmp &#x3D; tmp.left;</span><br><span class="line">            return tmp;</span><br><span class="line">        &#125; </span><br><span class="line">        tmp &#x3D; pNode.next;</span><br><span class="line">        while (tmp !&#x3D; null) &#123;</span><br><span class="line">            if (pNode &#x3D;&#x3D; tmp.left)</span><br><span class="line">                return tmp;</span><br><span class="line">            tmp &#x3D; tmp.next;</span><br><span class="line">            pNode &#x3D; pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test59"><a href="#Test59" class="headerlink" title="Test59"></a>Test59</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test59 请实现一个函数，用来判断一棵二叉树是不是对称的。</span><br><span class="line">注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 对称二叉树的左右子树相同，首先是根节点及其左右子树。</span><br><span class="line">    然后左子树的根节点和右子树的根节点相同，左子树的左子树和右子树的右子树同理 </span><br><span class="line">    采用递归法 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test59 &#123;</span><br><span class="line">    boolean isSymmetrical(TreeNode pRoot) &#123;</span><br><span class="line">        if (pRoot &#x3D;&#x3D; null)</span><br><span class="line">            return true;</span><br><span class="line">        return isSymmetricalHelper(pRoot.left, pRoot.right); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean isSymmetricalHelper(TreeNode leftRoot, TreeNode rightRoot) &#123;</span><br><span class="line">        if (leftRoot &#x3D;&#x3D; null)</span><br><span class="line">            return rightRoot &#x3D;&#x3D; null;</span><br><span class="line">        else if(rightRoot &#x3D;&#x3D; null)</span><br><span class="line">            return false;</span><br><span class="line">        if (leftRoot.val !&#x3D; rightRoot.val)</span><br><span class="line">            return false;</span><br><span class="line">        return isSymmetricalHelper(leftRoot.left, rightRoot.right)</span><br><span class="line">            &amp;&amp; isSymmetricalHelper(leftRoot.right, rightRoot.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test60"><a href="#Test60" class="headerlink" title="Test60"></a>Test60</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test60 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，</span><br><span class="line">第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 两个栈，分别存奇数层和偶数层 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test60 &#123;</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack1 &#x3D; new Stack();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack2 &#x3D; new Stack();</span><br><span class="line">        if (pRoot !&#x3D; null) </span><br><span class="line">            stack1.push(pRoot);</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list &#x3D; new ArrayList();</span><br><span class="line"></span><br><span class="line">        while(!stack1.empty() || !stack2.empty()) &#123;</span><br><span class="line">            if (!stack1.empty()) &#123; &#x2F;&#x2F; 将偶数层放入栈2</span><br><span class="line">                ArrayList&lt;Integer&gt; tmp &#x3D; new ArrayList();</span><br><span class="line">                int size &#x3D; stack1.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size; i ++) &#123; &#x2F;&#x2F; 这里不能直接用stack1.size，因为pop会改变其值</span><br><span class="line">                    TreeNode top &#x3D; stack1.pop();</span><br><span class="line">                    tmp.add(top.val);</span><br><span class="line">                    if (top.left !&#x3D; null)</span><br><span class="line">                        stack2.push(top.left);</span><br><span class="line">                    if (top.right !&#x3D; null)</span><br><span class="line">                        stack2.push(top.right);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(tmp);</span><br><span class="line">            &#125;    </span><br><span class="line">            if (!stack2.empty()) &#123; &#x2F;&#x2F; 根据栈2的节点，将下一层放入stack1中</span><br><span class="line">                ArrayList&lt;Integer&gt; tmp &#x3D; new ArrayList();</span><br><span class="line">                int size &#x3D; stack2.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                    TreeNode top &#x3D; stack2.pop();</span><br><span class="line">                    tmp.add(top.val);</span><br><span class="line">                    if (top.right !&#x3D; null)</span><br><span class="line">                        stack1.push(top.right);</span><br><span class="line">                    if (top.left !&#x3D; null)</span><br><span class="line">                        stack1.push(top.left);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(tmp);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test61"><a href="#Test61" class="headerlink" title="Test61"></a>Test61</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test61 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。*&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Queue;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class Test61 &#123;</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; </span><br><span class="line">        Queue&lt;TreeNode&gt; q1 &#x3D; new LinkedList();</span><br><span class="line">        Queue&lt;TreeNode&gt; q2 &#x3D; new LinkedList();</span><br><span class="line">        if (pRoot !&#x3D; null) </span><br><span class="line">            q1.add(pRoot);</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list &#x3D; new ArrayList();</span><br><span class="line"></span><br><span class="line">        while(!q1.isEmpty() || !q2.isEmpty()) &#123;</span><br><span class="line">            if (!q1.isEmpty()) &#123; &#x2F;&#x2F; 将偶数层放入q2</span><br><span class="line">                ArrayList&lt;Integer&gt; tmp &#x3D; new ArrayList();</span><br><span class="line">                int size &#x3D; q1.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size; i ++) &#123; &#x2F;&#x2F; 这里不能直接用stack1.size，因为pop会改变其值</span><br><span class="line">                    TreeNode top &#x3D; q1.remove();</span><br><span class="line">                    tmp.add(top.val);</span><br><span class="line">                    if (top.left !&#x3D; null)</span><br><span class="line">                        q2.add(top.left);</span><br><span class="line">                    if (top.right !&#x3D; null)</span><br><span class="line">                        q2.add(top.right);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(tmp);</span><br><span class="line">            &#125;    </span><br><span class="line">            if (!q2.isEmpty()) &#123; &#x2F;&#x2F; 根据栈2的节点，将下一层放入stack1中</span><br><span class="line">                ArrayList&lt;Integer&gt; tmp &#x3D; new ArrayList();</span><br><span class="line">                int size &#x3D; q2.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                    TreeNode top &#x3D; q2.remove();</span><br><span class="line">                    tmp.add(top.val);</span><br><span class="line">                    if (top.left !&#x3D; null)</span><br><span class="line">                        q1.add(top.left);</span><br><span class="line">                    if (top.right !&#x3D; null)</span><br><span class="line">                        q1.add(top.right);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                list.add(tmp);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test62"><a href="#Test62" class="headerlink" title="Test62"></a>Test62</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test62 请实现两个函数，分别用来序列化和反序列化二叉树</span><br><span class="line">二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，</span><br><span class="line">从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序</span><br><span class="line">的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），</span><br><span class="line">以 ！ 表示一个结点值的结束（value!）。</span><br><span class="line">二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</span><br><span class="line">例如，我们可以把一个只有根节点为1的二叉树序列化为&quot;1,&quot;，然后通过自己的函数来解析回这个二叉树 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 层序遍历 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Queue;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class Test62 &#123;</span><br><span class="line">    String Serialize(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q &#x3D; new LinkedList();</span><br><span class="line">        StringBuilder str &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">        if (root !&#x3D; null) </span><br><span class="line">            q.add(root);</span><br><span class="line"></span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode tmp &#x3D; q.poll();</span><br><span class="line">            if (tmp !&#x3D; null) &#123; &#x2F;&#x2F; 节点为null</span><br><span class="line">                str.append(tmp.val + &quot;!&quot;);</span><br><span class="line">                q.add(tmp.left);</span><br><span class="line">                q.add(tmp.right);</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; 不为null插入 #</span><br><span class="line">                str.append(&quot;#&quot; + &quot;!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        if (str.length() !&#x3D; 0) &#x2F;&#x2F; 删掉最后一个null后的！</span><br><span class="line">            str.deleteCharAt(str.length() - 1); </span><br><span class="line">        return str.toString();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">    TreeNode Deserialize(String str) &#123;</span><br><span class="line">        TreeNode root &#x3D; null;</span><br><span class="line">           if (str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D; 0)</span><br><span class="line">               return root;</span><br><span class="line">        String[] vals &#x3D; str.split(&quot;!&quot;); &#x2F;&#x2F; 按！分割得到每个节点的值</span><br><span class="line">        TreeNode[] nodes &#x3D; new TreeNode[vals.length];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 根据str构造 所有节点</span><br><span class="line">        for (int i &#x3D; 0; i &lt; vals.length; i ++) &#123;</span><br><span class="line">            if (!vals[i].equals(&quot;#&quot;))</span><br><span class="line">                nodes[i] &#x3D; new TreeNode(Integer.valueOf(vals[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 按照层序链接节点</span><br><span class="line">        root &#x3D; nodes[0];</span><br><span class="line">        for (int i &#x3D; 0, j &#x3D; 1; i &lt; nodes.length; i ++) &#123;</span><br><span class="line">            if (nodes[i] !&#x3D; null) &#123;</span><br><span class="line">                nodes[i].left &#x3D; nodes[j ++];</span><br><span class="line">                nodes[i].right &#x3D; nodes[j ++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test63"><a href="#Test63" class="headerlink" title="Test63"></a>Test63</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test63 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， </span><br><span class="line">（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 按中序遍历二叉搜索树得到递增的序列 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Test63 &#123;</span><br><span class="line">    TreeNode KthNode(TreeNode pRoot, int k) &#123;</span><br><span class="line">        if (pRoot &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack();</span><br><span class="line">        TreeNode tmp &#x3D; pRoot;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        while (tmp !&#x3D; null || !stack.empty()) &#123;</span><br><span class="line">            if (tmp !&#x3D; null)&#123;</span><br><span class="line">                stack.push(tmp);</span><br><span class="line">                tmp &#x3D; tmp.left;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                tmp &#x3D; stack.pop();</span><br><span class="line">                if(++ i &#x3D;&#x3D; k)</span><br><span class="line">                    return tmp;</span><br><span class="line">                tmp &#x3D; tmp.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test64"><a href="#Test64" class="headerlink" title="Test64"></a>Test64</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test64 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，</span><br><span class="line">那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，</span><br><span class="line">那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，</span><br><span class="line">使用GetMedian()方法获取当前读取数据的中位数。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 用两个PriorityQueue分别作为大顶堆和小顶堆 </span><br><span class="line">https:&#x2F;&#x2F;www.nowcoder.com&#x2F;questionTerminal&#x2F;9be0172896bd43948f8a32fb954e1be1?f&#x3D;discussion*&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">public class Test64 &#123;</span><br><span class="line">    &#x2F;&#x2F; 默认PriorityQueue为小顶堆</span><br><span class="line">    private PriorityQueue&lt;Integer&gt; minHeap &#x3D; new PriorityQueue&lt;Integer&gt;();</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;大顶堆</span><br><span class="line">    private PriorityQueue&lt;Integer&gt; maxHeap &#x3D; new PriorityQueue&lt;Integer&gt;(15, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            return o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    int count &#x3D; 0; &#x2F;&#x2F; 当前数字流中数字个数</span><br><span class="line">    &#x2F;&#x2F;每次插入小顶堆的是当前大顶堆中最大的数</span><br><span class="line">    &#x2F;&#x2F;每次插入大顶堆的是当前小顶堆中最小的数</span><br><span class="line">    &#x2F;&#x2F;这样保证小顶堆中的数永远大于等于大顶堆中的数</span><br><span class="line">    &#x2F;&#x2F;中位数就可以方便地从两者的根结点中获取了</span><br><span class="line"></span><br><span class="line">    public void Insert(Integer num) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当前数字个数为偶数，则先插入大顶堆，再把大顶堆中最大的数字插入到小顶堆</span><br><span class="line">        if (count % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">            int max &#x3D; maxHeap.poll();</span><br><span class="line">            minHeap.offer(max);</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 为奇数时则先插入小顶堆，再把小顶堆中最小的数字插入大顶堆</span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">            int min &#x3D; minHeap.poll();</span><br><span class="line">            maxHeap.offer(min);</span><br><span class="line">        &#125;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double GetMedian() &#123;</span><br><span class="line">        if (count % 2 &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 当前数字流中数字有偶数个，返回大、小顶堆头平均值</span><br><span class="line">            return new Double(minHeap.peek() + maxHeap.peek()) &#x2F; 2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new Double(minHeap.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test65"><a href="#Test65" class="headerlink" title="Test65"></a>Test65</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test65 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。</span><br><span class="line">例如，如果输入数组&#123;2,3,4,2,6,2,5,1&#125;及滑动窗口的大小3，那么一共存在6个滑动窗口，</span><br><span class="line">他们的最大值分别为&#123;4,4,6,6,6,5&#125;； 针对数组&#123;2,3,4,2,6,2,5,1&#125;的滑动窗口有以下6个：</span><br><span class="line"> &#123;[2,3,4],2,6,2,5,1&#125;， &#123;2,[3,4,2],6,2,5,1&#125;， &#123;2,3,[4,2,6],2,5,1&#125;，</span><br><span class="line">  &#123;2,3,4,[2,6,2],5,1&#125;， &#123;2,3,4,2,[6,2,5],1&#125;， &#123;2,3,4,2,6,[2,5,1]&#125;。</span><br><span class="line">窗口大于数组长度的时候，返回空 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test65 &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList();</span><br><span class="line">        if (size &gt; num.length || size &#x3D;&#x3D; 0)</span><br><span class="line">            return list;</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; num.length - size; i ++) &#123;</span><br><span class="line">            int tmp &#x3D; num[i];</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; i + size; j ++) &#123;</span><br><span class="line">                if (num[j] &gt; tmp)</span><br><span class="line">                    tmp &#x3D; num[j];</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test66"><a href="#Test66" class="headerlink" title="Test66"></a>Test66</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test66 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</span><br><span class="line">路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。</span><br><span class="line">如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 回溯法 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test66 &#123;</span><br><span class="line">    public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123;</span><br><span class="line">        &#x2F;&#x2F; 矩阵元素的标志位，表示其是否被遍历</span><br><span class="line">        boolean[] flag &#x3D; new boolean[matrix.length];</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; rows; i ++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; cols; j ++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 遍历整个矩阵元素作为第一个字符的情况</span><br><span class="line">                if (search(matrix, rows, cols, i, j, str, flag, 0))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; k表示搜索的str中的第k号字符</span><br><span class="line">    public boolean search(char[] matrix, int rows, int cols, int i, int j, char[] str, boolean[] flag, int k) &#123;</span><br><span class="line">        int index &#x3D; i * cols + j; &#x2F;&#x2F; 矩阵索引</span><br><span class="line">        &#x2F;&#x2F; 递归终止</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i  &gt;&#x3D; rows || j &gt;&#x3D; cols || matrix[index] !&#x3D; str[k] || flag[index] &#x3D;&#x3D; true)</span><br><span class="line">            return false;</span><br><span class="line">        flag[index] &#x3D; true; &#x2F;&#x2F; 矩阵走过的位置设置为true</span><br><span class="line">        &#x2F;&#x2F; 最后一个字符正确</span><br><span class="line">        if (k &#x3D;&#x3D; str.length - 1)</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 递归查找i，j四周的元素是否为第k个元素</span><br><span class="line">        if (search(matrix, rows, cols, i - 1, j, str, flag, k + 1) ||</span><br><span class="line">            search(matrix, rows, cols, i + 1, j, str, flag, k + 1) ||</span><br><span class="line">            search(matrix, rows, cols, i, j + 1, str, flag, k + 1) ||</span><br><span class="line">            search(matrix, rows, cols, i, j - 1, str, flag, k + 1)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 四周元素都没吻合的，说明当前元素选错了，进行回退</span><br><span class="line">        flag[index] &#x3D; false;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test67"><a href="#Test67" class="headerlink" title="Test67"></a>Test67</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test67 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，</span><br><span class="line">每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和</span><br><span class="line">大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 &#x3D; 18。</span><br><span class="line">但是，它不能进入方格（35,38），因为3+5+3+8 &#x3D; 19。请问该机器人能够达到多少个格子？*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test67 &#123;</span><br><span class="line">    public int movingCount(int threshold, int rows, int cols) &#123;</span><br><span class="line">        int[][] matrix &#x3D; new int[rows][cols];</span><br><span class="line">        boolean[][] flag &#x3D; new boolean[rows][cols];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; rows; i ++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; cols; j ++) &#123;</span><br><span class="line">                matrix[i][j] &#x3D; numSum(i) + numSum(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int count &#x3D; movingCountHelper(threshold, matrix, rows, cols, 0, 0, flag);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int movingCountHelper(int threshold, int[][] matrix, int rows, int cols, int i, int j, boolean[][] flag) &#123;</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; rows || j &gt;&#x3D; cols || matrix[i][j] &gt; threshold || flag[i][j] &#x3D;&#x3D; true)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        flag[i][j] &#x3D; true;</span><br><span class="line"></span><br><span class="line">        return 1 + movingCountHelper(threshold, matrix, rows, cols, i - 1, j, flag) </span><br><span class="line">                 + movingCountHelper(threshold, matrix, rows, cols, i + 1, j, flag) </span><br><span class="line">                 + movingCountHelper(threshold, matrix, rows, cols, i, j - 1, flag) </span><br><span class="line">                 + movingCountHelper(threshold, matrix, rows, cols, i, j + 1, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int numSum(int i) &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        do&#123;</span><br><span class="line">            sum +&#x3D; i%10;</span><br><span class="line">        &#125; while((i &#x3D; i&#x2F;10) &gt; 0);</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Test68"><a href="#Test68" class="headerlink" title="Test68"></a>Test68</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test68 给你一根长度为n的绳子，请把绳子剪成整数长的m段</span><br><span class="line">（m、n都是整数，n&gt;1并且m&gt;1，m&lt;&#x3D;n），每段绳子的长度记为</span><br><span class="line">k[1],...,k[m]。请问k[1]x...xk[m]可能的最大乘积是多少？</span><br><span class="line">例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，</span><br><span class="line">此时得到的最大乘积是18。 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.lang.Math;</span><br><span class="line"></span><br><span class="line">public class Test68 &#123;</span><br><span class="line">    public int cutRope(int target) &#123;</span><br><span class="line">        &#x2F;&#x2F; target &lt;&#x3D; 3时必须分段</span><br><span class="line">        if (target &#x3D;&#x3D; 2)</span><br><span class="line">            return 1;</span><br><span class="line">        if (target &#x3D;&#x3D; 3)</span><br><span class="line">            return 2;</span><br><span class="line"></span><br><span class="line">        int[] dp &#x3D; new int[target + 1];</span><br><span class="line">        &#x2F;&#x2F; target&gt;&#x3D;4时分段，分段中有1、2、3时该部分最大乘积如下</span><br><span class="line">        dp[1] &#x3D; 1;</span><br><span class="line">        dp[2] &#x3D; 2;</span><br><span class="line">        dp[3] &#x3D; 3;</span><br><span class="line">        int tmp &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 4; i &lt;&#x3D; target; i ++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; i &#x2F; 2; j ++) &#123;</span><br><span class="line">                tmp &#x3D; Math.max(tmp, dp[j] * dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#剑指Offer</p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/08/19/zAVSTgHkaJmCjoy.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/08/24/%E5%89%91%E6%8C%87Offer-Test02-Test30/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/08/19/zAVSTgHkaJmCjoy.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">剑指Offer Test02-Test30</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/08/24/剑指Offer-Test02-Test30/" title="剑指Offer Test02-Test30"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/19/zAVSTgHkaJmCjoy.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-24</div><div class="relatedPosts_title">剑指Offer Test02-Test30</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Yuwen Mi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>