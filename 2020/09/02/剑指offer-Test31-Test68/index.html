<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>剑指Offer Test31-Test68 | Yuwen Mi's Space</title><meta name="description" content="Test311234567891011121314151617181920212223&#x2F;* Test31 给一个数组，返回它的最大连续子序列的和 例如:&amp;#123;6,-3,-2,7,-15,1,2,2&amp;#125;,连续子向量的最大和为8(从第0个开始,到第3个为止)。 *&#x2F;&#x2F;*状态定义：dp[i]表示以array[i]结尾的连续子数组的最大和。所以最终要求dp[n]"><meta name="keywords" content="剑指Offer"><meta name="author" content="Yuwen Mi,mywjyw@foxmail.com"><meta name="copyright" content="Yuwen Mi"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/09/02/%E5%89%91%E6%8C%87offer-Test31-Test68/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="剑指Offer Test31-Test68"><meta property="og:url" content="http://yoursite.com/2020/09/02/%E5%89%91%E6%8C%87offer-Test31-Test68/"><meta property="og:site_name" content="Yuwen Mi's Space"><meta property="og:description" content="Test311234567891011121314151617181920212223&#x2F;* Test31 给一个数组，返回它的最大连续子序列的和 例如:&amp;#123;6,-3,-2,7,-15,1,2,2&amp;#125;,连续子向量的最大和为8(从第0个开始,到第3个为止)。 *&#x2F;&#x2F;*状态定义：dp[i]表示以array[i]结尾的连续子数组的最大和。所以最终要求dp[n]"><meta property="og:image" content="https://i.loli.net/2020/08/19/e6uyhEqAtD8sxHB.png"><meta property="article:published_time" content="2020-09-02T06:48:05.000Z"><meta property="article:modified_time" content="2020-09-02T06:50:14.952Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-02 14:50:14'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.1"><link rel="alternate" href="/atom.xml" title="Yuwen Mi's Space" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">3</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Test31"><span class="toc-number">1.</span> <span class="toc-text">Test31</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Test32"><span class="toc-number">2.</span> <span class="toc-text">Test32</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/08/19/e6uyhEqAtD8sxHB.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Yuwen Mi's Space</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">剑指Offer Test31-Test68</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-02T06:48:05.000Z" title="发表于 2020-09-02 14:48:05">2020-09-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-02T06:50:14.952Z" title="更新于 2020-09-02 14:50:14">2020-09-02</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Test31"><a href="#Test31" class="headerlink" title="Test31"></a>Test31</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test31 给一个数组，返回它的最大连续子序列的和 </span><br><span class="line">例如:&#123;6,-3,-2,7,-15,1,2,2&#125;,连续子向量的最大和为8(从第0个开始,到第3个为止)。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">状态定义：dp[i]表示以array[i]结尾的连续子数组的最大和。所以最终要求dp[n]</span><br><span class="line">状态转移方程：dp[i] &#x3D; max(array[i], dp[i-1]+array[i])</span><br><span class="line">解释：如果当前元素为整数，并且dp[i-1]为负数，那么当然结果就是只选当前元素</span><br><span class="line">*&#x2F;</span><br><span class="line">import java.lang.Math;</span><br><span class="line"></span><br><span class="line">public class Test31 &#123;</span><br><span class="line">    public int FindGreatestSumOfSubArray(int[] array) &#123;</span><br><span class="line">        int[] dp &#x3D; new int[array.length];</span><br><span class="line">        dp[0] &#x3D; array[0];</span><br><span class="line">        int res &#x3D; array[0];</span><br><span class="line">        for (int i &#x3D; 1; i &lt; dp.length; i ++) &#123;</span><br><span class="line">            dp[i] &#x3D; Math.max(dp[i - 1] + array[i], array[i]);</span><br><span class="line">            res &#x3D; Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Test32"><a href="#Test32" class="headerlink" title="Test32"></a>Test32</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"># Test33</span><br></pre></td></tr></table></figure>
<p>/* Test33 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。<br>    例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 */</p>
<p>/* 遍历整个数组进行从小到大的排序，数组元素a、b间的比较通过比较ab和ba的大小 */</p>
<p>public class Test33 {<br>    public String PrintMinNumber(int [] numbers) {<br>        if (numbers == null || numbers.length == 0)<br>            return “”;<br>        for (int i = 0; i &lt; numbers.length; i ++) {<br>            for (int j = i + 1; j &lt; numbers.length; j ++) {<br>                int ab = Integer.valueOf(numbers[i]+””+numbers[j]);<br>                int ba = Integer.valueOf(numbers[j]+””+numbers[i]);<br>                if (ab &gt; ba) {<br>                    int tmp = numbers[j];<br>                    numbers[j] = numbers[i];<br>                    numbers[i] = tmp;<br>                }<br>            }<br>        }</p>
<pre><code>    String str = &quot;&quot;;
    for (int i = 0; i &lt; numbers.length; i ++) &#123;
        str = str + numbers[i];
    &#125;

    return str;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test34</span><br></pre></td></tr></table></figure>
<p>/* Test34 把只包含质因子2、3和5的数称作丑数（Ugly Number）。<br>例如6、8都是丑数，但14不是，因为它包含质因子7。<br>习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 */</p>
<p>/* 只包含质因子2、3、5，所以丑数可以表示为2^x3^y5^z<br>    所以可以把已得到的丑数乘以2、3、5来得到新的丑数。<br>    维持三个指针来记录当前乘以2、乘以3、乘以5的最小值，<br>    然后当其被选为新的最小值后，要把相应的指针+1； */</p>
<p>import java.lang.Math;</p>
<p>public class Test34 {<br>    public int GetUglyNumber_Solution(int index) {<br>        if (index &lt;= 0)<br>            return 0;</p>
<pre><code>    // p2指向的数*2是所有*2可以得到的数最小的
    int p2 = 0, p3 = 0, p5 = 0;
    int[] res = new int [index];
    res[0] = 1;
    for (int i = 1; i &lt; index; i ++) &#123;
        // 找到当前最小的丑数
        res[i] = Math.min(res[p2] * 2, Math.min(res[p3] * 3, res[p5] * 5));
        // 更新三个指针
        if (res[i] == res[p2] * 2) p2++;
        if (res[i] == res[p3] * 3) p3++;
        if (res[i] == res[p5] * 5) p5++;
    &#125;
    return res[index - 1];
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test35</span><br></pre></td></tr></table></figure>
<p>/* Test35 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个<br>只出现一次的字符,并返回它的位置, 如果没有则返回 -1<br>（需要区分大小写）.（从0开始计数） */</p>
<p>/* hash法，创建一个数组，索引表示字符，对应的数据表示出现的次数 */</p>
<p>public class Test35 {<br>    public int FirstNotRepeatingChar(String str) {<br>        if (str == null || str.length() == 0)<br>            return -1;</p>
<pre><code>    int[] count = new int[256]; // 256 ASC码种类数
    for (int i = 0; i &lt; str.length(); i ++) &#123;
        count[str.charAt(i)]++;
    &#125;

    // 查找有没有只出现一次的
    for (int i = 0; i &lt; str.length(); i ++) &#123;
        if (count[str.charAt(i)] == 1)
            return i;
    &#125;
    return -1;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test36</span><br></pre></td></tr></table></figure>
<p>/* Test36 在数组中的两个数字，如果前面一个数字大于后面的数字，<br>则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。<br>并将P对1000000007取模的结果输出。 即输出P%1000000007 */</p>
<p>/* 方法一：固定一个元素，遍历之后的元素找逆序对 O(n2) */</p>
<p>/*方法二：进行归并排序的同时统计逆序对的个数 */</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test37</span><br></pre></td></tr></table></figure>
<p>/* Test37 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，<br>所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）*/</p>
<p>/* 方法一 固定第一个链表，遍历第二个O(n2) */</p>
<p>public class Test37 {<br>    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {<br>        ListNode node1 = pHead1;<br>        ListNode node2;</p>
<pre><code>    while (node1 != null) &#123;
        node2 = pHead2;
        while (node2 != null) &#123;
            if (node2 == node1)
                return node1;
            node2 = node2.next;
        &#125;
        node1 = node1.next;
    &#125;
    return null;
&#125;</code></pre>
<p>}</p>
<p>/* 方法二 双指针法，两链表有公共节点，所以公共节点后的链表相同。<br>    想办法让公共节点前的节点数相同。a+b=b+a，让b+a作为新的链表A，a+b作为新的B<br>    此时对两个新链表来说，目标公共节点在两新链表相同的位置 */</p>
<pre><code>public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;
    if (pHead1 == null || pHead2 == null) return null;
    ListNode node1 = pHead1;
    ListNode node2 = pHead2;

    while (node1 != node2) &#123;
        node1 = node1.next;
        node2 = node2.next;

        // 公共节点可能 为null，所以这里要判断一下
        if (node1 != node2) &#123;
            if (node1 == null) node1 = pHead2;
            if (node2 == null) node2 = pHead1;
        &#125;
    &#125;
    return node1;
&#125;</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test38</span><br></pre></td></tr></table></figure>
<p>/* Test38 统计一个数字在非降序数组中出现的次数。*/</p>
<p>/* 有序的数组，所以采用二分法，找到开头的k和最后的k */</p>
<p>public class Test38 {<br>    public int GetNumberOfK(int [] array , int k) {<br>       if (array.length == 0)<br>           return 0;<br>       int firstK = findFirstK(array, k, 0, array.length - 1);<br>       int lastK = findLastK(array, k, 0, array.length - 1);<br>       int count = 0;<br>       if (firstK != -1 &amp;&amp; lastK != -1) {<br>           count = lastK - firstK + 1;<br>       }<br>       return count;<br>    }</p>
<pre><code>// 用递归实现二分查找第一个k
public int findFirstK(int [] array, int k, int start, int end) &#123;
    if (start &gt; end)
        return -1;
    int mid = (start + end) &gt;&gt; 1;
    if (k &lt; array[mid]) &#123;
        return findFirstK(array, k, start, mid - 1);
    &#125; else if (k &gt; array[mid]) &#123;
        return findFirstK(array, k, mid + 1, end);
    &#125; else if (mid - 1 &gt;= 0 &amp;&amp; array[mid - 1] == k) &#123;
        return findFirstK(array, k , start, mid - 1);
    &#125; else &#123; // mid位置就是第一个k
        return mid;
    &#125;
&#125;


// 用循环实现二分查找最后一个k
public int findLastK(int [] array, int k, int start, int end) &#123;
    int mid = (start + end) &gt;&gt; 1;        
    while (start &lt;= end) &#123;
        if (k &lt; array[mid]) &#123;
            end = mid - 1;
        &#125; else if (k &gt; array[mid]) &#123;
            start = mid + 1;
        &#125; else if (mid + 1 &lt; array.length &amp;&amp; array[mid + 1] == k) &#123; // 注意这里跟上一个函数的区别
            start = mid + 1;
        &#125; else &#123;
            return mid;
        &#125;
        mid = (start + end) &gt;&gt; 1;
    &#125;
    return -1;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test39</span><br></pre></td></tr></table></figure>
<p>/* Test39 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点<br>（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 */</p>
<p>/* 递归，树深度=左子树深度和右子树深度的较大值+1 */</p>
<p>import java.lang.Math;</p>
<p>public class Test39 {<br>    public int TreeDepth(TreeNode root) {<br>        if (root == null)<br>            return 0;<br>        int leftDepth = TreeDepth(root.left);<br>        int rightDepth = TreeDepth(root.right);</p>
<pre><code>    int depth = Math.max(leftDepth, rightDepth) + 1;
    return depth;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test40</span><br></pre></td></tr></table></figure>
<p>/* Test40 输入一棵二叉树，判断该二叉树是否是平衡二叉树。<br>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 */</p>
<p>/* 平衡二叉树的左右子树高度差不超过1，且左右子树也应为平衡二叉树；<br>    在上一题实现了计算二叉树高度的函数，对其进行改进, 若不为平衡二叉树则返回-1 */<br>import java.lang.Math;</p>
<p>public class Test40 {</p>
<pre><code>public int depth(TreeNode root) &#123;
    if (root == null)
        return 0;
    int leftDepth = depth(root.left);
    if (leftDepth == -1) // 左子树不是平衡二叉树
        return -1;
    int rightDepth = depth(root.right);
    if (rightDepth == -1)
        return -1;
    // 判断当前树是否为平衡二叉树
    int diff = Math.abs(leftDepth - rightDepth);
    if (diff &gt; 1) 
        return -1;
    else &#123;
        return 1 + Math.max(leftDepth, rightDepth);
    &#125;
&#125;

public boolean IsBalanced_Solution(TreeNode root) &#123;
    // 非平衡二叉树depth返回-1
    return depth(root) != -1;    
&#125;</code></pre>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test41</span><br></pre></td></tr></table></figure>
<p>/* Test41 一个整型数组里除了两个数字之外，其他的数字都出现了两次。<br>请写程序找出这两个只出现一次的数字。 */</p>
<p>/* 方法一：用HashMap */</p>
<p>/* 方法二：相同的数异或结果为0，所以该数组中所有元素异或后的结果<br>    应为两个目标数异或的结果。根据异或结果可以知道两个目标数的哪一位<br>    不相同（该位为1）。此时再根据这一位为0/1将原数组分为两组，相同的数都在<br>    同一组，两目标数在不同组。分别异或可以得到两个目标数 */</p>
<p>public class Test41 {<br>    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {<br>        int xor = 0; // 所有数的异或结果<br>        for (int i = 0; i &lt; array.length; i ++) {<br>            xor = xor ^ array[i];<br>        }</p>
<pre><code>    // 找到两数不同的位
    int index = 1;
    while ((index &amp; xor) == 0) &#123;
        index = index &lt;&lt; 1;
    &#125;

    // 保存两类数组异或的结果
    int res1 = 0;
    int res2 = 0;
    for (int i = 0; i &lt; array.length; i ++) &#123;
        if ((index &amp; array[i]) == 0)
            res1 = res1 ^ array[i];
        else 
            res2 = res2 ^ array[i];
    &#125;

    num1[0] = res1;
    num2[0] = res2;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test42</span><br></pre></td></tr></table></figure>
<p>/* Test42 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,<br>他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种<br>连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:<br>18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! */</p>
<p>/* 方法一：算出从1到i之和sum[i]，则m到n之和为 sum[m]-sum[n] */</p>
<p>/* 方法二：滑动窗口<br>扩大窗口，j += 1<br>缩小窗口，i += 1<br>算法步骤：<br>初始化，i=1,j=1, 表示窗口大小为0<br>如果窗口中值的和小于目标值sum， 表示需要扩大窗口，j += 1<br>否则，如果狂口值和大于目标值sum，表示需要缩小窗口，i += 1<br>否则，等于目标值，存结果，缩小窗口，继续进行步骤2,3,4 */</p>
<p>import java.util.ArrayList;</p>
<p>public class Test42 {<br>    public ArrayList&lt;ArrayList<Integer> &gt; FindContinuousSequence(int sum) {<br>        ArrayList&lt;ArrayList<Integer>&gt; listAll = new ArrayList();<br>        // 初始化两个窗口<br>        int i = 1;<br>        int j = 2;<br>        int sumCur = i + j; // 当前窗口所有数之和</p>
<pre><code>    while (i &lt;= sum / 2) &#123;
        if (sumCur &lt; sum) &#123;
            j ++;
            sumCur += j;
        &#125; else if (sumCur &gt; sum) &#123;
            sumCur -= i;
            i ++;
        &#125; else &#123; // 当前窗口值之和=sum
            ArrayList&lt;Integer&gt; list = new ArrayList();
            for (int m = i; m &lt;= j; m ++) &#123;
                list.add(m);
            &#125;
            listAll.add(list);

            j ++;
            sumCur += j;
        &#125;
    &#125;
    return listAll;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test43</span><br></pre></td></tr></table></figure>
<p>/* Test43 输入一个递增排序的数组和一个数字S，在数组中查找两个数，<br>使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 */</p>
<p>/* 双指针 分别指向首尾*/</p>
<p>import java.util.ArrayList;</p>
<p>/* 暴力 */<br>public class Test43 {<br>    public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {<br>        ArrayList<Integer> list = new ArrayList();</p>
<pre><code>    int sumCur = 0;
    int i = 0;
    int j = 1;
    for (i = 0; i &lt; j; i ++) &#123;
        for (j = i + 1; j &lt; array.length; j ++) &#123;
            sumCur = array[i] + array[j];
            if (sumCur == sum) &#123;
                list.add(array[i]);
                list.add(array[j]);
                break;
            &#125;
        &#125;
        if (sumCur == sum) break;
    &#125;
    return list;
&#125;</code></pre>
<p>}</p>
<p>/* 双指针分别指向首位 */<br>    public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {<br>        ArrayList<Integer> list = new ArrayList();<br>        if (array == null  || array.length == 0)<br>            return list;<br>        int i = 0;<br>        int j = array.length - 1;<br>        int sumCur = array[i] + array[j];</p>
<pre><code>    while (array[i] &lt;= sum / 2) &#123;
        if (sumCur &gt; sum) &#123;
            j --;
            sumCur = array[i] + array[j];
        &#125; else if (sumCur &lt; sum) &#123;
            i ++;
            sumCur = array[i] + array[j];                
        &#125; else &#123;
               list.add(array[i]);
               list.add(array[j]);
               break;
        &#125;
    &#125;
    return list;
&#125;</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test44</span><br></pre></td></tr></table></figure>
<p>/* Test44 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，<br>就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，<br>请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,<br>要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ */</p>
<p>public class Test44 {<br>    public String LeftRotateString(String str,int n) {<br>        if (str == null || n &gt; str.length())<br>            return str;</p>
<pre><code>    return str.substring(n) + str.substring(0, n);
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test45</span><br></pre></td></tr></table></figure>
<p>/* Test45 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，<br>写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，<br>但却读不懂它的意思。例如，“student. a am I”。后来才意识到，<br>这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。<br>Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ */</p>
<p>/* 先对整个字符串进行反转，在对反转后的每个单词进行反转 */</p>
<p>public class Test45 {<br>    public String ReverseSentence(String str) {<br>        if (str == null || str.length() == 0)<br>            return str;</p>
<pre><code>    char[] chars = str.toCharArray();
    // 对原字符串进行翻转
    reverse(chars, 0, chars.length - 1);

    // 分别指向一个单词的最后一个字母和最后一个字母
    int start = 0;
    int end = 0;
    while (start &lt; chars.length) &#123;
        if (end == chars.length || chars[end] == &#39; &#39;) &#123; // 遇到空格或最后说明当前start到end为一个单词
            reverse(chars, start, end - 1);
            start = ++ end; // 指向下一个单词
        &#125; else &#123;
            end ++;
        &#125;
    &#125;
    return String.valueOf(chars);
&#125;

public void reverse(char[] chars, int begin, int end) &#123;
    while (begin &lt; end) &#123;
        char tmp = chars[end];
        chars[end] = chars[begin];
        chars[begin] = tmp;
        begin ++;
        end --;
    &#125;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test46</span><br></pre></td></tr></table></figure>
<p>/* Test46 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,<br>2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,<br>看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,<br>小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王<br>可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”<br>(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,<br>要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何，<br>如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。*/</p>
<p>/* 输入数组需要满足以下几个条件：<br>    1.数组长度为5<br>    2.max-min&lt;5<br>    3.数组元素除大小王外不重复<br>    用TreeSet顺序保存元素 */<br>import java.util.TreeSet;</p>
<p>public class Test46 {<br>    public boolean isContinuous(int [] numbers) {<br>        if (numbers.length != 5)<br>            return false;</p>
<pre><code>    int sum = 0; // 大小王个数
    TreeSet&lt;Integer&gt; set = new TreeSet();

    for (int i = 0; i &lt; numbers.length; i ++) &#123;
        if (numbers[i] == 0)
            sum++;
        else 
            set.add(numbers[i]);
    &#125;

    if (sum + set.size() != 5) 
        return false;
    if (set.last() - set.first() &gt;= 5)
        return false;

    return true;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test47</span><br></pre></td></tr></table></figure>
<p>/* Test47 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,<br>今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,<br>有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,<br>让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,<br>然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,<br>继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,<br>并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,<br>哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<p>如果没有小朋友，请返回-1 */</p>
<p>/* 方法一：数学公式推导 */</p>
<p>/* 方法二：用LinkedList模拟游戏过程 */</p>
<p>import java.util.LinkedList;</p>
<p>public class Test47 {<br>    public int LastRemaining_Solution(int n, int m) {<br>        if (n == 0)<br>            return -1;<br>        LinkedList<Integer> list = new LinkedList();</p>
<pre><code>    // list初始化小朋友编号
    for (int i = 0; i &lt; n; i ++) &#123;
         list.add(i);
    &#125; 

    int del = 0; // 每次出队的小朋友
    while (list.size() != 1) &#123;
        del = (del + m - 1) % list.size();
        list.remove(del);
    &#125;

    return list.get(0);
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test48</span><br></pre></td></tr></table></figure>
<p>/* Test48 求1+2+3+…+n，要求不能使用乘除法、<br>for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。*/</p>
<p>/* 求累加一般需要通过求和公式或者循环求和，但根据题目要求这两种都不能用，<br>    所以需要用到递归,<br>    很容易实现递归 当n=1时返回n 其他情况返回n+sum(n-1)。但是考虑到不能用if语句，<br>    所以需要用到短路求值，即&amp;&amp;语句，以a&amp;&amp;b为例，若a已经为0，则不会执行b*/</p>
<p>public class Test48 {<br>    public int Sum_Solution(int n) {<br>        boolean tmp;<br>        tmp = (n &gt; 1) &amp;&amp; ((n += Sum_Solution(n - 1)) &gt; 0);<br>        return n;<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test49</span><br></pre></td></tr></table></figure>
<p>/* Test49 写一个函数，求两个整数之和，要求在函数体内<br>不得使用+、-、<em>、/四则运算符号。</em>/</p>
<p>/* 不能用加减乘除，所以肯定是用位操作，考虑到加法的过程，<br>    x^y执行加法,(x&amp;y)&lt;&lt;1执行进位操作 ；<br>    每次加法操作相当于进行位加法和进行操作，知道进位为0为止 */</p>
<p>public class Test49 {<br>    public int Add(int num1,int num2) {<br>        int res = 0; // 位加法结果<br>        int carry = 0; // 进位结果</p>
<pre><code>    do &#123;
        res = num1 ^ num2;
        carry = (num1 &amp; num2) &lt;&lt; 1;

        num1 = res;
        num2 = carry;
    &#125; while (carry != 0);

    return res;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test50</span><br></pre></td></tr></table></figure>
<p>/* Test50 将一个字符串转换成一个整数，<br>要求不能使用字符串转换整数的库函数。<br>数值为0或者字符串不是一个合法的数值则返回0 */</p>
<p>public class Test50 {<br>    public int StrToInt(String str) {<br>        if (str == null || str.length() == 0)<br>            return 0;</p>
<pre><code>    boolean negative = false; // 输入是否为负数
    int res = 0;

    int limit = Integer.MAX_VALUE; // 允许的正数的最大值
    int i = 0;

    int digit; // 循环时的当前位
    // 进行正负判断
    char signal = str.charAt(0);
    if (signal &lt; &#39;0&#39;) &#123; // 为&#39;+&#39;/&#39;-&#39;
        if (signal == &#39;-&#39;) &#123; // 负数
            negative = true;
            limit = Integer.MIN_VALUE;
        &#125; else if (signal != &#39;+&#39;) &#123; // 不是合法的 数
            return 0;
        &#125;

        if (str.length() == 1)
            return 0;
        i ++;
    &#125;

    int multmin = limit / 10; 
    while (i &lt; str.length()) &#123;
        digit = str.charAt(i) - &#39;0&#39;;
        if (digit &lt; 0 || digit &gt; 9)
            return 0;

        // 对是否溢出进行判断
        if (negative) &#123;
            if (res &lt; multmin)
                return 0;
        &#125; else &#123;
            if (res &gt; multmin)
                return 0;
        &#125;

        res *= 10;

        if (negative) &#123;
            if (res - digit &lt; limit)
                return 0;
            res -= digit;
        &#125; else &#123;
            if (res + digit &gt; limit)
                return 0;
            res += digit;
        &#125;
        i ++;
    &#125;
    return res;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test51</span><br></pre></td></tr></table></figure>
<p>/* Test51 在一个长度为n的数组里的所有数字都在0到n-1的范围内。<br>数组中某些数字是重复的，但不知道有几个数字是重复的。<br>也不知道每个数字重复几次。请找出数组中任意一个重复的数字。<br> 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，<br> 那么对应的输出是第一个重复的数字2。 */</p>
<p>/* 用lenth长度的boolen表示数组中的各元素有没有重复出现 */</p>
<p>public class Test51 {<br>    public boolean duplicate(int numbers[],int length,int [] duplication) {<br>        // 默认初始化都为false<br>        boolean[] status = new boolean[length];</p>
<pre><code>    for (int i = 0; i &lt; length; i ++) &#123;
        if (status[numbers[i]]) &#123;// 重复遇见第i个元素
            duplication[0] = numbers[i];
            return true;
        &#125;
        status[numbers[i]] = true;
    &#125;
    return false;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test52</span><br></pre></td></tr></table></figure>
<p>/* Test52 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],<br>其中B中的元素B[i]=A[0]<em>A[1]</em>…*A[i-1]<em>A[i+1]</em>…*A[n-1]。<br>不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，<br>B[n-1] = A[0] * A[1] * … * A[n-2];）<br>对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。 */</p>
<p>/* 下三角用连乘可以很容求得，上三角，从下向上也是连乘。<br>因此我们的思路就很清晰了，先算下三角中的连乘，<br>即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，<br>把另一部分也乘进去。 */</p>
<p>public class Test52 {<br>    public int[] multiply(int[] A) {<br>        int[] B = new int[A.length];</p>
<pre><code>    if (A.length != 0) &#123;
        B[0] = 1;
        // B的下三角部分
        for (int i = 1; i &lt; B.length; i ++) &#123;
            B[i] = B[i - 1] * A[i - 1];
        &#125;


        // 计算B的上三角部分
        int tmp = 1;
        for (int i = B.length - 2; i &gt;= 0; i --) &#123;
            tmp *= A[i + 1];
            B[i] *= tmp;
        &#125;
    &#125;

    return B;

&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test53</span><br></pre></td></tr></table></figure>
<p>/* Test53 请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，<br>而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。<br>例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配 */</p>
<p>/*<br>当模式中的第二个字符是“<em>”时：<br>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：<br>1、模式后移2字符，相当于x</em>被忽略；<br>2、字符串后移1字符，模式后移2字符；<br>3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；</p>
<p>当模式中的第二个字符不是“*”时：<br>1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。<br>2、如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。<br>*/</p>
<p>public class Test53 {<br>    public boolean match(char[] str, char[] pattern) {<br>        if (str == null || pattern == null)<br>            return false;</p>
<pre><code>    return match(str, 0, pattern, 0);
&#125;

public boolean match(char[] str, int strIndex, char[] pattern, int patternIndex) &#123;
    // 同时到达末尾则匹配成功
    if (strIndex == str.length &amp;&amp; patternIndex == pattern.length) 
        return true;
    if (strIndex != str.length &amp;&amp; patternIndex == pattern.length)
        return false;


    // 当前pattern的第二个字符是 *
    if (patternIndex + 1 &lt; pattern.length &amp;&amp; pattern[patternIndex + 1] == &#39;*&#39;) &#123;
        // 第一个字符相同
        if (strIndex != str.length &amp;&amp; (str[strIndex] == pattern[patternIndex] || pattern[patternIndex] == &#39;.&#39;)) &#123;
            return match(str, strIndex, pattern, patternIndex + 2) // *不匹配字符
                || match(str, strIndex + 1, pattern, patternIndex + 2) // *匹配1个字符
                || match(str, strIndex + 1, pattern, patternIndex); // *匹配后继续匹配str中的下一个
        &#125; else &#123; // 第一个字符不相同
            return match(str, strIndex, pattern, patternIndex + 2);
        &#125;
    &#125;

    // 当前pattern第二个字符不是 *,且str第一个字符和pattern第一个 字符匹配，都后移一位
    if (strIndex != str.length &amp;&amp; (str[strIndex] == pattern[patternIndex] || pattern[patternIndex] == &#39;.&#39;)) &#123;
        return match(str, strIndex + 1, pattern, patternIndex + 1);
    &#125;



    return false;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test54</span><br></pre></td></tr></table></figure>
<p>/* Test54 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。<br>例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。<br> 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 */</p>
<p>/* 方法一：正则表达式 */</p>
<p>/* 方法二：明确几个约束条件</p>
<p>+-号后面必定为数字或后面为.（-.123 = -0.123）<br>+-号只出现在第一位或在eE的后一位<br>.后面必定为数字或为最后一位（233. = 233.0）<br>eE后面必定为数字或+-号</p>
<p>*/</p>
<p>public class Test54 {<br>    public boolean isNumeric(char[] str) {<br>        if (str.length == 0)<br>            return false;</p>
<pre><code>    boolean point = false, exp = false; // 是否已出现小数点/指数

    for (int i = 0; i &lt; str.length; i ++) &#123;
        // 符号为+/-
        if (str[i] == &#39;+&#39; || str[i] == &#39;-&#39;) &#123;
            // + -后必须为数字或.
            if (i + 1 == str.length || !(str[i + 1] &gt;= &#39;0&#39; &amp;&amp; str[i + 1] &lt;= &#39;9&#39; || str[i + 1] == &#39;.&#39;))
                return false;

            // +- 号只能出现在第一位或eE的下一位
            if (i != 0 &amp;&amp; str[i - 1] != &#39;e&#39; &amp;&amp; str[i - 1] != &#39;E&#39;)
                return false;
        &#125; else if (str[i] == &#39;.&#39;) &#123; // 符号为.
            // 不能出现在e后，有下一位且下一位不是数字则错
            if (point || exp || !(i + 1 &lt; str.length &amp;&amp; str[i+1] &gt;= &#39;0&#39; &amp;&amp; str[i+1] &lt;=&#39;9&#39;)) 
                return false;
            point = true;
        &#125; else if (str[i] == &#39;e&#39; || str[i] == &#39;E&#39;) &#123;
            // 之前有过e/e是最后一位/下一位不是数字或+ -   则报错
            if (exp || i + 1 == str.length || !(str[i+1] &gt;= &#39;0&#39; &amp;&amp; str[i+1] &lt;= &#39;9&#39; || str[i+1] == &#39;+&#39; || str[i+1] == &#39;-&#39;))
                return false;
            exp = true;
        &#125; else if (str[i] &gt;=  &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;) &#123;

        &#125; else 
            return false;
    &#125;
    return true;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test55</span><br></pre></td></tr></table></figure>
<p>/*Test55 请实现一个函数用来找出字符流中第一个只出现一次的字符。<br>例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。<br>当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 */</p>
<p>import java.util.*;</p>
<p>public class Test55 {</p>
<pre><code>// 储存字符流的字符及其出现的次数 
HashMap&lt;Character, Integer&gt; map = new HashMap(); 
// 储存字符流的字符
LinkedList&lt;Character&gt; list = new LinkedList();

//Insert one char from stringstream
public void Insert(char ch)  &#123;
    if (map.containsKey(ch)) &#123;
        map.put(ch, map.get(ch) + 1);
    &#125; else &#123;
        map.put(ch, 1);
    &#125;
    list.add(ch);
&#125;</code></pre>
<p>  //return the first appearence once char in current stringstream<br>    public char FirstAppearingOnce()  {<br>        for(char ch : list) {<br>            if (map.get(ch) == 1)<br>                return ch;<br>        }<br>        return ‘#’;<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test56</span><br></pre></td></tr></table></figure>
<p>/*  Test56 给一个链表，若其中包含环，<br>请找出该链表的环的入口结点，否则，输出null。*/</p>
<p>/* 1.判断链表中有环 -&gt; 2.得到环中节点的数目 -&gt; 3.找到环中的入口节点 */</p>
<p>public class Test56 {<br>    public ListNode EntryNodeOfLoop(ListNode pHead) {<br>        if (pHead == null)<br>            return null;</p>
<pre><code>    ListNode l = pHead, r = pHead; // 快慢指针
    boolean ring = false;

    // 判断链表中是否存在环
    while (r != null &amp;&amp; r.next != null) &#123;
        l = l.next;
        r = r.next.next;
        if (l == r) &#123;
            ring = true;
            break;
        &#125;
    &#125;
    if (!ring)
        return null;

    int n = 1; // 环中节点个数 
    r = r.next;
    while (r != l) &#123;
        r = r.next;
        n ++;
    &#125;

    // 在得知环节点个数后，先让快指针走n个节点；
    // 再快慢指针一起走，因为环有n个节点。所以两指针会在入口处相遇
    l = pHead;
    r = pHead;
    for (int i = 0; i &lt; n; i ++) &#123;
        r = r.next;
    &#125;

    while (r != l) &#123;
        l = l.next;
        r = r.next;
    &#125;
    return r;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test57</span><br></pre></td></tr></table></figure>
<p>/* Test57 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，<br>重复的结点不保留，返回链表头指针。<br>例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 */</p>
<p>/* 新增一个节点head，便于处理第一个节点就重复的情况</p>
<p>指针l指向当前最后一个只出现一次的节点，指针r为工作节点，向后移动 */</p>
<p>/* 这题需要在好好看看 */</p>
<p>public class Test57 {<br>    public ListNode deleteDuplication(ListNode pHead) {<br>        if (pHead == null || pHead.next == null)<br>            return pHead;<br>        // 换表头<br>        ListNode head = new ListNode(0);<br>        ListNode l = head, r = pHead;<br>        head.next = pHead;</p>
<pre><code>    while (r != null) &#123;
        if (r.next != null &amp;&amp; r.val == r.next.val) &#123;
            while (r.next != null &amp;&amp; r.val == r.next.val) &#123;
                r = r.next;
            &#125;
            l.next = r.next;
            r = r.next;
        &#125; else &#123; // r指向的节点只出现一次
            l = l.next;
            r = r.next;
        &#125;
    &#125;
    return pHead;


&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test58</span><br></pre></td></tr></table></figure>
<p>/* Test58 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。<br>注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 */</p>
<p>/* 中序遍历的下一个节点可以分为如下几种情况：<br>    1.当前有点有右子树，则遍历的下一个节点为其右子树的最左侧树节点<br>    2.当前节点没有右子树时，若当前节点是其父节点的左孩子，则下一个节点为父节点<br>                       否则为父节点的父节点…知道当前节点作为左子树 */</p>
<p>public class Test58 {<br>    public TreeLinkNode GetNext(TreeLinkNode pNode) {<br>        if (pNode == null)<br>            return null;<br>        TreeLinkNode tmp = new TreeLinkNode(0);<br>        if (pNode.right != null) {<br>            tmp = pNode.right;<br>            while (tmp.left != null)<br>                tmp = tmp.left;<br>            return tmp;<br>        }<br>        tmp = pNode.next;<br>        while (tmp != null) {<br>            if (pNode == tmp.left)<br>                return tmp;<br>            tmp = tmp.next;<br>            pNode = pNode.next;<br>        }<br>        return null;</p>
<pre><code>&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test59</span><br></pre></td></tr></table></figure>
<p>/* Test59 请实现一个函数，用来判断一棵二叉树是不是对称的。<br>注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。*/</p>
<p>/* 对称二叉树的左右子树相同，首先是根节点及其左右子树。<br>    然后左子树的根节点和右子树的根节点相同，左子树的左子树和右子树的右子树同理<br>    采用递归法 */</p>
<p>public class Test59 {<br>    boolean isSymmetrical(TreeNode pRoot) {<br>        if (pRoot == null)<br>            return true;<br>        return isSymmetricalHelper(pRoot.left, pRoot.right);<br>    }</p>
<pre><code>boolean isSymmetricalHelper(TreeNode leftRoot, TreeNode rightRoot) &#123;
    if (leftRoot == null)
        return rightRoot == null;
    else if(rightRoot == null)
        return false;
    if (leftRoot.val != rightRoot.val)
        return false;
    return isSymmetricalHelper(leftRoot.left, rightRoot.right)
        &amp;&amp; isSymmetricalHelper(leftRoot.right, rightRoot.left);
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test60</span><br></pre></td></tr></table></figure>
<p>/* Test60 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，<br>第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 */</p>
<p>/* 两个栈，分别存奇数层和偶数层 */</p>
<p>import java.util.Stack;<br>import java.util.ArrayList;</p>
<p>public class Test60 {<br>    public ArrayList&lt;ArrayList<Integer> &gt; Print(TreeNode pRoot) {<br>        Stack<TreeNode> stack1 = new Stack();<br>        Stack<TreeNode> stack2 = new Stack();<br>        if (pRoot != null)<br>            stack1.push(pRoot);<br>        ArrayList&lt;ArrayList<Integer>&gt; list = new ArrayList();</p>
<pre><code>    while(!stack1.empty() || !stack2.empty()) &#123;
        if (!stack1.empty()) &#123; // 将偶数层放入栈2
            ArrayList&lt;Integer&gt; tmp = new ArrayList();
            int size = stack1.size();
            for (int i = 0; i &lt; size; i ++) &#123; // 这里不能直接用stack1.size，因为pop会改变其值
                TreeNode top = stack1.pop();
                tmp.add(top.val);
                if (top.left != null)
                    stack2.push(top.left);
                if (top.right != null)
                    stack2.push(top.right);
            &#125;
            list.add(tmp);
        &#125;    
        if (!stack2.empty()) &#123; // 根据栈2的节点，将下一层放入stack1中
            ArrayList&lt;Integer&gt; tmp = new ArrayList();
            int size = stack2.size();
            for (int i = 0; i &lt; size; i++) &#123;
                TreeNode top = stack2.pop();
                tmp.add(top.val);
                if (top.right != null)
                    stack1.push(top.right);
                if (top.left != null)
                    stack1.push(top.left);
            &#125;
            list.add(tmp);
        &#125;        
    &#125;
    return list;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test61</span><br></pre></td></tr></table></figure>
<p>/* Test61 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。*/</p>
<p>import java.util.Queue;<br>import java.util.ArrayList;<br>import java.util.LinkedList;</p>
<p>public class Test61 {<br>    public ArrayList&lt;ArrayList<Integer> &gt; Print(TreeNode pRoot) {<br>        Queue<TreeNode> q1 = new LinkedList();<br>        Queue<TreeNode> q2 = new LinkedList();<br>        if (pRoot != null)<br>            q1.add(pRoot);<br>        ArrayList&lt;ArrayList<Integer>&gt; list = new ArrayList();</p>
<pre><code>    while(!q1.isEmpty() || !q2.isEmpty()) &#123;
        if (!q1.isEmpty()) &#123; // 将偶数层放入q2
            ArrayList&lt;Integer&gt; tmp = new ArrayList();
            int size = q1.size();
            for (int i = 0; i &lt; size; i ++) &#123; // 这里不能直接用stack1.size，因为pop会改变其值
                TreeNode top = q1.remove();
                tmp.add(top.val);
                if (top.left != null)
                    q2.add(top.left);
                if (top.right != null)
                    q2.add(top.right);
            &#125;
            list.add(tmp);
        &#125;    
        if (!q2.isEmpty()) &#123; // 根据栈2的节点，将下一层放入stack1中
            ArrayList&lt;Integer&gt; tmp = new ArrayList();
            int size = q2.size();
            for (int i = 0; i &lt; size; i++) &#123;
                TreeNode top = q2.remove();
                tmp.add(top.val);
                if (top.left != null)
                    q1.add(top.left);
                if (top.right != null)
                    q1.add(top.right);

            &#125;
            list.add(tmp);
        &#125;        
    &#125;
    return list;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test62</span><br></pre></td></tr></table></figure>
<p>/* Test62 请实现两个函数，分别用来序列化和反序列化二叉树<br>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，<br>从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序<br>的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），<br>以 ！ 表示一个结点值的结束（value!）。<br>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。<br>例如，我们可以把一个只有根节点为1的二叉树序列化为”1,”，然后通过自己的函数来解析回这个二叉树 */</p>
<p>/* 层序遍历 */</p>
<p>import java.util.Queue;<br>import java.util.LinkedList;</p>
<p>public class Test62 {<br>    String Serialize(TreeNode root) {<br>        Queue<TreeNode> q = new LinkedList();<br>        StringBuilder str = new StringBuilder();</p>
<pre><code>    if (root != null) 
        q.add(root);

    while (!q.isEmpty()) &#123;
        TreeNode tmp = q.poll();
        if (tmp != null) &#123; // 节点为null
            str.append(tmp.val + &quot;!&quot;);
            q.add(tmp.left);
            q.add(tmp.right);
        &#125; else &#123; // 不为null插入 #
            str.append(&quot;#&quot; + &quot;!&quot;);
        &#125;
    &#125;  

    if (str.length() != 0) // 删掉最后一个null后的！
        str.deleteCharAt(str.length() - 1); 
    return str.toString();

   &#125;
TreeNode Deserialize(String str) &#123;
    TreeNode root = null;
       if (str == null || str.length() == 0)
           return root;
    String[] vals = str.split(&quot;!&quot;); // 按！分割得到每个节点的值
    TreeNode[] nodes = new TreeNode[vals.length];

    // 根据str构造 所有节点
    for (int i = 0; i &lt; vals.length; i ++) &#123;
        if (!vals[i].equals(&quot;#&quot;))
            nodes[i] = new TreeNode(Integer.valueOf(vals[i]));
    &#125;

    // 按照层序链接节点
    root = nodes[0];
    for (int i = 0, j = 1; i &lt; nodes.length; i ++) &#123;
        if (nodes[i] != null) &#123;
            nodes[i].left = nodes[j ++];
            nodes[i].right = nodes[j ++];
        &#125;
    &#125;
    return root;
  &#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test63</span><br></pre></td></tr></table></figure>
<p>/* Test63 给定一棵二叉搜索树，请找出其中的第k小的结点。例如，<br>（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。*/</p>
<p>/* 按中序遍历二叉搜索树得到递增的序列 */</p>
<p>import java.util.Stack;</p>
<p>public class Test63 {<br>    TreeNode KthNode(TreeNode pRoot, int k) {<br>        if (pRoot == null)<br>            return null;<br>        Stack<TreeNode> stack = new Stack();<br>        TreeNode tmp = pRoot;<br>        int i = 0;<br>        while (tmp != null || !stack.empty()) {<br>            if (tmp != null){<br>                stack.push(tmp);<br>                tmp = tmp.left;<br>            } else{<br>                tmp = stack.pop();<br>                if(++ i == k)<br>                    return tmp;<br>                tmp = tmp.right;<br>            }<br>        }<br>        return null;<br>    }</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test64</span><br></pre></td></tr></table></figure>
<p>/* Test64 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，<br>那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，<br>那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，<br>使用GetMedian()方法获取当前读取数据的中位数。 */</p>
<p>/* 用两个PriorityQueue分别作为大顶堆和小顶堆<br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/9be0172896bd43948f8a32fb954e1be1?f=discussion*/">https://www.nowcoder.com/questionTerminal/9be0172896bd43948f8a32fb954e1be1?f=discussion*/</a></p>
<p>import java.util.PriorityQueue;<br>import java.util.Comparator;</p>
<p>public class Test64 {<br>    // 默认PriorityQueue为小顶堆<br>    private PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();</p>
<pre><code>//大顶堆
private PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(15, new Comparator&lt;Integer&gt;() &#123;
    @Override
    public int compare(Integer o1, Integer o2) &#123;
        return o2 - o1;
    &#125;
&#125;);

int count = 0; // 当前数字流中数字个数
//每次插入小顶堆的是当前大顶堆中最大的数
//每次插入大顶堆的是当前小顶堆中最小的数
//这样保证小顶堆中的数永远大于等于大顶堆中的数
//中位数就可以方便地从两者的根结点中获取了

public void Insert(Integer num) &#123;
    // 当前数字个数为偶数，则先插入大顶堆，再把大顶堆中最大的数字插入到小顶堆
    if (count % 2 == 0) &#123;
        maxHeap.offer(num);
        int max = maxHeap.poll();
        minHeap.offer(max);
    &#125; else &#123; // 为奇数时则先插入小顶堆，再把小顶堆中最小的数字插入大顶堆
        minHeap.offer(num);
        int min = minHeap.poll();
        maxHeap.offer(min);
    &#125;
    count ++;
&#125;

public Double GetMedian() &#123;
    if (count % 2 == 0) &#123; // 当前数字流中数字有偶数个，返回大、小顶堆头平均值
        return new Double(minHeap.peek() + maxHeap.peek()) / 2;
    &#125; else &#123;
        return new Double(minHeap.peek());
    &#125;
&#125;    </code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test65</span><br></pre></td></tr></table></figure>
<p>/* Test65 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。<br>例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，<br>他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：<br> {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}，<br>  {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。<br>窗口大于数组长度的时候，返回空 */</p>
<p>import java.util.ArrayList;</p>
<p>public class Test65 {<br>    public ArrayList<Integer> maxInWindows(int [] num, int size) {<br>        ArrayList<Integer> list = new ArrayList();<br>        if (size &gt; num.length || size == 0)<br>            return list;<br>        for (int i = 0; i &lt;= num.length - size; i ++) {<br>            int tmp = num[i];<br>            for (int j = i + 1; j &lt; i + size; j ++) {<br>                if (num[j] &gt; tmp)<br>                    tmp = num[j];<br>            }<br>            list.add(tmp);<br>        }<br>        return list;<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test66</span><br></pre></td></tr></table></figure>
<p>/* Test66 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。<br>路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。<br>如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。*/</p>
<p>/* 回溯法 */</p>
<p>public class Test66 {<br>    public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {<br>        // 矩阵元素的标志位，表示其是否被遍历<br>        boolean[] flag = new boolean[matrix.length];</p>
<pre><code>    for (int i = 0; i &lt; rows; i ++) &#123;
        for (int j = 0; j &lt; cols; j ++) &#123;
            // 遍历整个矩阵元素作为第一个字符的情况
            if (search(matrix, rows, cols, i, j, str, flag, 0))
                return true;
        &#125;
    &#125;
    return false;
&#125;

// k表示搜索的str中的第k号字符
public boolean search(char[] matrix, int rows, int cols, int i, int j, char[] str, boolean[] flag, int k) &#123;
    int index = i * cols + j; // 矩阵索引
    // 递归终止
    if (i &lt; 0 || j &lt; 0 || i  &gt;= rows || j &gt;= cols || matrix[index] != str[k] || flag[index] == true)
        return false;
    flag[index] = true; // 矩阵走过的位置设置为true
    // 最后一个字符正确
    if (k == str.length - 1)
        return true;

    // 递归查找i，j四周的元素是否为第k个元素
    if (search(matrix, rows, cols, i - 1, j, str, flag, k + 1) ||
        search(matrix, rows, cols, i + 1, j, str, flag, k + 1) ||
        search(matrix, rows, cols, i, j + 1, str, flag, k + 1) ||
        search(matrix, rows, cols, i, j - 1, str, flag, k + 1)) &#123;
        return true;
    &#125;

    // 四周元素都没吻合的，说明当前元素选错了，进行回退
    flag[index] = false;
    return false;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test67</span><br></pre></td></tr></table></figure>
<p>/* Test67 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，<br>每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和<br>大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。<br>但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？*/</p>
<p>public class Test67 {<br>    public int movingCount(int threshold, int rows, int cols) {<br>        int[][] matrix = new int[rows][cols];<br>        boolean[][] flag = new boolean[rows][cols];<br>        for (int i = 0; i &lt; rows; i ++) {<br>            for (int j = 0; j &lt; cols; j ++) {<br>                matrix[i][j] = numSum(i) + numSum(j);<br>            }<br>        }<br>        int count = movingCountHelper(threshold, matrix, rows, cols, 0, 0, flag);<br>        return count;<br>    }</p>
<pre><code>public int movingCountHelper(int threshold, int[][] matrix, int rows, int cols, int i, int j, boolean[][] flag) &#123;
    if (i &lt; 0 || j &lt; 0 || i &gt;= rows || j &gt;= cols || matrix[i][j] &gt; threshold || flag[i][j] == true)
        return 0;

    flag[i][j] = true;

    return 1 + movingCountHelper(threshold, matrix, rows, cols, i - 1, j, flag) 
             + movingCountHelper(threshold, matrix, rows, cols, i + 1, j, flag) 
             + movingCountHelper(threshold, matrix, rows, cols, i, j - 1, flag) 
             + movingCountHelper(threshold, matrix, rows, cols, i, j + 1, flag);
&#125;

private int numSum(int i) &#123;
    int sum = 0;
    do&#123;
        sum += i%10;
    &#125; while((i = i/10) &gt; 0);
    return sum;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Test68</span><br></pre></td></tr></table></figure>
<p>/* Test68 给你一根长度为n的绳子，请把绳子剪成整数长的m段<br>（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为<br>k[1],…,k[m]。请问k[1]x…xk[m]可能的最大乘积是多少？<br>例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，<br>此时得到的最大乘积是18。 */</p>
<p>import java.lang.Math;</p>
<p>public class Test68 {<br>    public int cutRope(int target) {<br>        // target &lt;= 3时必须分段<br>        if (target == 2)<br>            return 1;<br>        if (target == 3)<br>            return 2;</p>
<pre><code>    int[] dp = new int[target + 1];
    // target&gt;=4时分段，分段中有1、2、3时该部分最大乘积如下
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 3;
    int tmp = 0;
    for (int i = 4; i &lt;= target; i ++) &#123;
        for (int j = 1; j &lt;= i / 2; j ++) &#123;
            tmp = Math.max(tmp, dp[j] * dp[i - j]);
        &#125;
        dp[i] = tmp;
    &#125;
    return dp[target];
&#125;</code></pre>
<p>}</p>
<p>```</p>
<p>#剑指Offer</p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/08/19/e6uyhEqAtD8sxHB.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/08/24/%E5%89%91%E6%8C%87Offer-Test02-Test30/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/08/19/zAVSTgHkaJmCjoy.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">剑指Offer Test02-Test30</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/08/24/剑指Offer-Test02-Test30/" title="剑指Offer Test02-Test30"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/19/zAVSTgHkaJmCjoy.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-24</div><div class="relatedPosts_title">剑指Offer Test02-Test30</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Yuwen Mi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>