<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yuwen Mi&#39;s Space</title>
  <icon>https://www.gravatar.com/avatar/376f6cb13e98ff675f5b604a199d7024</icon>
  <subtitle>👊👊👊👊</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-24T13:45:40.388Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yuwen Mi</name>
    <email>mywjyw@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer Test02-Test30</title>
    <link href="http://yoursite.com/2020/08/24/%E5%89%91%E6%8C%87Offer-Test02-Test30/"/>
    <id>http://yoursite.com/2020/08/24/%E5%89%91%E6%8C%87Offer-Test02-Test30/</id>
    <published>2020-08-24T13:41:47.000Z</published>
    <updated>2020-08-24T13:45:40.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Test2"><a href="#Test2" class="headerlink" title="Test2"></a>Test2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Test02 设计一个类，我们只能生成该类的一个实例。</span><br><span class="line"></span><br><span class="line">&#x2F;* 饿汉式 *&#x2F;</span><br><span class="line">class A &#123;</span><br><span class="line">    private A() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private static final A instance &#x3D; new A();</span><br><span class="line"></span><br><span class="line">    public static A getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 懒汉式 *&#x2F;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">    private B() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static B instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static getInstance() &#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null) </span><br><span class="line">            instance &#x3D; new B();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Test3"><a href="#Test3" class="headerlink" title="Test3"></a>Test3</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test03 在一个二维数组中，每一行都按照从左到右递增的顺序排序，</span><br><span class="line">    每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的</span><br><span class="line">    一个二维数组和一个整数，判断数组中是否函数该整数。*&#x2F;</span><br><span class="line"></span><br><span class="line">class Test03 &#123;</span><br><span class="line">    public boolean search(int target, int[][] array) &#123;</span><br><span class="line">        int length1 &#x3D; array[0].length; &#x2F;&#x2F; 列数</span><br><span class="line">        int length2 &#x3D; array.length; &#x2F;&#x2F; 行数</span><br><span class="line"></span><br><span class="line">        int row &#x3D; 0;</span><br><span class="line">        int col &#x3D; length1 - 1;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 从第一行最后一列找起</span><br><span class="line">        while (row &lt; length2 &amp;&amp; col &gt;&#x3D; 0) &#123;</span><br><span class="line">            if(array[row][col] &#x3D;&#x3D; target)</span><br><span class="line">                return true;</span><br><span class="line">            else if (target &lt; array[row][col]) &#123;</span><br><span class="line">                col --;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                row ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test4"><a href="#Test4" class="headerlink" title="Test4"></a>Test4</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test04 请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。</span><br><span class="line">    例如输入&quot;We are happy&quot;，则输出&quot;We%20are%20happy&quot; *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test04 &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">        StringBuffer tmp &#x3D; new StringBuffer();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">            char c &#x3D; str.charAt(i);</span><br><span class="line">            if (c &#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">                tmp.append(&quot;%20&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tmp.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test5"><a href="#Test5" class="headerlink" title="Test5"></a>Test5</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test05 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 *&#x2F;</span><br><span class="line">public class Test05 &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">        while (listNode !&#x3D; null) &#123;</span><br><span class="line">            arraylist.add(0, listNode.val);</span><br><span class="line">            listNode &#x3D; listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return arraylist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test6"><a href="#Test6" class="headerlink" title="Test6"></a>Test6</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test06 根据某二叉树前序遍历和中序遍历的结果重建二叉树 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays</span><br><span class="line"></span><br><span class="line">public class Test06 &#123;</span><br><span class="line">    public TreeNode reConstructBinaryTree(int [] pre, int [] in) &#123;</span><br><span class="line">        if (pre.length &#x3D;&#x3D; 0 || in.length &#x3D;&#x3D; 0) </span><br><span class="line">            return null;</span><br><span class="line">        TreeNode root &#x3D; new TreeNode(pre[0]);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; in.length; i ++) &#123;</span><br><span class="line">            if (pre[0] &#x3D;&#x3D; in[i]) &#123;</span><br><span class="line">                &#x2F;&#x2F; copyOfRange函数左闭右开</span><br><span class="line">                root.left &#x3D; reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));</span><br><span class="line"></span><br><span class="line">                root.right &#x3D; reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test7"><a href="#Test7" class="headerlink" title="Test7"></a>Test7</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test07 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 *&#x2F;</span><br><span class="line">&#x2F;* Push直接push到stack1中，</span><br><span class="line">    Pop：若stack2中没有数据，则先将stack1中数据都push进去再pop stack2；</span><br><span class="line">    若stack2中有数据则直接Pop stack2 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Test07 &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    public void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if (stack2.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            while (stack1.size() !&#x3D; 0) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test8"><a href="#Test8" class="headerlink" title="Test8"></a>Test8</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test08 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</span><br><span class="line">输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</span><br><span class="line">例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为1。</span><br><span class="line">NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 二分法：</span><br><span class="line">    右断点看作target，mid与target比较，</span><br><span class="line">    mid &lt; target，last &#x3D; mid</span><br><span class="line">    mid &gt; target，first &#x3D; mid+1</span><br><span class="line">    *&#x2F;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test08 &#123;</span><br><span class="line">    public int minNumberInRotateArray(int[] array) &#123;</span><br><span class="line">        if (array.length &#x3D;&#x3D; 0) return 0;</span><br><span class="line"></span><br><span class="line">        int target &#x3D; array[array.length - 1];</span><br><span class="line">        int first &#x3D; 0;</span><br><span class="line">        int last &#x3D; array.length - 1;</span><br><span class="line">        int mid &#x3D; (first + last) &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F; 不能等</span><br><span class="line">        while (first &lt; last) &#123;</span><br><span class="line">            if (array[first] &lt; array[last]) </span><br><span class="line">                return array[first];</span><br><span class="line">            if (array[mid] &lt; target) &#123;</span><br><span class="line">                last &#x3D; mid;</span><br><span class="line">            &#125; else if (array[mid] &gt; target) &#123;</span><br><span class="line">                first &#x3D; mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                last --;</span><br><span class="line">            &#125;</span><br><span class="line">            mid &#x3D; (first + last) &#x2F; 2;</span><br><span class="line">            target &#x3D; array[last];</span><br><span class="line">        &#125;</span><br><span class="line">        return array[first];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test9"><a href="#Test9" class="headerlink" title="Test9"></a>Test9</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test09 现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</span><br><span class="line">n&lt;&#x3D;39 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 递归法，时间 复杂度 O(n2)。*&#x2F;</span><br><span class="line">public class Test09 &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        if (n &#x3D;&#x3D; 0) return 0;</span><br><span class="line">        if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">        return Fibonacci(n - 2) + Fibonacci(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 递归法会重复计算，因此可以迭代计算，每次保存下次需要的数据</span><br><span class="line">    sum 存储第 n 项的值</span><br><span class="line">    one 存储第 n-1 项的值</span><br><span class="line">    two 存储第 n-2 项的值</span><br><span class="line"> *&#x2F;</span><br><span class="line">public in Fibonacci(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1) return n;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    int one &#x3D; 1;</span><br><span class="line">    int two &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        sum &#x3D; one + two;</span><br><span class="line">        two &#x3D; one;</span><br><span class="line">        one &#x3D; sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test10"><a href="#Test10" class="headerlink" title="Test10"></a>Test10</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test10 一只青蛙一次可以跳上1级台阶，也可以跳上2级。</span><br><span class="line">求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 上n层台阶有f(n)种，</span><br><span class="line">    第一步有两种选择：1.先上1层再上n-1层有f(n-1)</span><br><span class="line">                  2.先上2层再上n-2层有f(n-2)</span><br><span class="line">    所以f(n) &#x3D; f(n-1) + f(n-2)是个斐波那契</span><br><span class="line">    f(1)&#x3D;1 f(2)&#x3D;2 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test10 &#123;</span><br><span class="line">    public int JumpFloor(int target) &#123;</span><br><span class="line">        if (target &#x3D;&#x3D; 1 || target &#x3D;&#x3D; 2) return n;</span><br><span class="line">        return JumpFloor(target-1) + JumpFloor(target-2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test11"><a href="#Test11" class="headerlink" title="Test11"></a>Test11</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test11 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。</span><br><span class="line">    求该青蛙跳上一个n级的台阶总共有多少种跳法。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设跳上n级台阶有f(n)种跳法，</span><br><span class="line">    跳上n级可以分为n种，在第1级跳n-1步，...在第n-1级跳1步</span><br><span class="line">    所以f(n) &#x3D; f(1) + f(2)+...+f(n-1) *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test11 &#123;</span><br><span class="line">    public int JumpFloorII(int target) &#123;</span><br><span class="line">        if (target &#x3D;&#x3D; 1 || target &#x3D;&#x3D; 2)  return target;</span><br><span class="line">        return 2*JumpFloorII(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="Test12"><a href="#Test12" class="headerlink" title="Test12"></a>Test12</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test12 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。</span><br><span class="line">请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* f(n)&#x3D;f(n-1)+f(n-2) f(1)&#x3D;1 f(2)&#x3D;2 *&#x2F;</span><br><span class="line">public class Test12 &#123;</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">        if (target &#x3D;&#x3D; 0 || target &#x3D;&#x3D; 1 || target &#x3D;&#x3D; 2) return target;</span><br><span class="line">        return RectCover(target - 1) + RectCover(target - 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test13"><a href="#Test13" class="headerlink" title="Test13"></a>Test13</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test13 输入一个整数，输出该数32位二进制表示中1的个数。</span><br><span class="line">    其中负数用补码表示。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* val &amp; (val-1) 得到的值的二进制形式正好是val最低位的1变为0 </span><br><span class="line">    例：val :1101000, val-1: 1100111 那么val &amp; （val-1） : 1100000</span><br><span class="line">    *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test13 &#123;</span><br><span class="line">    public int NumberOf1(int n) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while (n !&#x3D; 0) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            n &#x3D; n &amp; (n - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test14"><a href="#Test14" class="headerlink" title="Test14"></a>Test14</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test14 给定一个double类型的浮点数base和int类型的整数exponent。</span><br><span class="line">求base的exponent次方。保证base和exponent不同时为0 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 递归法快速幂 </span><br><span class="line">    偶数直接平方，奇数再乘上base *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test14 &#123;</span><br><span class="line">    public double Power(double base, int exponent) &#123;</span><br><span class="line">        &#x2F;&#x2F; 考虑e &lt; 0的情况</span><br><span class="line">        if (exponent &lt; 0) &#123;</span><br><span class="line">            base &#x3D; 1 &#x2F; base;</span><br><span class="line">            exponent &#x3D;  - exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        if (exponent &#x3D;&#x3D; 0) return 1;</span><br><span class="line">        if (exponent &#x3D;&#x3D; 1) return base;</span><br><span class="line"></span><br><span class="line">        double res;</span><br><span class="line">        res &#x3D; Power(base, exponent &gt;&gt; 1);</span><br><span class="line">        res *&#x3D; res;</span><br><span class="line">        if  (exponent &#x2F; 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            res *&#x3D; base;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test15"><a href="#Test15" class="headerlink" title="Test15"></a>Test15</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test15 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，</span><br><span class="line">所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 1.用一个临时数组，遍历原数组向新数组中存奇数和偶数，时间复杂度O(n) 空间O(n)</span><br><span class="line">   2.in-place算法</span><br><span class="line">初始化操作：记录一个变量i表示已经将奇数放好的下一个位置，显然最开始i&#x3D;0,表示还没有一个奇数放好。</span><br><span class="line">j 表示数组的下标，初始值为0， 表示从下标0开始遍历。</span><br><span class="line">如果遇到偶数，j++</span><br><span class="line">如果遇到奇数,假设位置为j，就将此奇数插入到i所指的位置，然后i往后移动一个位置，在插入之前，显然会涉及到数据的移动，也就是将[i,j-1]整体往后移动。</span><br><span class="line">直到整个数组遍历完毕，结束 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test15 &#123;</span><br><span class="line">    public void reOrderArray(int [] array) &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int tmp;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; array.length; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F; j索引位置为奇数</span><br><span class="line">            if ((array[j] &amp; 0x01) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                tmp &#x3D; array[j];</span><br><span class="line">                for (int k &#x3D; j; k &gt; i; k --) &#123;</span><br><span class="line">                    array[k] &#x3D; array[k - 1];</span><br><span class="line">                &#125;</span><br><span class="line">                array[i] &#x3D; tmp;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test16"><a href="#Test16" class="headerlink" title="Test16"></a>Test16</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test16 输入一个链表，输出该链表中倒数第k个结点。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 倒数第k个节点与null节点间有k个指针。所以构造两个指针，slow指针到fast指针间也有k个指针，</span><br><span class="line">    这样当fast指针指向null节点时，slow指针正好指向目标节点 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test16 &#123;</span><br><span class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow &#x3D; head;</span><br><span class="line">        ListNode fast &#x3D; head;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; k; i ++) &#123;</span><br><span class="line">            if (fast &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            fast &#x3D; fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while (fast !&#x3D; null) &#123;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">            fast &#x3D; fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test17"><a href="#Test17" class="headerlink" title="Test17"></a>Test17</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test17 输入一个链表，反转链表后，输出新链表的表头。 *&#x2F;</span><br><span class="line">&#x2F;*</span><br><span class="line">初始化：3个指针</span><br><span class="line">1）pre指针指向已经反转好的链表的最后一个节点，最开始没有反转，所以指向null</span><br><span class="line">2）cur指针指向待反转链表的第一个节点，最开始第一个节点待反转，所以指向head</span><br><span class="line">3）nxt指针指向待反转链表的第二个节点，目的是保存链表，因为cur改变指向后，后面的链表则失效了，所以需要保存</span><br><span class="line"></span><br><span class="line">循环执行：</span><br><span class="line">nxt&#x3D;cur.next</span><br><span class="line">cur.next&#x3D;pre</span><br><span class="line">pre&#x3D;cur cur&#x3D;nxt</span><br><span class="line">循环条件是cur!&#x3D;null</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test17 &#123;</span><br><span class="line">    public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode pre &#x3D; null;</span><br><span class="line">        ListNode nxt;</span><br><span class="line">        while (head !&#x3D; null) &#123;</span><br><span class="line">            nxt &#x3D; head.next;</span><br><span class="line">            head.next &#x3D; pre;</span><br><span class="line">            pre &#x3D; head;</span><br><span class="line">            head &#x3D; nxt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test18"><a href="#Test18" class="headerlink" title="Test18"></a>Test18</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test18 输入两个单调递增的链表，输出两个链表合成后的链表，</span><br><span class="line">    当然我们需要合成后的链表满足单调不减规则。*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test18 &#123;</span><br><span class="line">    public ListNode Merge(ListNode list1,ListNode list2) &#123;</span><br><span class="line">        ListNode head &#x3D;  new ListNode(-1);</span><br><span class="line">        ListNode tmp &#x3D; head;</span><br><span class="line"></span><br><span class="line">        while (list1 !&#x3D; null &amp;&amp; list2 !&#x3D; null) &#123;</span><br><span class="line">            if (list1.val &lt; list2.val) &#123;</span><br><span class="line">                tmp.next &#x3D; list1;</span><br><span class="line">                list1 &#x3D; list1.next;</span><br><span class="line">            &#125; else if (list1.val &gt; list2.val) &#123;</span><br><span class="line">                tmp.next &#x3D; list2;</span><br><span class="line">                list2 &#x3D; list2.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tmp.next &#x3D; list1;</span><br><span class="line">                list1 &#x3D; list1.next;</span><br><span class="line">                tmp &#x3D; tmp.next;</span><br><span class="line">                tmp.next &#x3D; list2;</span><br><span class="line">                list2 &#x3D; list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp &#x3D; tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (list1 !&#x3D; null) tmp.next &#x3D; list1;</span><br><span class="line">        if (list2 !&#x3D; null) tmp.next &#x3D; list2;</span><br><span class="line"></span><br><span class="line">        return head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test19"><a href="#Test19" class="headerlink" title="Test19"></a>Test19</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test19 输入两棵二叉树A，B，判断B是不是A的子结构。</span><br><span class="line">（ps：我们约定空树不是任意一个树的子结构）*&#x2F;</span><br><span class="line">&#x2F;* 递归 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test19 &#123;</span><br><span class="line">    public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123;</span><br><span class="line">        boolean res &#x3D; false;</span><br><span class="line">        if (root1 !&#x3D; null &amp;&amp; root2 !&#x3D; null) &#123;</span><br><span class="line">            if (root1.val &#x3D;&#x3D; root2.val) &#123;</span><br><span class="line">                res &#x3D; doesTree1HaveTree2(root1, root2);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!res) &#123;</span><br><span class="line">                res &#x3D; HasSubtree(root1.left, root2);</span><br><span class="line">            &#125; </span><br><span class="line">            if (!res) &#123;</span><br><span class="line">                res &#x3D; HasSubtree(root1.right, root2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean doesTree1HaveTree2(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">        if (root2 &#x3D;&#x3D; null) </span><br><span class="line">            return true;</span><br><span class="line">        if (root1 &#x3D;&#x3D; null)</span><br><span class="line">            return false;</span><br><span class="line">        if (root1.val !&#x3D; root2.val) </span><br><span class="line">            return false;</span><br><span class="line">        return doesTree1HaveTree2(root1.left, root2.left) &amp;&amp; doesTree1HaveTree2(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Test20"><a href="#Test20" class="headerlink" title="Test20"></a>Test20</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test20 操作给定的二叉树，将其变换为源二叉树的镜像。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 递归 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test20 &#123;</span><br><span class="line">    public void Mirror(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) return ;</span><br><span class="line">        TreeNode tmp &#x3D; root.left;</span><br><span class="line">        root.left &#x3D; root.right;</span><br><span class="line">        root.right &#x3D; tmp;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test21"><a href="#Test21" class="headerlink" title="Test21"></a>Test21</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test21 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，</span><br><span class="line">如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字</span><br><span class="line">1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 把矩阵外层看成一个圈，打印每个圈；</span><br><span class="line"></span><br><span class="line">定义四个变量代表范围，top、bottom、left、right</span><br><span class="line"></span><br><span class="line">向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 top 加一，同时判断是否和代表下边界的 bottom 交错</span><br><span class="line">向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错</span><br><span class="line">向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 bottom 减一，同时判断是否和代表上边界的 top 交错</span><br><span class="line">向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test21 &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList(); </span><br><span class="line">        if (matrix &#x3D;&#x3D; null || matrix.length &#x3D;&#x3D; 0 || matrix[0].length &#x3D;&#x3D; 0)</span><br><span class="line">            return list;</span><br><span class="line">        int top &#x3D; 0;</span><br><span class="line">        int bottom &#x3D; matrix.length - 1;</span><br><span class="line">        int left &#x3D; 0;</span><br><span class="line">        int right &#x3D; matrix[0].length - 1;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F; 最顶一行</span><br><span class="line">            for (int i &#x3D; left; i &lt;&#x3D; right; i ++) &#123;</span><br><span class="line">                list.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (++ top &gt; bottom)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 最右侧一行</span><br><span class="line">            for (int i &#x3D; top; i &lt;&#x3D; bottom; i ++) &#123;</span><br><span class="line">                list.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (--right &lt; left)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 最底层一行</span><br><span class="line">            for (int i &#x3D; right; i &gt;&#x3D; left; i --) &#123;</span><br><span class="line">                list.add(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (--bottom &lt; top)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 最左侧一行</span><br><span class="line">            for (int i &#x3D; bottom; i &gt;&#x3D; top; i  --) &#123;</span><br><span class="line">                list.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (++ left &gt; right)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test22"><a href="#Test22" class="headerlink" title="Test22"></a>Test22</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的</span><br><span class="line">min函数（时间复杂度应为O（1））*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 需要创建一个辅助栈来实现呢min函数，如果仅仅使用一个辅助变量min，</span><br><span class="line">则其值可能因为min元素被出栈而失效.</span><br><span class="line">    辅助栈中成员数量与栈中相同，对应着栈的最小值 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Test22 &#123;</span><br><span class="line">    private Stack&lt;Integer&gt; stack1 &#x3D; new Stack();</span><br><span class="line">    private Stack&lt;Integer&gt; stackSupport &#x3D; new Stack();</span><br><span class="line"></span><br><span class="line">    public void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        if (stackSupport.empty() || node &lt; stackSupport.peek()) &#123;</span><br><span class="line">            stackSupport.push(node);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stackSupport.push(stackSupport.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pop() &#123;</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stackSupport.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int min() &#123;</span><br><span class="line">        return stackSupport.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test23"><a href="#Test23" class="headerlink" title="Test23"></a>Test23</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test23 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为</span><br><span class="line">该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是</span><br><span class="line">某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，</span><br><span class="line">但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 新建一个栈，将数组A压入栈中，当栈顶元素等于数组B时，就将其出栈，</span><br><span class="line">当循环结束时，判断栈是否为空，若为空则返回true. *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Test23 &#123;</span><br><span class="line">    public boolean IsPopOrder(int [] pushA,int [] popA) &#123;</span><br><span class="line">        if (pushA.length &#x3D;&#x3D; 0 || popA.length &#x3D;&#x3D; 0 || pushA.length !&#x3D; popA.length)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack &#x3D; new Stack();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0, j &#x3D; 0; i &lt; pushA.length; i ++) &#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line"></span><br><span class="line">            while (!stack.empty() &amp;&amp; stack.peek() &#x3D;&#x3D; popA[j]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test24"><a href="#Test24" class="headerlink" title="Test24"></a>Test24</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test24 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。</span><br><span class="line">如果是则返回true,否则返回false。</span><br><span class="line">假设输入的数组的任意两个数字都互不相同。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 后序遍历 左-&gt;右-&gt;根，所以最后一个元素是根元素，BST要求所有左子树元素小于根，右子树元素大于根。</span><br><span class="line">那么，只需要不断地确定出左子树区间和右子树区间，并且判断：左子树区间的所有结点值 &lt; 根结点值 &lt; 右子树区间所有结点值，</span><br><span class="line">这个条件是否满足即可 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test24 &#123;</span><br><span class="line">    public boolean VerifySquenceOfBST(int [] sequence) &#123;</span><br><span class="line">        if (sequence &#x3D;&#x3D; null || sequence.length &#x3D;&#x3D; 0)</span><br><span class="line">            return false;</span><br><span class="line">        return helpVerify(sequence, 0, sequence.length - 1); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean helpVerify(int [] sequence, int start, int end) &#123;</span><br><span class="line">        &#x2F;&#x2F; 左子树空的话会&gt;</span><br><span class="line">        if (start &gt;&#x3D; end)</span><br><span class="line">            return true;</span><br><span class="line">        int root &#x3D; sequence[end];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; start - i-1为左子树</span><br><span class="line">        int i &#x3D; start;</span><br><span class="line">        for (; i &lt; end; i ++) &#123;</span><br><span class="line">            if (sequence[i] &gt; root)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j &#x3D; i; j &lt; end; j ++) &#123;</span><br><span class="line">            if (sequence[j] &lt; root)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断左右子树是否符合BST</span><br><span class="line">        return helpVerify(sequence, start, i - 1) &amp;&amp; </span><br><span class="line">                helpVerify(sequence, i, end - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test25"><a href="#Test25" class="headerlink" title="Test25"></a>Test25</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*Test25 输入一颗二叉树的根节点和一个整数，</span><br><span class="line">按字典序打印出二叉树中结点值的和为输入整数的所有路径。</span><br><span class="line">路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* </span><br><span class="line">递归三要素</span><br><span class="line">1.明白递归函数的功能：FindPath(TreeNode* root,int sum)，从root节点出发，找和为sum的路径</span><br><span class="line">2.递归终止条件：当root节点为叶子节点并且target-root.val&#x3D;&#x3D;0, 表示找到了一条符合条件的路径</span><br><span class="line">3.下一次递归：如果左子树不空，递归左子树FindPath(root-&gt;left, target),如果右子树不空，递归右子树，FindPath(root-&gt;right, target)</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test25 &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list &#x3D; new ArrayList();</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll &#x3D; new ArrayList();</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null)</span><br><span class="line">            return listAll;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target -&#x3D; root.val;</span><br><span class="line">        &#x2F;&#x2F; 当前节点为叶节点且target&#x3D;0</span><br><span class="line">        if (target &#x3D;&#x3D; 0 &amp;&amp; root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) </span><br><span class="line">            listAll.add(new ArrayList(list));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 继续递归左右子树</span><br><span class="line">        FindPath(root.left, target);</span><br><span class="line">        FindPath(root.right, target);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 删除list中最后一个节点，回退到当前节点状态</span><br><span class="line">        list.remove(list.size() - 1);</span><br><span class="line"></span><br><span class="line">        return listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test26"><a href="#Test26" class="headerlink" title="Test26"></a>Test26</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test26 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，</span><br><span class="line">另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。</span><br><span class="line">（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* step1 在旧链表中创建新链表（如1&#96;在1号节点后），不处理新链表的兄弟节点</span><br><span class="line">    step2 遍历链表，初始化新节点中的兄弟节点</span><br><span class="line">    step3 从旧链表中拆分得到新链表 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test26 &#123;</span><br><span class="line">    public RandomListNode Clone(RandomListNode pHead) &#123;</span><br><span class="line">        if (pHead &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        RandomListNode curNode &#x3D; pHead;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; step 1</span><br><span class="line">        while (curNode !&#x3D; null) &#123;</span><br><span class="line">            RandomListNode cloneNode &#x3D; new RandomListNode(curNode.label);</span><br><span class="line">            cloneNode.next &#x3D; curNode.next;</span><br><span class="line">            curNode.next &#x3D; cloneNode;</span><br><span class="line">            curNode &#x3D; cloneNode.next;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; step 2</span><br><span class="line">        curNode &#x3D; pHead;</span><br><span class="line">        while (curNode !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里要注意复制节点的random应该指向复制节点，别指向原节点了</span><br><span class="line">            curNode.next.random &#x3D; curNode.random&#x3D;&#x3D;null ? null : curNode.random.next;</span><br><span class="line">            curNode &#x3D; curNode.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; step3</span><br><span class="line">        curNode &#x3D; pHead;</span><br><span class="line">        RandomListNode pCloneHead &#x3D; pHead.next; &#x2F;&#x2F; 复制链表的头节点</span><br><span class="line">        while (curNode !&#x3D; null) &#123;</span><br><span class="line">            RandomListNode cloneNode &#x3D; curNode.next;</span><br><span class="line">            curNode.next &#x3D; cloneNode.next;</span><br><span class="line">            &#x2F;&#x2F; 尾节点的话next会是null，要进行判断</span><br><span class="line">            cloneNode.next &#x3D; cloneNode.next&#x3D;&#x3D;null ? null : cloneNode.next.next;</span><br><span class="line">            curNode &#x3D; curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test27"><a href="#Test27" class="headerlink" title="Test27"></a>Test27</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test27 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</span><br><span class="line">要求不能创建任何新的结点，只能调整树中结点指针的指向。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 中序遍历一棵二叉搜索树得到的序列是从小到大排列的</span><br><span class="line">    中序遍历链表后再添加指针构成双向链表 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test27 &#123;</span><br><span class="line">    public TreeNode Convert(TreeNode pRootOfTree) &#123;</span><br><span class="line">        if (pRootOfTree &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; list &#x3D; new ArrayList();</span><br><span class="line">        &#x2F;&#x2F; 中序遍历，结果保存到list中</span><br><span class="line">        Convert(pRootOfTree, list);</span><br><span class="line">        return Convert(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Convert(TreeNode pRootOfTree, ArrayList list) &#123;</span><br><span class="line">        if (pRootOfTree.left !&#x3D;null) &#123;</span><br><span class="line">            Convert(pRootOfTree.left, list);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(pRootOfTree);</span><br><span class="line">        if (pRootOfTree.right !&#x3D; null) &#123;</span><br><span class="line">            Convert(pRootOfTree.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode Convert(ArrayList&lt;TreeNode&gt; list) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; list.size() - 1; i ++) &#123;</span><br><span class="line">            list.get(i).right &#x3D; list.get(i+1);</span><br><span class="line">            list.get(i+1).left &#x3D; list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return list.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test28"><a href="#Test28" class="headerlink" title="Test28"></a>Test28</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test28 输入一个字符串,按字典序打印出该字符串中字符的所有排列。</span><br><span class="line">例如输入字符串abc,则按字典序打印出由字符a,b,c</span><br><span class="line">所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。*&#x2F;</span><br><span class="line"></span><br><span class="line">还没做</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Test29"><a href="#Test29" class="headerlink" title="Test29"></a>Test29</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test29 数组中有一个数字出现的次数超过数组长度的一半，</span><br><span class="line">请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。</span><br><span class="line">由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：对数组进行顺序排列，目标数若存在肯定位于中间位置。</span><br><span class="line">    获得该数后遍历数组判断是否符合要求 *&#x2F;</span><br><span class="line">&#x2F;* 时间复杂度O(nlgn) 空间复杂度O(1) *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Test29 &#123;</span><br><span class="line">    public int MoreThanHalfNum_Solution(int [] array) &#123;</span><br><span class="line">           Arrays.sort(array);</span><br><span class="line">           int target &#x3D; array[array.length &#x2F; 2];</span><br><span class="line">           int count &#x3D; 0;</span><br><span class="line">           for (int i &#x3D; 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">               if (array[i] &#x3D;&#x3D; target)</span><br><span class="line">                   count ++;</span><br><span class="line">           &#125;</span><br><span class="line">           if (count &gt; array.length &#x2F; 2)</span><br><span class="line">               return target;</span><br><span class="line">           return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二：</span><br><span class="line">加入数组中存在众数，那么众数一定大于数组的长度的一半。</span><br><span class="line">思想就是：如果两个数不相等，就消去这两个数，最坏情况下，</span><br><span class="line">每次消去一个众数和一个非众数，那么如果存在众数，最后留下的数肯定是众数。</span><br><span class="line"></span><br><span class="line">具体做法：</span><br><span class="line"></span><br><span class="line">初始化：候选人cond &#x3D; -1， 候选人的投票次数cnt &#x3D; 0</span><br><span class="line">遍历数组，如果cnt&#x3D;0， 表示没有候选人，则选取当前数为候选人，++cnt</span><br><span class="line">否则，如果cnt &gt; 0, 表示有候选人，如果当前数&#x3D;cond，则++cnt，否则--cnt</span><br><span class="line">直到数组遍历完毕，最后检查cond是否为众数</span><br><span class="line"></span><br><span class="line">时间复杂度O(n) 空间O(1)</span><br><span class="line">*&#x2F;</span><br><span class="line">    public int MoreThanHalfNum_Solution(int [] array) &#123;</span><br><span class="line">        int cond &#x3D; -1, cnt &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">            if (cnt &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                cond &#x3D; array[i];</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (array[i] &#x3D;&#x3D; cond) </span><br><span class="line">                    ++ cnt;</span><br><span class="line">                else</span><br><span class="line">                    -- cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">               if (array[i] &#x3D;&#x3D; cond)</span><br><span class="line">                   count ++;</span><br><span class="line">           &#125;</span><br><span class="line">           if (count &gt; array.length &#x2F; 2)</span><br><span class="line">               return target;</span><br><span class="line">           return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Test30"><a href="#Test30" class="headerlink" title="Test30"></a>Test30</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test30 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，</span><br><span class="line">    则最小的4个数字是1,2,3,4。 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：排序后输出前k个数 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test30 &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123;</span><br><span class="line">        if (k &gt; input.length)</span><br><span class="line">            return null;</span><br><span class="line">        Arrays.sort(input);</span><br><span class="line">        ArrayList&lt;Integer&gt; list&#x3D; new ArrayList();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; k; i ++) &#123;</span><br><span class="line">            list.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二：优先队列PriorityQueue *&#x2F;</span><br></pre></td></tr></table></figure><p>#剑指Offer</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Test2&quot;&gt;&lt;a href=&quot;#Test2&quot; class=&quot;headerlink&quot; title=&quot;Test2&quot;&gt;&lt;/a&gt;Test2&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    
    <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>JavaGuide笔记</title>
    <link href="http://yoursite.com/2020/08/19/JavaGuide%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/19/JavaGuide%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-19T07:04:57.000Z</published>
    <updated>2020-08-19T07:05:27.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h1><h2 id="java基本功"><a href="#java基本功" class="headerlink" title="java基本功"></a>java基本功</h2><h3 id="java和c-的区别"><a href="#java和c-的区别" class="headerlink" title="java和c++的区别"></a>java和c++的区别</h3><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li><li><em>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</em></li></ul><h3 id="Java语法"><a href="#Java语法" class="headerlink" title="Java语法"></a>Java语法</h3><h4 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h4><ol><li>泛型方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt; E &gt; void printArray( E[] inputArray )</span><br><span class="line">   &#123;         </span><br><span class="line">         for ( E element : inputArray )&#123;        </span><br><span class="line">            System.out.printf( &quot;%s &quot;, element );</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><em>常用的通配符为： T，E，K，V，？</em></p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个java类型</li><li>K V (key value) 分别代表java键值中的Key Value</li><li>E (element) 代表Element</li></ul><h4 id="hashCode-与equals"><a href="#hashCode-与equals" class="headerlink" title="hashCode()与equals()"></a>hashCode()与equals()</h4><p><a href="https://www.cnblogs.com/skywang12345/p/3324958.html">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="8种基本类型的包装类和常量池"><a href="#8种基本类型的包装类和常量池" class="headerlink" title="8种基本类型的包装类和常量池"></a>8种基本类型的包装类和常量池</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 &#x3D; 40;</span><br><span class="line">Integer i2 &#x3D; 40;</span><br><span class="line">Integer i3 &#x3D; 0;</span><br><span class="line">Integer i4 &#x3D; new Integer(40);</span><br><span class="line">Integer i5 &#x3D; new Integer(40);</span><br><span class="line">Integer i6 &#x3D; new Integer(0);</span><br><span class="line"></span><br><span class="line">System.out.println(“i1&#x3D;i2   “ + (i1 &#x3D;&#x3D; i2));</span><br><span class="line">System.out.println(“i1&#x3D;i2+i3   “ + (i1 &#x3D;&#x3D; i2 + i3));</span><br><span class="line">System.out.println(“i1&#x3D;i4   “ + (i1 &#x3D;&#x3D; i4));</span><br><span class="line">System.out.println(“i4&#x3D;i5   “ + (i4 &#x3D;&#x3D; i5));</span><br><span class="line">System.out.println(“i4&#x3D;i5+i6   “ + (i4 &#x3D;&#x3D; i5 + i6));   </span><br><span class="line">System.out.println(“40&#x3D;i5+i6   “ + (40 &#x3D;&#x3D; i5 + i6));     </span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i1&#x3D;i2   true</span><br><span class="line">i1&#x3D;i2+i3   true</span><br><span class="line">i1&#x3D;i4   false</span><br><span class="line">i4&#x3D;i5   false</span><br><span class="line">i4&#x3D;i5+i6   true</span><br><span class="line">40&#x3D;i5+i6   true</span><br></pre></td></tr></table></figure><p>解释：<br>+操作不适用于Integer对线，因此回自动拆箱操作，进行数值相加。</p><h2 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h2><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="在java中定义无参的构造方法"><a href="#在java中定义无参的构造方法" class="headerlink" title="在java中定义无参的构造方法"></a>在java中定义无参的构造方法</h4><p>Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>private修饰属性，public方法用来获得属性并返回。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><em>关于继承如下 3 点请记住：</em><br>1 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<em>只是拥有</em>。<br>2 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>3 子类可以用自己的方式实现父类的方法。（以后介绍）。</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><h2 id="Java核心技术"><a href="#Java核心技术" class="headerlink" title="Java核心技术"></a>Java核心技术</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><em>注意：</em> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>与进程不同，同类的多个线程共享同一块内存空间和一组系统资源。</p><p><em>进程是系统运行程序的基本单位</em></p><h3 id="文件与I-O流"><a href="#文件与I-O流" class="headerlink" title="文件与I/O流"></a>文件与I/O流</h3><p><em>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</em><br>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>[image:8C704DD8-7B72-4EF3-8FBF-0C6B3706B105-6931-0000695C8EBD05B1/Java-Collections.jpeg]</p><h2 id="Collection子接口List"><a href="#Collection子接口List" class="headerlink" title="Collection子接口List"></a>Collection子接口List</h2><h3 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h3><ol><li>ArrayList 是 List 的主要实现类，底层使用 Object[ ]存储，适用于频繁的查找工作，线程不安全 ；</li><li>Vector 是 List 的古老实现类，底层使用 Object[ ]存储，线程安全的。</li></ol><h3 id="ArrayLIst和LinkedList区别"><a href="#ArrayLIst和LinkedList区别" class="headerlink" title="ArrayLIst和LinkedList区别"></a>ArrayLIst和LinkedList区别</h3><ol><li><em>底层数据结构</em>：<code>Arraylist </code>底层使用的是 <code>Object</code><em>数组</em>；<code>LinkedList</code> 底层使用的是 <em>双向链表</em> 数据结构</li><li><em>插入和删除是否受元素位置的影响：</em> ① <code>ArrayList</code><em>采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</em> 比如：执行<code>add(E e)</code>方法的时候，<code> ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话<code>（add(int index, E element)）</code>时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <code>LinkedList</code><em>采用链表存储，所以对于</em><code>add(E e)</code><em>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置</em>i<em>插入和删除元素的话<code>（*(add(int index, E element)*）</code> 时间复杂度近似为</em><code>o(n))</code><em>因为需要先移动到指定位置再插入。</em></li><li><em>内存空间占用：</em> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h2 id="Collection子接口Set"><a href="#Collection子接口Set" class="headerlink" title="Collection子接口Set"></a>Collection子接口Set</h2><h3 id="Comparable和Comparator"><a href="#Comparable和Comparator" class="headerlink" title="Comparable和Comparator"></a>Comparable和Comparator</h3><ul><li><code>comparable</code> 接口实际上是出自<br><code>java.lang</code>包 它有一个<br><code>compareTo(Object obj)</code> 方法用来排序</li><li><code>comparator</code> 接口实际上是出自 <code>java.util</code> 包它有一个<br><code>compare(Object obj1, Object obj2)</code> 方法用来排序</li></ul><p><code>implements Comparable</code>接口的类重写<code>compareTo</code>来实现自定义排序</p><h3 id="set无序性和不可重复性"><a href="#set无序性和不可重复性" class="headerlink" title="set无序性和不可重复性"></a>set无序性和不可重复性</h3><ol><li>什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li><li>什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</li></ol><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>Java中不需要为每一个new操作区写对应的free</p><h3 id="二-运行时数据区域"><a href="#二-运行时数据区域" class="headerlink" title="二 运行时数据区域"></a>二 运行时数据区域</h3><p>JDK 1.8:<br>[image:B3776FAA-F613-447E-8696-6C35A25D2294-6931-00008E8C37A6B67C/2019-3Java运行时数据区域JDK1.8.png]</p><p><em>线程私有的：</em></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>线程共享的：*</li><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p><em>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</em></p><h4 id="Java虚拟机栈（虚拟机中拘捕变量表部分）"><a href="#Java虚拟机栈（虚拟机中拘捕变量表部分）" class="headerlink" title="Java虚拟机栈（虚拟机中拘捕变量表部分）"></a>Java虚拟机栈（虚拟机中拘捕变量表部分）</h4><p><em>描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</em><br>实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。</p><p><em>局部变量表主要存放了编译期可知的各种数据类型</em>（boolean、byte、char、short、int、float、long、double）、<em>对象引用</em>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p>Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。<br>Java 方法有两种返回方式：</p><ol><li>return 语句。</li><li>抛出异常。<br>不管哪种返回方式都会导致栈帧被弹出。</li></ol><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java堆多有线程共享。<em>唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</em></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<em>GC 堆（Garbage Collected Heap）</em>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<em>进一步划分的目的是更好地回收内存，或者更快地分配内存。</em></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>#Javaguide# #笔记</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础知识&quot;&gt;&lt;a href=&quot;#Java基础知识&quot; class=&quot;headerlink&quot; title=&quot;Java基础知识&quot;&gt;&lt;/a&gt;Java基础知识&lt;/h1&gt;&lt;h2 id=&quot;java基本功&quot;&gt;&lt;a href=&quot;#java基本功&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
