<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yuwen Mi&#39;s Space</title>
  <icon>https://www.gravatar.com/avatar/376f6cb13e98ff675f5b604a199d7024</icon>
  <subtitle>👊👊👊👊</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-21T07:57:24.762Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yuwen Mi</name>
    <email>mywjyw@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图解HTTP学习笔记</title>
    <link href="http://yoursite.com/2020/12/17/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/12/17/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-17T07:52:13.000Z</published>
    <updated>2020-12-21T07:57:24.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-了解Web及网络基础"><a href="#第一章-了解Web及网络基础" class="headerlink" title="第一章 了解Web及网络基础"></a>第一章 了解Web及网络基础</h1><h2 id="与HTTP关系密切的协议：IP、TCP和DNS"><a href="#与HTTP关系密切的协议：IP、TCP和DNS" class="headerlink" title="与HTTP关系密切的协议：IP、TCP和DNS"></a>与HTTP关系密切的协议：IP、TCP和DNS</h2><h3 id="负责传输的IP协议"><a href="#负责传输的IP协议" class="headerlink" title="负责传输的IP协议"></a>负责传输的IP协议</h3><p>（Internet Protocol）网际协议位于网络层</p><p>作用：把各种数据包传送给对方，保证传送到对方那里：IP地址和MAC地址。</p><p>使用ARP协议凭借MAC地址进行通信，是一种用于解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p><h3 id="确保可靠性的TCP协议"><a href="#确保可靠性的TCP协议" class="headerlink" title="确保可靠性的TCP协议"></a>确保可靠性的TCP协议</h3><p>提供<strong>可靠</strong>的<strong>字节流</strong>服务。</p><h2 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h2><p>URI：统一资源标识符</p><p>URL：统一资源定位符</p><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>URI就是由某个协议方案（Http、ftp…）表示的资源的定位标识符</p><p>URI用字符串标识某一互联网资源，而URL表示自愿的地点。URL是URI的子集。</p><h1 id="第二章-简单的HTTP协议"><a href="#第二章-简单的HTTP协议" class="headerlink" title="第二章 简单的HTTP协议"></a>第二章 简单的HTTP协议</h1><p>请求报文包括：请求方法、请求URI、协议版本、可选的请求首部字段和内容实体。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/16/orHK4J3f8MVxOGs.png"></p><p>请求内容的处理结果以响应的行事返回</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/16/36qOXguk2WFzyET.png"></p><h3 id="HTTP是不保存状态的协议"><a href="#HTTP是不保存状态的协议" class="headerlink" title="HTTP是不保存状态的协议"></a>HTTP是不保存状态的协议</h3><p>HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，引入了Cookie技术。</p><h2 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h2><ol><li>GET：获取资源</li><li>POST：传输实体主体</li><li>PUT：传输文件</li><li>HEAD：获得报文首部</li><li>DELETE：删除文件</li><li>OPTIONS：询问支持的方法</li><li>TRACE：追踪路径</li><li>CONNECT：要求用隧道协议连接代理</li></ol><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>HTTP/1.1中 所有连接默认都是持久连接</p><h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>持久连接使得请求以管线化方式发送成为可能。不用发送一个请求后不用等待响应就可以直接发送下一请求。</p><h1 id="第三章-HTTP报文内的HTTP信息"><a href="#第三章-HTTP报文内的HTTP信息" class="headerlink" title="第三章 HTTP报文内的HTTP信息"></a>第三章 HTTP报文内的HTTP信息</h1><h2 id="请求报文和相应报文的结构"><a href="#请求报文和相应报文的结构" class="headerlink" title="请求报文和相应报文的结构"></a>请求报文和相应报文的结构</h2><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/16/WYKoRCGF7ShJI4E.png"></p><p>报文实例：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/16/iZ5Caq2HLdPukTY.png"></p><h2 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h2><p>遇到网络中断时，从之前下载中断处恢复下载。实现该功能需要指定下载的实体范围，用到首部字段Range。</p><h2 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h2><h1 id="第四章-返回结果的HTTP状态码"><a href="#第四章-返回结果的HTTP状态码" class="headerlink" title="第四章 返回结果的HTTP状态码"></a>第四章 返回结果的HTTP状态码</h1><h2 id="状态码告知从服务器端返回的请求结果"><a href="#状态码告知从服务器端返回的请求结果" class="headerlink" title="状态码告知从服务器端返回的请求结果"></a>状态码告知从服务器端返回的请求结果</h2><p>状态码类别</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/16/5gYSm3Lc8nVChHf.png"></p><h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul><li>200 OK 客户端发来的请求在服务器端被正常处理了</li><li>204 No Content 服务器接收请求已成功处理，但返回的响应报文中不含实体的主体部分。</li><li>206 Partial Content 表示客户端进行了范围（Range）请求</li></ul><h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul><li><p>301 Moved Permanly 请求的资源已被分配了新的URI。（会把书签更新为新的URI）</p></li><li><p>302 Found 资源已分配新的URI，希望用户能使用新的URI访问，但是是临时性质的。（不会更新书签）</p></li><li><p>303 See Other </p></li><li><p>304 Not Modified （和重定向没有关系）。该状态码表示客户端发送附带条件的请求，服务器允许请求访问资源，但未满足条件。</p></li><li><p>307 Temporary Redirect 临时重定向，会遵守不从POST变成GET</p></li></ul><h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul><li>400 Bad Request 请求报文中存在语法错误</li><li>401 Unauthorized 表示发送的请求需要有通过HTTP认证的认证信息。</li><li>403 Forbidden 对请求自愿的访问被服务器拒绝了</li><li>404 Not Found 服务器上无法找到请求的资源（可以在服务器端拒绝请求且不想说明理由时使用）</li></ul><h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul><li>500 Internal Server Error 服务端在执行请求时发生了错误</li><li>503 Service Unavailable 无夫妻暂时处于超负载或正在进行停机维护，无法处理请求</li></ul><h1 id="第五章-与HTTP协作的Web服务器"><a href="#第五章-与HTTP协作的Web服务器" class="headerlink" title="第五章 与HTTP协作的Web服务器"></a>第五章 与HTTP协作的Web服务器</h1><h2 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h2><p>不同的域名同时部署在同一个服务器上，使用DNS解析域名后得到的访问IP相同。</p><p>在相同IP地址下，必须在发送HTTP请求时在Host首部内完整指定主机名和域名的URI。</p><h2 id="通信数据转发程序：代理、网关、隧道"><a href="#通信数据转发程序：代理、网关、隧道" class="headerlink" title="通信数据转发程序：代理、网关、隧道"></a>通信数据转发程序：代理、网关、隧道</h2><ul><li>隧道：在相隔很远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。</li></ul><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><ul><li>缓存代理：代理转发响应时，缓存代理会预先将自愿的副本保存在代理服务器上。</li><li>透明代理：转发时不对报文做任何加工</li></ul><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>利用网关可以由HTTP请求转化为其他协议通信</p><p>可以提高通信安全性</p><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>确保客户端与服务器进行<strong>安全</strong>的通信</p><p>隧道本身不会解析HTTP请求（是透明的）</p><h2 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h2><h3 id="缓存的有效期限"><a href="#缓存的有效期限" class="headerlink" title="缓存的有效期限"></a>缓存的有效期限</h3><p>因为客户端的要求、缓存的有效期等因素，缓存服务器会向源服务器确认资源的有效性。若判断缓存失效，则会再次从源服务器上获取新资源。</p><h3 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h3><h1 id="第六章-HTTP首部"><a href="#第六章-HTTP首部" class="headerlink" title="第六章 HTTP首部"></a>第六章 HTTP首部</h1><h2 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h2><h3 id="4种首部字段类型"><a href="#4种首部字段类型" class="headerlink" title="4种首部字段类型"></a>4种首部字段类型</h3><ul><li>通用首部字段</li><li>请求首部字段</li><li>响应首部字段</li><li>实体首部字段：补充了资源内容更新时间等与实体有关的信息。</li></ul><h3 id="HTTP-1-1首部字段一览"><a href="#HTTP-1-1首部字段一览" class="headerlink" title="HTTP/1.1首部字段一览"></a>HTTP/1.1首部字段一览</h3><ul><li><p>通用首部字段</p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/19/8jF5dSwJPo4f7CN.png" style="zoom:50%;" /></li></ul><ul><li><p>请求首部字段</p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/19/58RgJPChfvTxmdB.png" style="zoom:50%;" /></li><li><p>响应首部字段</p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/19/kVabAZJuNyomD48.png" style="zoom:50%;" /></li><li><p>实体首部字段</p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/19/Dm8OHrJSZ6BpLN5.png" style="zoom:50%;" /></li></ul><h3 id="End-to-end首部和Hop-by-hop首部"><a href="#End-to-end首部和Hop-by-hop首部" class="headerlink" title="End-to-end首部和Hop-by-hop首部"></a>End-to-end首部和Hop-by-hop首部</h3><p>端到端首部（<strong>End-to-end  Header</strong>）分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必 须保存在由缓存生成的响应中，另外规定它必须被转发。</p><p>逐跳首部(<strong>Hop-by-hop Header</strong>) 分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再 转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提 供 Connection 首部字段。</p><p>除这 8 个首部字段之外， 其他所有字段都属于端到端首部。</p><ul><li>Conne ction</li><li>Keep-Alive </li><li>Proxy-Auth nticate </li><li>Proxy-Authorization</li><li>Trailer</li><li>TE</li><li>Transfer-Encoding</li><li>Upgrade</li></ul><h2 id="HTTP-1-1通用首部字段"><a href="#HTTP-1-1通用首部字段" class="headerlink" title="HTTP/1.1通用首部字段"></a>HTTP/1.1通用首部字段</h2><p>即请求和相应报文都会用到的首部</p><p>…</p><h1 id="第七章-确保Web安全的HTTPS"><a href="#第七章-确保Web安全的HTTPS" class="headerlink" title="第七章 确保Web安全的HTTPS"></a>第七章 确保Web安全的HTTPS</h1><h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><ul><li>通信使用明文，内容可能被窃听</li><li>不验证通信方的身份，可能遭遇伪装</li><li>无法证明报文完整性，可能已被篡改</li></ul><h3 id="使用明文可能会被窃听"><a href="#使用明文可能会被窃听" class="headerlink" title="使用明文可能会被窃听"></a>使用明文可能会被窃听</h3><ul><li><p>加密处理防止被窃听</p><p>HTTP协议中没有加密机制，可以通过和SSL或TLS组合使用加密通信内容。（建立安全通信线路）</p><p>与SSL组合使用的HTTP被称为HTTPS</p></li></ul><h3 id="不验证通信方身份就可能遭遇伪装"><a href="#不验证通信方身份就可能遭遇伪装" class="headerlink" title="不验证通信方身份就可能遭遇伪装"></a>不验证通信方身份就可能遭遇伪装</h3><p>HTTP协议中的请求和响应不会对通信方进行确认</p><ul><li><p>任何人都可以发起请求</p><p>HTTP协议不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下隐患</p><ul><li>无法确定请求发送至目标的Web服务器是否时返回响应的那台服务器，有可能是伪装的Web服务器。</li><li>伪装客户端同上</li><li>无法确定正在通信的对方是否具备访问权限</li><li>无法判定请求来自何方</li><li>即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击</li></ul></li><li><p>查明对方的证书</p><p>HTTP无法确定通信方，使用了SSL则可以。</p></li></ul><h3 id="无法证明报文完整性，可能已遭篡改"><a href="#无法证明报文完整性，可能已遭篡改" class="headerlink" title="无法证明报文完整性，可能已遭篡改"></a>无法证明报文完整性，可能已遭篡改</h3><p>如何防止篡改</p><p>虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便 捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法， 以及用来确认文件的数字签名方法。</p><p>可惜的是，用这些方法也依然无法百分百保证确认结果正确。因 为 PGP 和 MD5 本身被改写的话，用户是没有办法意识到的。</p><p>为了有效防止这些弊端，有必要使用 HTTPS。SSL 提供认证和加 密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的，因此 通过和其他协议组合使用来实现这个目标。下节我们介绍 HTTPS 的相关内容。</p><h2 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+加密+认证+完整性保护=HTTPS"></a>HTTP+加密+认证+完整性保护=HTTPS</h2><h3 id="HTTPS是身披SSL外壳的HTTP"><a href="#HTTPS是身披SSL外壳的HTTP" class="headerlink" title="HTTPS是身披SSL外壳的HTTP"></a>HTTPS是身披SSL外壳的HTTP</h3><p>通常HTTP直接和TCP通信，当使用SSL时则是先和SSL通信，再由SSL和TCP通信。</p><p>SSL独立于HTTP</p><h3 id="相互交换密钥的公开密钥加密技术"><a href="#相互交换密钥的公开密钥加密技术" class="headerlink" title="相互交换密钥的公开密钥加密技术"></a>相互交换密钥的公开密钥加密技术</h3><ul><li><p>共享密钥加密（对称加密）的困境</p><p>共享密钥需要发给对方，如何安全地转交？</p></li><li><p>使用两把密钥的公开密钥加密</p><p>使用一堆非对称的密钥，一把私有密钥。一把公开密钥</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/21/2SAWY9LKfkqvz5p.png"></p></li><li><p>HTTPS采用混合加密机制</p><p>在交换密钥环节使用非对称加密，通信交换报文阶段则使用对称加密</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/21/JgHMhP7xD4jmlIY.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-了解Web及网络基础&quot;&gt;&lt;a href=&quot;#第一章-了解Web及网络基础&quot; class=&quot;headerlink&quot; title=&quot;第一章 了解Web及网络基础&quot;&gt;&lt;/a&gt;第一章 了解Web及网络基础&lt;/h1&gt;&lt;h2 id=&quot;与HTTP关系密切的协议：IP、T</summary>
      
    
    
    
    <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计网" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
    <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>第一行代码学习笔记-Chapter3 UI开发</title>
    <link href="http://yoursite.com/2020/12/03/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Chapter3-UI%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2020/12/03/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Chapter3-UI%E5%BC%80%E5%8F%91/</id>
    <published>2020-12-03T04:05:58.000Z</published>
    <updated>2020-12-03T04:12:04.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter3-UI开发"><a href="#Chapter3-UI开发" class="headerlink" title="Chapter3 UI开发"></a>Chapter3 UI开发</h2><h3 id="4种基本布局"><a href="#4种基本布局" class="headerlink" title="4种基本布局"></a>4种基本布局</h3><h4 id="线性布局"><a href="#线性布局" class="headerlink" title="线性布局"></a>线性布局</h4><p><code>android:gravity</code> :用于指定文字在控件中的对齐方式</p><p><code>android:layout_gravity</code> :用于指定控件在布局中的对齐方式</p><p><code>android:layout_weight</code>:当明确该属性时，控件宽度由该值决定，不由</p><p><code>android:layout_width</code>决定</p><h4 id="相对布局"><a href="#相对布局" class="headerlink" title="相对布局"></a>相对布局</h4><h4 id="帧布局"><a href="#帧布局" class="headerlink" title="帧布局"></a>帧布局</h4><h4 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h4><p>LinearLayout本身已经支持按比例指定控件大小，因此百分比布局提供了PercentFrameLayout和PercentRelativeLayout作为帧布局和相对布局的扩展</p><h3 id="创建自定义控件"><a href="#创建自定义控件" class="headerlink" title="创建自定义控件"></a>创建自定义控件</h3><p><img src= "/img/loading.gif" data-lazy-src="http://qg9p3wo2k.hd-bkt.clouddn.com/img/20201203121023.png"></p><h4 id="引入布局"><a href="#引入布局" class="headerlink" title="引入布局"></a>引入布局</h4><p>在layout中引入模版布局（如自定义的标题栏）</p><p>在用到该模版的布局中直接include该模版</p><p><em>解决了重复编写布局代码的问题</em></p><h4 id="创建自定义控件-1"><a href="#创建自定义控件-1" class="headerlink" title="创建自定义控件"></a>创建自定义控件</h4><p><em>布局中有一些空间需要要求能够相应事件</em>（如自定义标题栏中的按钮需要相应对应的事件）</p><p>最显而易见的方式是在每一个活动中都重新注册一遍返回按钮的点击事件，但这无疑会增加很多重复代码，更好的方式是使用自定义控件。</p><p>新建Title继承自LinearLayout</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class TitleLayout extends LinearLayout &#123;</span><br><span class="line">    public TitleLayout(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.title, this);</span><br><span class="line"></span><br><span class="line">        Button titleBack &#x3D; (Button) findViewById(R.id.title_back);</span><br><span class="line">        Button titleEdit &#x3D; (Button) findViewById(R.id.title_edit);</span><br><span class="line"></span><br><span class="line">        titleBack.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                ((Activity) getContext()).finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        titleEdit.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                Toast.makeText(getContext(), &quot;Clicked Edit button&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义控件的构造函数中，需要借助<code>LayoutInflater</code>对标题栏布局进行动态加载<code>from()</code>方法构建出一个<code>LayoutInflater</code>对象，调用<code>inflate()</code>方法动态加载布局文件。该方法接受两个参数：第一个是要加载的布局文件的id，第二个参数是给加载好的布局再添加一个父布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.example.uicustomviews.TitleLayout</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><h4 id="ListView简单用法"><a href="#ListView简单用法" class="headerlink" title="ListView简单用法"></a>ListView简单用法</h4><p><strong>数据需要借助适配器Adapter来传递给ListView</strong>，最常用的有ArrayAdapter。</p><h4 id="定制ListView界面"><a href="#定制ListView界面" class="headerlink" title="定制ListView界面"></a>定制ListView界面</h4><p>自定义ListView的界面使其能展示除文本之外的内容。</p><p>需要为ListView的子项指定一个我们自定义的布局（即ListView中展示的每一项的布局）。</p><p>接下来需要创建一个自定义的适配器，来传入数据。</p><p><img src= "/img/loading.gif" data-lazy-src="http://qg9p3wo2k.hd-bkt.clouddn.com/img/20201203121152.png"></p><h4 id="提升ListView的运行效率"><a href="#提升ListView的运行效率" class="headerlink" title="提升ListView的运行效率"></a>提升ListView的运行效率</h4><ol><li><p>用getView()方法中的<code>converView</code>参数，用于将之前加载好的布局进行缓存</p></li><li><p>上述方法还需要每次调用<code>findViewById()</code>方法来获取控件的实例，借助一个自定义类<code>ViewHolder</code>来进行优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">    Fruit fruit = getItem(position); <span class="comment">// 获取当前项的Fruit实例</span></span><br><span class="line">    View view;</span><br><span class="line">    ViewHolder viewHolder;</span><br><span class="line">    <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        view = LayoutInflater.from(getContext()).inflate(resourceId, parent, <span class="keyword">false</span>);</span><br><span class="line">        viewHolder = <span class="keyword">new</span> ViewHolder();</span><br><span class="line">        viewHolder.fruitImage = (ImageView) view.findViewById (R.id.fruit_image);</span><br><span class="line">        viewHolder.fruitName = (TextView) view.findViewById (R.id.fruit_name);</span><br><span class="line">        view.setTag(viewHolder); <span class="comment">// 将ViewHolder存储在View中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        view = convertView;</span><br><span class="line">        viewHolder = (ViewHolder) view.getTag(); <span class="comment">// 重新获取ViewHolder</span></span><br><span class="line">    &#125;</span><br><span class="line">    viewHolder.fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">    viewHolder.fruitName.setText(fruit.getName());</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    ImageView fruitImage;</span><br><span class="line">   </span><br><span class="line">    TextView fruitName;</span><br><span class="line">   </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li></ol><h3 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h3><p>未完待续….</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Chapter3-UI开发&quot;&gt;&lt;a href=&quot;#Chapter3-UI开发&quot; class=&quot;headerlink&quot; title=&quot;Chapter3 UI开发&quot;&gt;&lt;/a&gt;Chapter3 UI开发&lt;/h2&gt;&lt;h3 id=&quot;4种基本布局&quot;&gt;&lt;a href=&quot;#4种基</summary>
      
    
    
    
    <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>美团、步步高一面面经</title>
    <link href="http://yoursite.com/2020/09/19/%E7%BE%8E%E5%9B%A2%E3%80%81%E6%AD%A5%E6%AD%A5%E9%AB%98%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2020/09/19/%E7%BE%8E%E5%9B%A2%E3%80%81%E6%AD%A5%E6%AD%A5%E9%AB%98%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2020-09-19T11:25:31.000Z</published>
    <updated>2020-09-19T11:26:12.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美团IOS一面凉经"><a href="#美团IOS一面凉经" class="headerlink" title="美团IOS一面凉经"></a>美团IOS一面凉经</h1><p>无IOS经验，女面试官，挺和蔼的，近1h</p><p>自我介绍</p><h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><ol><li>输入url的过程</li><li>TCP三次握手、四次挥手</li><li>TCP、UDP的区别，UDP的主要用途</li><li>HTTP建立连接（？</li><li>http和https的区别（具体怎么加密、客户端怎么才能信任服务器</li></ol><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol><li><p>进程、线程区别</p></li><li><p>进程间的通信方式</p></li><li><p>虚拟内存</p></li><li><p>堆和栈的区别</p></li><li><p>一个java文件（源码）是如何变成一个可执行文件的？</p></li><li><p>编译里的一些步骤（词法分析、语法分析…？</p></li><li><p>链接的过程都干了什么？</p></li><li><p>死锁</p></li><li><p>破坏死锁</p></li><li><p>你平时编程怎么保证线程安全</p></li><li><p>解释一下C里static</p></li><li><p>解释一下数组链表的区别</p></li><li><p>删除倒数第k个节点</p></li><li><p>常见的排序算法</p></li><li><p>哪种排序算法不稳定</p></li><li><p>解释一下满二叉树和完全二叉树</p></li></ol><p>做了半小时左右的题<br>编程题：一个2行n列的路，每个路有可能有障碍物，有障碍物则走不了，可以选择走三个方向：朝右、右上、右下，问从左上到右下的几种走法。<br>（动态规划，leetcode有类似的题）</p><h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><p>评价一下：每个都能说一点，但是每个都不深入🐶</p><p>希望能有二面吧，没有也躺平了🐶</p><h1 id="步步高安卓一面"><a href="#步步高安卓一面" class="headerlink" title="步步高安卓一面"></a>步步高安卓一面</h1><p>无安卓经验，男面试官，态度很好很nice   时长50min</p><p>自我介绍<br>排名<br>问了问了专业课程及分数</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ol><li>jdk和jre的区别</li><li>平时用什么IDE</li><li>int和long的范围</li><li>接口里可以实现方法吗？</li><li>ArrayList和LinkedList区别</li></ol><p><em>1</em> <em>是否保证线程安全：</em> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；<br><em>2</em> <em>底层数据结构：</em> Arraylist 底层使用的是 Object<em>数组</em>；LinkedList 底层使用的是 <em>双向链表</em> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）<br><em>3</em> <em>插入和删除是否受元素位置的影响：</em> ① ArrayList<em>采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</em> 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList<em>采用链表存储，所以对于</em>add(E e)<em>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置</em>i<em>插入和删除元素的话（</em>(add(int index, E element)<em>） 时间复杂度近似为</em>o(n))<em>因为需要先移动到指定位置再插入。</em><br><em>4</em> <em>是否支持快速随机访问：</em> LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。<br><em>5</em> <em>内存空间占用：</em> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p><ol start="6"><li>初始化一个ArrayList</li><li>ArrayList是否是线程安全的，还有哪些也是线程安全的容器</li><li>HashMap的底层结构</li><li>Java中的内部类和应用场景</li><li>Java中锁的机制</li><li>GC机制的原理</li><li>通过什么学的Java</li></ol><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><ol><li>strcpy和strncpy有什么区别</li><li>通过什么方式保证malloc和free配对</li></ol><h2 id="计网-1"><a href="#计网-1" class="headerlink" title="计网"></a>计网</h2><ol><li>TCP跟UDP区别、位于哪一层</li><li>http和https的区别</li><li>证书从哪获取</li><li>三次握手</li><li>http状态码</li></ol><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>#面经</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;美团IOS一面凉经&quot;&gt;&lt;a href=&quot;#美团IOS一面凉经&quot; class=&quot;headerlink&quot; title=&quot;美团IOS一面凉经&quot;&gt;&lt;/a&gt;美团IOS一面凉经&lt;/h1&gt;&lt;p&gt;无IOS经验，女面试官，挺和蔼的，近1h&lt;/p&gt;
&lt;p&gt;自我介绍&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    
    <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>在Mac上编辑uniquecv来制作简历</title>
    <link href="http://yoursite.com/2020/09/05/%E5%9C%A8Mac%E4%B8%8A%E7%BC%96%E8%BE%91uniquecv%E6%9D%A5%E5%88%B6%E4%BD%9C%E7%AE%80%E5%8E%86/"/>
    <id>http://yoursite.com/2020/09/05/%E5%9C%A8Mac%E4%B8%8A%E7%BC%96%E8%BE%91uniquecv%E6%9D%A5%E5%88%B6%E4%BD%9C%E7%AE%80%E5%8E%86/</id>
    <published>2020-09-05T12:24:47.000Z</published>
    <updated>2020-09-05T12:46:09.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Mac上编辑uniquecv"><a href="#在Mac上编辑uniquecv" class="headerlink" title="在Mac上编辑uniquecv"></a>在Mac上编辑uniquecv</h1><p>最近在准备秋招简历，用到了大🔥用了都说好的简历模版<a href="https://github.com/dyinnz/uniquecv">uniquecv</a>。<br>这个简历模版是使用LaTex编写的，因为之前没有用过LaTex，所以想要编辑这份简历模版还需要进行一下配置。</p><h2 id="安装MacTex"><a href="#安装MacTex" class="headerlink" title="安装MacTex"></a>安装MacTex</h2><p>因为我本人用的是<em>mac系统</em>，所以选择<a href="http://www.tug.org/mactex/downloading.html">MacTex</a>作为LaTex的编译器，为了省事直接下载了完整版，要是下载Basic版本的话可以还需要添加一些依赖包。</p><h2 id="安装Texpad"><a href="#安装Texpad" class="headerlink" title="安装Texpad"></a>安装Texpad</h2><p>选择Texpad作为编辑器，这个软件颜值还挺高的，就是后续可能需要收费。</p><h2 id="进行编辑"><a href="#进行编辑" class="headerlink" title="进行编辑"></a>进行编辑</h2><p>直接用Texpad打开从github上clone下来的<code>example.tex</code>。打开后还需要进行一些配置，选择左上角的第二个齿轮图标，在General菜单将Typeset Engine设置为XeLaTex。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/05/5ICmWEYp4w2oMtg.png" alt="1.png"></p><p>进行完上述设置后发现右侧预览栏中缺少应有的图标，并且报错提示缺少<code>FrontAwesome</code>，这部分我是从另一个GitHub仓库找到的这个文字库，链接为<a href="https://github.com/posquit0/Awesome-CV/blob/master/fonts/FontAwesome.ttf">Awesome-CV/FontAwesome.ttf at master · posquit0/Awesome-CV · GitHub</a>。<br>下载后直接双击就可以安装这个文字库了，再回到Texpad就可以发现图标也正常加载了。</p><p>（写简历的过程中越发觉得自己属实太菜了，希望爸爸们好赖给个面试机会吧QAQ）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在Mac上编辑uniquecv&quot;&gt;&lt;a href=&quot;#在Mac上编辑uniquecv&quot; class=&quot;headerlink&quot; title=&quot;在Mac上编辑uniquecv&quot;&gt;&lt;/a&gt;在Mac上编辑uniquecv&lt;/h1&gt;&lt;p&gt;最近在准备秋招简历，用到了大🔥用了</summary>
      
    
    
    
    <category term="随手记" scheme="http://yoursite.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>数据链路层知识总结</title>
    <link href="http://yoursite.com/2020/09/02/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/09/02/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2020-09-02T09:50:22.000Z</published>
    <updated>2020-09-05T12:42:30.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><h3 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1. 封装成帧"></a>1. 封装成帧</h3><p>网络层传下来的分组（IP数据报）添加首部和尾部<br>[image:8824282F-5A39-40B6-973E-565AED100D41-12860-00007824CFADBE21/29a14735-e154-4f60-9a04-c9628e5d09f4.png]</p><h3 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="2.透明传输"></a>2.透明传输</h3><p>透明表示一个实际存在的事物看起来好像不存在一样。<br><em>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定</em>。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><h3 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3.差错检测"></a>3.差错检测</h3><p>数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p><h2 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h2><h3 id="1-广播信道"><a href="#1-广播信道" class="headerlink" title="1. 广播信道"></a>1. 广播信道</h3><p>一对多通信。主要通过<em>信道复用技术</em>/<br><em>CSMA/CD 协议</em> 来进行协调，避免冲突发生</p><h3 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h3><p>一对一通信，使用PPP协议进行控制</p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><h3 id="1-频分复用"><a href="#1-频分复用" class="headerlink" title="1. 频分复用"></a>1. 频分复用</h3><p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。<br>[image:9D135E78-C4D6-487D-93E0-0AF4C153E372-12860-000078CD726B9793/4aa5e057-bc57-4719-ab57-c6fbc861c505.png]</p><h3 id="2-时分复用"><a href="#2-时分复用" class="headerlink" title="2. 时分复用"></a>2. 时分复用</h3><p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。<br>[image:12406E13-2282-43CD-A687-6206F176E9FE-12860-000078D4A1D4DD10/67582ade-d44a-46a6-8757-3c1296cc1ef9.png]<br>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p><h3 id="3-统计时分复用"><a href="#3-统计时分复用" class="headerlink" title="3. 统计时分复用"></a>3. 统计时分复用</h3><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。<br>[image:0D436811-C84A-4F47-88F1-0F07C926E774-12860-0000790CC5B34B3E/6283be2a-814a-4a10-84bf-9592533fe6bc.png]</p><h2 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h2><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><p>PPP 的帧格式：</p><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500<br>[image:F8118CE2-2ECC-4B95-8170-5276E0F0C817-12860-00007977325834E3/759013d7-61d8-4509-897a-d75af598a236.png]</li></ul><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。<br>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。<br>可以按照网络拓扑结构对局域网进行分类：<br>[image:3988CDE9-ABD8-4BD1-B03A-21FFC69A9A70-12860-00007A50F68F3B36/807f4258-dba8-4c54-9c3c-a707c7ccffa2.jpg]</p><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>星型拓扑结构的局域网。<br>早期使用集线器链接，作用于bit而不是帧。当bit到达接口时，集线器重新生成该bit从而扩大传输距离，之后再将该bit发送到其他接口</p><p>目前以太网使用交换机替代集线器，根据MAC地址进行存储转发。</p><p>以太网帧格式：</p><ul><li><em>类型</em> ：标记上层使用的协议；</li><li><em>数据</em> ：长度在 46-1500 之间，如果太小则需要填充；</li><li><em>FCS</em> ：帧检验序列，使用的是 CRC 检验方法；<br>[image:B4024AFD-ACFE-419A-8F7A-537BC36092F2-12860-00007A8186962804/164944d3-bbd2-4bb2-924b-e62199c51b90.png]</li></ul><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机可以通过交换表自学习，因此即插即用。<br>交换表中存储MAC地址到接口的映射</p><p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就<em>发送广播帧</em>，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。<br>[image:9C46EF97-DBC0-4F23-83AB-F82E320F28A8-12860-00007ADE0C6FA4E7/a4444545-0d68-4015-9a3d-19209dc436b3.png]</p><h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p><p>#计网</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据链路层&quot;&gt;&lt;a href=&quot;#数据链路层&quot; class=&quot;headerlink&quot; title=&quot;数据链路层&quot;&gt;&lt;/a&gt;数据链路层&lt;/h1&gt;&lt;h2 id=&quot;基本问题&quot;&gt;&lt;a href=&quot;#基本问题&quot; class=&quot;headerlink&quot; title=&quot;基本问题&quot;</summary>
      
    
    
    
    <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计网" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="http://yoursite.com/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</id>
    <published>2020-09-02T09:49:59.000Z</published>
    <updated>2020-09-05T12:40:58.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p><em>ISP</em>：互联网服务提供商<br>ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。<br>互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。<br>[image:C3A3DAED-8EAF-457B-9E45-8E13C6471931-12860-0000751531DFF8A5/3be42601-9d33-4d29-8358-a9d16453af93.png]</p><h2 id="主机间的通信方式"><a href="#主机间的通信方式" class="headerlink" title="主机间的通信方式"></a>主机间的通信方式</h2><ul><li>C/S</li><li>P2P</li></ul><h2 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h2><ol><li>电路交换在整个通信过程中始终占用链路</li><li>分组交换允许同一条传输线路上传输多个分组，使用到了存储转发过程</li></ol><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延<br>[image:BE0DED23-F2A7-4426-A054-3E16327EA9F8-12860-000076691F3C9AB3/4b2ae78c-e254-44df-9e37-578e2f2bef52.jpg]</p><ol><li>排队时延<br>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</li><li>处理时延<br>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</li><li>传输时延<br>主机或路由器传输数据帧所需要的时间。<br>delay = l(bit)/v(bit/s)</li><li>传播时延<br>电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。<br>delay=l(m)/v(m/s)</li></ol><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h3><ul><li><em>应用层</em><br>为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li><li><em>传输层</em><br>为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li><em>网络层</em><br>为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><em>数据链路层</em><br>网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><em>物理层</em><br>考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h3 id="数据在各层间的传递过程"><a href="#数据在各层间的传递过程" class="headerlink" title="数据在各层间的传递过程"></a>数据在各层间的传递过程</h3><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。<br>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。<br>#计网</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络概述&quot;&gt;&lt;a href=&quot;#计算机网络概述&quot; class=&quot;headerlink&quot; title=&quot;计算机网络概述&quot;&gt;&lt;/a&gt;计算机网络概述&lt;/h1&gt;&lt;h2 id=&quot;ISP&quot;&gt;&lt;a href=&quot;#ISP&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计网" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer Test31 Test68</title>
    <link href="http://yoursite.com/2020/09/02/%E5%89%91%E6%8C%87Offer-Test31-Test68-md/"/>
    <id>http://yoursite.com/2020/09/02/%E5%89%91%E6%8C%87Offer-Test31-Test68-md/</id>
    <published>2020-09-02T06:59:13.000Z</published>
    <updated>2020-09-03T01:14:06.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Test31"><a href="#Test31" class="headerlink" title="Test31"></a>Test31</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test31 给一个数组，返回它的最大连续子序列的和 </span><br><span class="line">例如:&#123;6,-3,-2,7,-15,1,2,2&#125;,连续子向量的最大和为8(从第0个开始,到第3个为止)。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">状态定义：dp[i]表示以array[i]结尾的连续子数组的最大和。所以最终要求dp[n]</span><br><span class="line">状态转移方程：dp[i] &#x3D; max(array[i], dp[i-1]+array[i])</span><br><span class="line">解释：如果当前元素为整数，并且dp[i-1]为负数，那么当然结果就是只选当前元素</span><br><span class="line">*&#x2F;</span><br><span class="line">import java.lang.Math;</span><br><span class="line"></span><br><span class="line">public class Test31 &#123;</span><br><span class="line">    public int FindGreatestSumOfSubArray(int[] array) &#123;</span><br><span class="line">        int[] dp &#x3D; new int[array.length];</span><br><span class="line">        dp[0] &#x3D; array[0];</span><br><span class="line">        int res &#x3D; array[0];</span><br><span class="line">        for (int i &#x3D; 1; i &lt; dp.length; i ++) &#123;</span><br><span class="line">            dp[i] &#x3D; Math.max(dp[i - 1] + array[i], array[i]);</span><br><span class="line">            res &#x3D; Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Test32"><a href="#Test32" class="headerlink" title="Test32"></a>Test32</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">未完成</span><br></pre></td></tr></table></figure><h1 id="Test33"><a href="#Test33" class="headerlink" title="Test33"></a>Test33</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test33 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</span><br><span class="line">    例如输入数组&#123;3，32，321&#125;，则打印出这三个数字能排成的最小数字为321323。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 遍历整个数组进行从小到大的排序，数组元素a、b间的比较通过比较ab和ba的大小 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test33 &#123;</span><br><span class="line">    public String PrintMinNumber(int [] numbers) &#123;</span><br><span class="line">        if (numbers &#x3D;&#x3D; null || numbers.length &#x3D;&#x3D; 0)</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numbers.length; i ++) &#123;</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; numbers.length; j ++) &#123;</span><br><span class="line">                int ab &#x3D; Integer.valueOf(numbers[i]+&quot;&quot;+numbers[j]);</span><br><span class="line">                int ba &#x3D; Integer.valueOf(numbers[j]+&quot;&quot;+numbers[i]);</span><br><span class="line">                if (ab &gt; ba) &#123;</span><br><span class="line">                    int tmp &#x3D; numbers[j];</span><br><span class="line">                    numbers[j] &#x3D; numbers[i];</span><br><span class="line">                    numbers[i] &#x3D; tmp; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numbers.length; i ++) &#123;</span><br><span class="line">            str &#x3D; str + numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test34"><a href="#Test34" class="headerlink" title="Test34"></a>Test34</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test34 把只包含质因子2、3和5的数称作丑数（Ugly Number）。</span><br><span class="line">例如6、8都是丑数，但14不是，因为它包含质因子7。 </span><br><span class="line">习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 只包含质因子2、3、5，所以丑数可以表示为2^x3^y5^z</span><br><span class="line">    所以可以把已得到的丑数乘以2、3、5来得到新的丑数。</span><br><span class="line">    维持三个指针来记录当前乘以2、乘以3、乘以5的最小值，</span><br><span class="line">    然后当其被选为新的最小值后，要把相应的指针+1； *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.lang.Math;</span><br><span class="line"></span><br><span class="line">public class Test34 &#123;</span><br><span class="line">    public int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">        if (index &lt;&#x3D; 0)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; p2指向的数*2是所有*2可以得到的数最小的</span><br><span class="line">        int p2 &#x3D; 0, p3 &#x3D; 0, p5 &#x3D; 0;</span><br><span class="line">        int[] res &#x3D; new int [index];</span><br><span class="line">        res[0] &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; index; i ++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到当前最小的丑数</span><br><span class="line">            res[i] &#x3D; Math.min(res[p2] * 2, Math.min(res[p3] * 3, res[p5] * 5));</span><br><span class="line">            &#x2F;&#x2F; 更新三个指针</span><br><span class="line">            if (res[i] &#x3D;&#x3D; res[p2] * 2) p2++;</span><br><span class="line">            if (res[i] &#x3D;&#x3D; res[p3] * 3) p3++;</span><br><span class="line">            if (res[i] &#x3D;&#x3D; res[p5] * 5) p5++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[index - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test35"><a href="#Test35" class="headerlink" title="Test35"></a>Test35</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test35 在一个字符串(0&lt;&#x3D;字符串长度&lt;&#x3D;10000，全部由字母组成)中找到第一个</span><br><span class="line">只出现一次的字符,并返回它的位置, 如果没有则返回 -1</span><br><span class="line">（需要区分大小写）.（从0开始计数） *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* hash法，创建一个数组，索引表示字符，对应的数据表示出现的次数 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test35 &#123;</span><br><span class="line">    public int FirstNotRepeatingChar(String str) &#123;</span><br><span class="line">        if (str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D; 0)</span><br><span class="line">            return -1;</span><br><span class="line"></span><br><span class="line">        int[] count &#x3D; new int[256]; &#x2F;&#x2F; 256 ASC码种类数</span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length(); i ++) &#123;</span><br><span class="line">            count[str.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 查找有没有只出现一次的</span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length(); i ++) &#123;</span><br><span class="line">            if (count[str.charAt(i)] &#x3D;&#x3D; 1)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test36"><a href="#Test36" class="headerlink" title="Test36"></a>Test36</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test36 在数组中的两个数字，如果前面一个数字大于后面的数字，</span><br><span class="line">则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。</span><br><span class="line">并将P对1000000007取模的结果输出。 即输出P%1000000007 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：固定一个元素，遍历之后的元素找逆序对 O(n2) *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*方法二：进行归并排序的同时统计逆序对的个数 *&#x2F;</span><br></pre></td></tr></table></figure><h1 id="Test37"><a href="#Test37" class="headerlink" title="Test37"></a>Test37</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test37 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，</span><br><span class="line">所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一 固定第一个链表，遍历第二个O(n2) *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test37 &#123;</span><br><span class="line">    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;</span><br><span class="line">        ListNode node1 &#x3D; pHead1;</span><br><span class="line">        ListNode node2;</span><br><span class="line"></span><br><span class="line">        while (node1 !&#x3D; null) &#123;</span><br><span class="line">            node2 &#x3D; pHead2;</span><br><span class="line">            while (node2 !&#x3D; null) &#123;</span><br><span class="line">                if (node2 &#x3D;&#x3D; node1)</span><br><span class="line">                    return node1;</span><br><span class="line">                node2 &#x3D; node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node1 &#x3D; node1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二 双指针法，两链表有公共节点，所以公共节点后的链表相同。</span><br><span class="line">    想办法让公共节点前的节点数相同。a+b&#x3D;b+a，让b+a作为新的链表A，a+b作为新的B</span><br><span class="line">    此时对两个新链表来说，目标公共节点在两新链表相同的位置 *&#x2F;</span><br><span class="line"></span><br><span class="line">    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;</span><br><span class="line">        if (pHead1 &#x3D;&#x3D; null || pHead2 &#x3D;&#x3D; null) return null;</span><br><span class="line">        ListNode node1 &#x3D; pHead1;</span><br><span class="line">        ListNode node2 &#x3D; pHead2;</span><br><span class="line"></span><br><span class="line">        while (node1 !&#x3D; node2) &#123;</span><br><span class="line">            node1 &#x3D; node1.next;</span><br><span class="line">            node2 &#x3D; node2.next;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 公共节点可能 为null，所以这里要判断一下</span><br><span class="line">            if (node1 !&#x3D; node2) &#123;</span><br><span class="line">                if (node1 &#x3D;&#x3D; null) node1 &#x3D; pHead2;</span><br><span class="line">                if (node2 &#x3D;&#x3D; null) node2 &#x3D; pHead1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return node1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Test38"><a href="#Test38" class="headerlink" title="Test38"></a>Test38</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test38 统计一个数字在非降序数组中出现的次数。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 有序的数组，所以采用二分法，找到开头的k和最后的k *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test38 &#123;</span><br><span class="line">    public int GetNumberOfK(int [] array , int k) &#123;</span><br><span class="line">       if (array.length &#x3D;&#x3D; 0)</span><br><span class="line">           return 0;</span><br><span class="line">       int firstK &#x3D; findFirstK(array, k, 0, array.length - 1);</span><br><span class="line">       int lastK &#x3D; findLastK(array, k, 0, array.length - 1);</span><br><span class="line">       int count &#x3D; 0;</span><br><span class="line">       if (firstK !&#x3D; -1 &amp;&amp; lastK !&#x3D; -1) &#123;</span><br><span class="line">           count &#x3D; lastK - firstK + 1;</span><br><span class="line">       &#125;</span><br><span class="line">       return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用递归实现二分查找第一个k</span><br><span class="line">    public int findFirstK(int [] array, int k, int start, int end) &#123;</span><br><span class="line">        if (start &gt; end)</span><br><span class="line">            return -1;</span><br><span class="line">        int mid &#x3D; (start + end) &gt;&gt; 1;</span><br><span class="line">        if (k &lt; array[mid]) &#123;</span><br><span class="line">            return findFirstK(array, k, start, mid - 1);</span><br><span class="line">        &#125; else if (k &gt; array[mid]) &#123;</span><br><span class="line">            return findFirstK(array, k, mid + 1, end);</span><br><span class="line">        &#125; else if (mid - 1 &gt;&#x3D; 0 &amp;&amp; array[mid - 1] &#x3D;&#x3D; k) &#123;</span><br><span class="line">            return findFirstK(array, k , start, mid - 1);</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; mid位置就是第一个k</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用循环实现二分查找最后一个k</span><br><span class="line">    public int findLastK(int [] array, int k, int start, int end) &#123;</span><br><span class="line">        int mid &#x3D; (start + end) &gt;&gt; 1;        </span><br><span class="line">        while (start &lt;&#x3D; end) &#123;</span><br><span class="line">            if (k &lt; array[mid]) &#123;</span><br><span class="line">                end &#x3D; mid - 1;</span><br><span class="line">            &#125; else if (k &gt; array[mid]) &#123;</span><br><span class="line">                start &#x3D; mid + 1;</span><br><span class="line">            &#125; else if (mid + 1 &lt; array.length &amp;&amp; array[mid + 1] &#x3D;&#x3D; k) &#123; &#x2F;&#x2F; 注意这里跟上一个函数的区别</span><br><span class="line">                start &#x3D; mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">            mid &#x3D; (start + end) &gt;&gt; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test39"><a href="#Test39" class="headerlink" title="Test39"></a>Test39</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test39 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点</span><br><span class="line">（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 递归，树深度&#x3D;左子树深度和右子树深度的较大值+1 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.lang.Math;</span><br><span class="line"></span><br><span class="line">public class Test39 &#123;</span><br><span class="line">    public int TreeDepth(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null)</span><br><span class="line">            return 0;</span><br><span class="line">        int leftDepth &#x3D; TreeDepth(root.left);</span><br><span class="line">        int rightDepth &#x3D; TreeDepth(root.right);</span><br><span class="line"></span><br><span class="line">        int depth &#x3D; Math.max(leftDepth, rightDepth) + 1;</span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test40"><a href="#Test40" class="headerlink" title="Test40"></a>Test40</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test40 输入一棵二叉树，判断该二叉树是否是平衡二叉树。</span><br><span class="line">在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 平衡二叉树的左右子树高度差不超过1，且左右子树也应为平衡二叉树；</span><br><span class="line">    在上一题实现了计算二叉树高度的函数，对其进行改进, 若不为平衡二叉树则返回-1 *&#x2F;</span><br><span class="line">import java.lang.Math;</span><br><span class="line"></span><br><span class="line">public class Test40 &#123;</span><br><span class="line"></span><br><span class="line">    public int depth(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null)</span><br><span class="line">            return 0;</span><br><span class="line">        int leftDepth &#x3D; depth(root.left);</span><br><span class="line">        if (leftDepth &#x3D;&#x3D; -1) &#x2F;&#x2F; 左子树不是平衡二叉树</span><br><span class="line">            return -1;</span><br><span class="line">        int rightDepth &#x3D; depth(root.right);</span><br><span class="line">        if (rightDepth &#x3D;&#x3D; -1)</span><br><span class="line">            return -1;</span><br><span class="line">        &#x2F;&#x2F; 判断当前树是否为平衡二叉树</span><br><span class="line">        int diff &#x3D; Math.abs(leftDepth - rightDepth);</span><br><span class="line">        if (diff &gt; 1) </span><br><span class="line">            return -1;</span><br><span class="line">        else &#123;</span><br><span class="line">            return 1 + Math.max(leftDepth, rightDepth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean IsBalanced_Solution(TreeNode root) &#123;</span><br><span class="line">        &#x2F;&#x2F; 非平衡二叉树depth返回-1</span><br><span class="line">        return depth(root) !&#x3D; -1;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="Test41"><a href="#Test41" class="headerlink" title="Test41"></a>Test41</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test41 一个整型数组里除了两个数字之外，其他的数字都出现了两次。</span><br><span class="line">请写程序找出这两个只出现一次的数字。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：用HashMap *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二：相同的数异或结果为0，所以该数组中所有元素异或后的结果</span><br><span class="line">    应为两个目标数异或的结果。根据异或结果可以知道两个目标数的哪一位</span><br><span class="line">    不相同（该位为1）。此时再根据这一位为0&#x2F;1将原数组分为两组，相同的数都在</span><br><span class="line">    同一组，两目标数在不同组。分别异或可以得到两个目标数 *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test41 &#123;</span><br><span class="line">    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123;</span><br><span class="line">        int xor &#x3D; 0; &#x2F;&#x2F; 所有数的异或结果</span><br><span class="line">        for (int i &#x3D; 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">            xor &#x3D; xor ^ array[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 找到两数不同的位</span><br><span class="line">        int index &#x3D; 1;</span><br><span class="line">        while ((index &amp; xor) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            index &#x3D; index &lt;&lt; 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 保存两类数组异或的结果</span><br><span class="line">        int res1 &#x3D; 0;</span><br><span class="line">        int res2 &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">            if ((index &amp; array[i]) &#x3D;&#x3D; 0)</span><br><span class="line">                res1 &#x3D; res1 ^ array[i];</span><br><span class="line">            else </span><br><span class="line">                res2 &#x3D; res2 ^ array[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        num1[0] &#x3D; res1;</span><br><span class="line">        num2[0] &#x3D; res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test42"><a href="#Test42" class="headerlink" title="Test42"></a>Test42</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test42 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,</span><br><span class="line">他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种</span><br><span class="line">连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:</span><br><span class="line">18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：算出从1到i之和sum[i]，则m到n之和为 sum[m]-sum[n] *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二：滑动窗口</span><br><span class="line">扩大窗口，j +&#x3D; 1</span><br><span class="line">缩小窗口，i +&#x3D; 1</span><br><span class="line">算法步骤：</span><br><span class="line">初始化，i&#x3D;1,j&#x3D;1, 表示窗口大小为0</span><br><span class="line">如果窗口中值的和小于目标值sum， 表示需要扩大窗口，j +&#x3D; 1</span><br><span class="line">否则，如果狂口值和大于目标值sum，表示需要缩小窗口，i +&#x3D; 1</span><br><span class="line">否则，等于目标值，存结果，缩小窗口，继续进行步骤2,3,4 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test42 &#123;</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll &#x3D; new ArrayList();</span><br><span class="line">        &#x2F;&#x2F; 初始化两个窗口</span><br><span class="line">        int i &#x3D; 1;</span><br><span class="line">        int j &#x3D; 2;</span><br><span class="line">        int sumCur &#x3D; i + j; &#x2F;&#x2F; 当前窗口所有数之和</span><br><span class="line"></span><br><span class="line">        while (i &lt;&#x3D; sum &#x2F; 2) &#123;</span><br><span class="line">            if (sumCur &lt; sum) &#123;</span><br><span class="line">                j ++;</span><br><span class="line">                sumCur +&#x3D; j;</span><br><span class="line">            &#125; else if (sumCur &gt; sum) &#123;</span><br><span class="line">                sumCur -&#x3D; i;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; 当前窗口值之和&#x3D;sum</span><br><span class="line">                ArrayList&lt;Integer&gt; list &#x3D; new ArrayList();</span><br><span class="line">                for (int m &#x3D; i; m &lt;&#x3D; j; m ++) &#123;</span><br><span class="line">                    list.add(m);</span><br><span class="line">                &#125;</span><br><span class="line">                listAll.add(list);</span><br><span class="line"></span><br><span class="line">                j ++;</span><br><span class="line">                sumCur +&#x3D; j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test43"><a href="#Test43" class="headerlink" title="Test43"></a>Test43</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test43 输入一个递增排序的数组和一个数字S，在数组中查找两个数，</span><br><span class="line">使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 双指针 分别指向首尾*&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 暴力 *&#x2F;</span><br><span class="line">public class Test43 &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList();</span><br><span class="line"></span><br><span class="line">        int sumCur &#x3D; 0;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int j &#x3D; 1;</span><br><span class="line">        for (i &#x3D; 0; i &lt; j; i ++) &#123;</span><br><span class="line">            for (j &#x3D; i + 1; j &lt; array.length; j ++) &#123;</span><br><span class="line">                sumCur &#x3D; array[i] + array[j];</span><br><span class="line">                if (sumCur &#x3D;&#x3D; sum) &#123;</span><br><span class="line">                    list.add(array[i]);</span><br><span class="line">                    list.add(array[j]);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sumCur &#x3D;&#x3D; sum) break;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 双指针分别指向首位 *&#x2F;</span><br><span class="line">    public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList();</span><br><span class="line">        if (array &#x3D;&#x3D; null  || array.length &#x3D;&#x3D; 0) </span><br><span class="line">            return list;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int j &#x3D; array.length - 1;</span><br><span class="line">        int sumCur &#x3D; array[i] + array[j];</span><br><span class="line"></span><br><span class="line">        while (array[i] &lt;&#x3D; sum &#x2F; 2) &#123;</span><br><span class="line">            if (sumCur &gt; sum) &#123;</span><br><span class="line">                j --;</span><br><span class="line">                sumCur &#x3D; array[i] + array[j];</span><br><span class="line">            &#125; else if (sumCur &lt; sum) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">                sumCur &#x3D; array[i] + array[j];                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                   list.add(array[i]);</span><br><span class="line">                   list.add(array[j]);</span><br><span class="line">                   break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Test44"><a href="#Test44" class="headerlink" title="Test44"></a>Test44</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test44 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，</span><br><span class="line">就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，</span><br><span class="line">请你把其循环左移K位后的序列输出。例如，字符序列S&#x3D;”abcXYZdef”,</span><br><span class="line">要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test44 &#123;</span><br><span class="line">    public String LeftRotateString(String str,int n) &#123;</span><br><span class="line">        if (str &#x3D;&#x3D; null || n &gt; str.length())</span><br><span class="line">            return str;</span><br><span class="line"></span><br><span class="line">        return str.substring(n) + str.substring(0, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test45"><a href="#Test45" class="headerlink" title="Test45"></a>Test45</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test45 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，</span><br><span class="line">写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，</span><br><span class="line">但却读不懂它的意思。例如，“student. a am I”。后来才意识到，</span><br><span class="line">这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。</span><br><span class="line">Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 先对整个字符串进行反转，在对反转后的每个单词进行反转 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test45 &#123;</span><br><span class="line">    public String ReverseSentence(String str) &#123;</span><br><span class="line">        if (str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D; 0)</span><br><span class="line">            return str;</span><br><span class="line"></span><br><span class="line">        char[] chars &#x3D; str.toCharArray();</span><br><span class="line">        &#x2F;&#x2F; 对原字符串进行翻转</span><br><span class="line">        reverse(chars, 0, chars.length - 1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 分别指向一个单词的最后一个字母和最后一个字母</span><br><span class="line">        int start &#x3D; 0;</span><br><span class="line">        int end &#x3D; 0;</span><br><span class="line">        while (start &lt; chars.length) &#123;</span><br><span class="line">            if (end &#x3D;&#x3D; chars.length || chars[end] &#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F; 遇到空格或最后说明当前start到end为一个单词</span><br><span class="line">                reverse(chars, start, end - 1);</span><br><span class="line">                start &#x3D; ++ end; &#x2F;&#x2F; 指向下一个单词</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                end ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reverse(char[] chars, int begin, int end) &#123;</span><br><span class="line">        while (begin &lt; end) &#123;</span><br><span class="line">            char tmp &#x3D; chars[end];</span><br><span class="line">            chars[end] &#x3D; chars[begin];</span><br><span class="line">            chars[begin] &#x3D; tmp;</span><br><span class="line">            begin ++;</span><br><span class="line">            end --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test46"><a href="#Test46" class="headerlink" title="Test46"></a>Test46</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test46 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,</span><br><span class="line">2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,</span><br><span class="line">看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,</span><br><span class="line">小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王</span><br><span class="line">可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”</span><br><span class="line">(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,</span><br><span class="line">要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， </span><br><span class="line">如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 输入数组需要满足以下几个条件：</span><br><span class="line">    1.数组长度为5</span><br><span class="line">    2.max-min&lt;5</span><br><span class="line">    3.数组元素除大小王外不重复</span><br><span class="line">    用TreeSet顺序保存元素 *&#x2F;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class Test46 &#123;</span><br><span class="line">    public boolean isContinuous(int [] numbers) &#123;</span><br><span class="line">        if (numbers.length !&#x3D; 5)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        int sum &#x3D; 0; &#x2F;&#x2F; 大小王个数</span><br><span class="line">        TreeSet&lt;Integer&gt; set &#x3D; new TreeSet();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; numbers.length; i ++) &#123;</span><br><span class="line">            if (numbers[i] &#x3D;&#x3D; 0)</span><br><span class="line">                sum++;</span><br><span class="line">            else </span><br><span class="line">                set.add(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (sum + set.size() !&#x3D; 5) </span><br><span class="line">            return false;</span><br><span class="line">        if (set.last() - set.first() &gt;&#x3D; 5)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test47"><a href="#Test47" class="headerlink" title="Test47"></a>Test47</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test47 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,</span><br><span class="line">今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,</span><br><span class="line">有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,</span><br><span class="line">让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,</span><br><span class="line">然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,</span><br><span class="line">继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,</span><br><span class="line">并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,</span><br><span class="line">哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</span><br><span class="line"></span><br><span class="line">如果没有小朋友，请返回-1 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：数学公式推导 *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二：用LinkedList模拟游戏过程 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class Test47 &#123;</span><br><span class="line">    public int LastRemaining_Solution(int n, int m) &#123;</span><br><span class="line">        if (n &#x3D;&#x3D; 0)</span><br><span class="line">            return -1;</span><br><span class="line">        LinkedList&lt;Integer&gt; list &#x3D; new LinkedList();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; list初始化小朋友编号</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i ++) &#123;</span><br><span class="line">             list.add(i);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        int del &#x3D; 0; &#x2F;&#x2F; 每次出队的小朋友</span><br><span class="line">        while (list.size() !&#x3D; 1) &#123;</span><br><span class="line">            del &#x3D; (del + m - 1) % list.size();</span><br><span class="line">            list.remove(del);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test48"><a href="#Test48" class="headerlink" title="Test48"></a>Test48</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test48 求1+2+3+...+n，要求不能使用乘除法、</span><br><span class="line">for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 求累加一般需要通过求和公式或者循环求和，但根据题目要求这两种都不能用，</span><br><span class="line">    所以需要用到递归,</span><br><span class="line">    很容易实现递归 当n&#x3D;1时返回n 其他情况返回n+sum(n-1)。但是考虑到不能用if语句，</span><br><span class="line">    所以需要用到短路求值，即&amp;&amp;语句，以a&amp;&amp;b为例，若a已经为0，则不会执行b*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test48 &#123;</span><br><span class="line">    public int Sum_Solution(int n) &#123;</span><br><span class="line">        boolean tmp;</span><br><span class="line">        tmp &#x3D; (n &gt; 1) &amp;&amp; ((n +&#x3D; Sum_Solution(n - 1)) &gt; 0);</span><br><span class="line">        return n; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Test49"><a href="#Test49" class="headerlink" title="Test49"></a>Test49</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test49 写一个函数，求两个整数之和，要求在函数体内</span><br><span class="line">不得使用+、-、*、&#x2F;四则运算符号。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 不能用加减乘除，所以肯定是用位操作，考虑到加法的过程，</span><br><span class="line">    x^y执行加法,(x&amp;y)&lt;&lt;1执行进位操作 ；</span><br><span class="line">    每次加法操作相当于进行位加法和进行操作，知道进位为0为止 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test49 &#123;</span><br><span class="line">    public int Add(int num1,int num2) &#123;</span><br><span class="line">        int res &#x3D; 0; &#x2F;&#x2F; 位加法结果</span><br><span class="line">        int carry &#x3D; 0; &#x2F;&#x2F; 进位结果</span><br><span class="line"></span><br><span class="line">        do &#123;</span><br><span class="line">            res &#x3D; num1 ^ num2;</span><br><span class="line">            carry &#x3D; (num1 &amp; num2) &lt;&lt; 1;</span><br><span class="line"></span><br><span class="line">            num1 &#x3D; res;</span><br><span class="line">            num2 &#x3D; carry;</span><br><span class="line">        &#125; while (carry !&#x3D; 0);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test50"><a href="#Test50" class="headerlink" title="Test50"></a>Test50</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test50 将一个字符串转换成一个整数，</span><br><span class="line">要求不能使用字符串转换整数的库函数。 </span><br><span class="line">数值为0或者字符串不是一个合法的数值则返回0 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test50 &#123;</span><br><span class="line">    public int StrToInt(String str) &#123;</span><br><span class="line">        if (str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D; 0)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        boolean negative &#x3D; false; &#x2F;&#x2F; 输入是否为负数</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        int limit &#x3D; Integer.MAX_VALUE; &#x2F;&#x2F; 允许的正数的最大值</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        int digit; &#x2F;&#x2F; 循环时的当前位</span><br><span class="line">        &#x2F;&#x2F; 进行正负判断</span><br><span class="line">        char signal &#x3D; str.charAt(0);</span><br><span class="line">        if (signal &lt; &#39;0&#39;) &#123; &#x2F;&#x2F; 为&#39;+&#39;&#x2F;&#39;-&#39;</span><br><span class="line">            if (signal &#x3D;&#x3D; &#39;-&#39;) &#123; &#x2F;&#x2F; 负数</span><br><span class="line">                negative &#x3D; true;</span><br><span class="line">                limit &#x3D; Integer.MIN_VALUE;</span><br><span class="line">            &#125; else if (signal !&#x3D; &#39;+&#39;) &#123; &#x2F;&#x2F; 不是合法的 数</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (str.length() &#x3D;&#x3D; 1)</span><br><span class="line">                return 0;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int multmin &#x3D; limit &#x2F; 10; </span><br><span class="line">        while (i &lt; str.length()) &#123;</span><br><span class="line">            digit &#x3D; str.charAt(i) - &#39;0&#39;;</span><br><span class="line">            if (digit &lt; 0 || digit &gt; 9)</span><br><span class="line">                return 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 对是否溢出进行判断</span><br><span class="line">            if (negative) &#123;</span><br><span class="line">                if (res &lt; multmin)</span><br><span class="line">                    return 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (res &gt; multmin)</span><br><span class="line">                    return 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res *&#x3D; 10;</span><br><span class="line"></span><br><span class="line">            if (negative) &#123;</span><br><span class="line">                if (res - digit &lt; limit)</span><br><span class="line">                    return 0;</span><br><span class="line">                res -&#x3D; digit;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (res + digit &gt; limit)</span><br><span class="line">                    return 0;</span><br><span class="line">                res +&#x3D; digit;</span><br><span class="line">            &#125;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test51"><a href="#Test51" class="headerlink" title="Test51"></a>Test51</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test51 在一个长度为n的数组里的所有数字都在0到n-1的范围内。</span><br><span class="line">数组中某些数字是重复的，但不知道有几个数字是重复的。</span><br><span class="line">也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</span><br><span class="line"> 例如，如果输入长度为7的数组&#123;2,3,1,0,2,5,3&#125;，</span><br><span class="line"> 那么对应的输出是第一个重复的数字2。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 用lenth长度的boolen表示数组中的各元素有没有重复出现 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test51 &#123;</span><br><span class="line">    public boolean duplicate(int numbers[],int length,int [] duplication) &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认初始化都为false</span><br><span class="line">        boolean[] status &#x3D; new boolean[length];</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i ++) &#123;</span><br><span class="line">            if (status[numbers[i]]) &#123;&#x2F;&#x2F; 重复遇见第i个元素</span><br><span class="line">                duplication[0] &#x3D; numbers[i];</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            status[numbers[i]] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test52"><a href="#Test52" class="headerlink" title="Test52"></a>Test52</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test52 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],</span><br><span class="line">其中B中的元素B[i]&#x3D;A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。</span><br><span class="line">不能使用除法。（注意：规定B[0] &#x3D; A[1] * A[2] * ... * A[n-1]，</span><br><span class="line">B[n-1] &#x3D; A[0] * A[1] * ... * A[n-2];）</span><br><span class="line">对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 下三角用连乘可以很容求得，上三角，从下向上也是连乘。</span><br><span class="line">因此我们的思路就很清晰了，先算下三角中的连乘，</span><br><span class="line">即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，</span><br><span class="line">把另一部分也乘进去。 *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test52 &#123;</span><br><span class="line">    public int[] multiply(int[] A) &#123;</span><br><span class="line">        int[] B &#x3D; new int[A.length];</span><br><span class="line"></span><br><span class="line">        if (A.length !&#x3D; 0) &#123;</span><br><span class="line">            B[0] &#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F; B的下三角部分</span><br><span class="line">            for (int i &#x3D; 1; i &lt; B.length; i ++) &#123;</span><br><span class="line">                B[i] &#x3D; B[i - 1] * A[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 计算B的上三角部分</span><br><span class="line">            int tmp &#x3D; 1;</span><br><span class="line">            for (int i &#x3D; B.length - 2; i &gt;&#x3D; 0; i --) &#123;</span><br><span class="line">                tmp *&#x3D; A[i + 1];</span><br><span class="line">                B[i] *&#x3D; tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return B;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test53"><a href="#Test53" class="headerlink" title="Test53"></a>Test53</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test53 请实现一个函数用来匹配包括&#39;.&#39;和&#39;*&#39;的正则表达式。模式中的字符&#39;.&#39;表示任意一个字符，</span><br><span class="line">而&#39;*&#39;表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。</span><br><span class="line">例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* </span><br><span class="line">当模式中的第二个字符是“*”时：</span><br><span class="line">如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：</span><br><span class="line">1、模式后移2字符，相当于x*被忽略；</span><br><span class="line">2、字符串后移1字符，模式后移2字符；</span><br><span class="line">3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；</span><br><span class="line"></span><br><span class="line">当模式中的第二个字符不是“*”时：</span><br><span class="line">1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。</span><br><span class="line">2、如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test53 &#123;</span><br><span class="line">    public boolean match(char[] str, char[] pattern) &#123;</span><br><span class="line">        if (str &#x3D;&#x3D; null || pattern &#x3D;&#x3D; null)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        return match(str, 0, pattern, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean match(char[] str, int strIndex, char[] pattern, int patternIndex) &#123;</span><br><span class="line">        &#x2F;&#x2F; 同时到达末尾则匹配成功</span><br><span class="line">        if (strIndex &#x3D;&#x3D; str.length &amp;&amp; patternIndex &#x3D;&#x3D; pattern.length) </span><br><span class="line">            return true;</span><br><span class="line">        if (strIndex !&#x3D; str.length &amp;&amp; patternIndex &#x3D;&#x3D; pattern.length)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 当前pattern的第二个字符是 *</span><br><span class="line">        if (patternIndex + 1 &lt; pattern.length &amp;&amp; pattern[patternIndex + 1] &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 第一个字符相同</span><br><span class="line">            if (strIndex !&#x3D; str.length &amp;&amp; (str[strIndex] &#x3D;&#x3D; pattern[patternIndex] || pattern[patternIndex] &#x3D;&#x3D; &#39;.&#39;)) &#123;</span><br><span class="line">                return match(str, strIndex, pattern, patternIndex + 2) &#x2F;&#x2F; *不匹配字符</span><br><span class="line">                    || match(str, strIndex + 1, pattern, patternIndex + 2) &#x2F;&#x2F; *匹配1个字符</span><br><span class="line">                    || match(str, strIndex + 1, pattern, patternIndex); &#x2F;&#x2F; *匹配后继续匹配str中的下一个</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; 第一个字符不相同</span><br><span class="line">                return match(str, strIndex, pattern, patternIndex + 2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 当前pattern第二个字符不是 *,且str第一个字符和pattern第一个 字符匹配，都后移一位</span><br><span class="line">        if (strIndex !&#x3D; str.length &amp;&amp; (str[strIndex] &#x3D;&#x3D; pattern[patternIndex] || pattern[patternIndex] &#x3D;&#x3D; &#39;.&#39;)) &#123;</span><br><span class="line">            return match(str, strIndex + 1, pattern, patternIndex + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test54"><a href="#Test54" class="headerlink" title="Test54"></a>Test54</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test54 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</span><br><span class="line">例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-16&quot;都表示数值。</span><br><span class="line"> 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：正则表达式 *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二：明确几个约束条件</span><br><span class="line"></span><br><span class="line">+-号后面必定为数字或后面为.（-.123 &#x3D; -0.123）</span><br><span class="line">+-号只出现在第一位或在eE的后一位</span><br><span class="line">.后面必定为数字或为最后一位（233. &#x3D; 233.0）</span><br><span class="line">eE后面必定为数字或+-号</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test54 &#123;</span><br><span class="line">    public boolean isNumeric(char[] str) &#123;</span><br><span class="line">        if (str.length &#x3D;&#x3D; 0)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        boolean point &#x3D; false, exp &#x3D; false; &#x2F;&#x2F; 是否已出现小数点&#x2F;指数</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length; i ++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 符号为+&#x2F;-</span><br><span class="line">            if (str[i] &#x3D;&#x3D; &#39;+&#39; || str[i] &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; + -后必须为数字或.</span><br><span class="line">                if (i + 1 &#x3D;&#x3D; str.length || !(str[i + 1] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[i + 1] &lt;&#x3D; &#39;9&#39; || str[i + 1] &#x3D;&#x3D; &#39;.&#39;))</span><br><span class="line">                    return false;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; +- 号只能出现在第一位或eE的下一位</span><br><span class="line">                if (i !&#x3D; 0 &amp;&amp; str[i - 1] !&#x3D; &#39;e&#39; &amp;&amp; str[i - 1] !&#x3D; &#39;E&#39;)</span><br><span class="line">                    return false;</span><br><span class="line">            &#125; else if (str[i] &#x3D;&#x3D; &#39;.&#39;) &#123; &#x2F;&#x2F; 符号为.</span><br><span class="line">                &#x2F;&#x2F; 不能出现在e后，有下一位且下一位不是数字则错</span><br><span class="line">                if (point || exp || !(i + 1 &lt; str.length &amp;&amp; str[i+1] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[i+1] &lt;&#x3D;&#39;9&#39;)) </span><br><span class="line">                    return false;</span><br><span class="line">                point &#x3D; true;</span><br><span class="line">            &#125; else if (str[i] &#x3D;&#x3D; &#39;e&#39; || str[i] &#x3D;&#x3D; &#39;E&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; 之前有过e&#x2F;e是最后一位&#x2F;下一位不是数字或+ -   则报错</span><br><span class="line">                if (exp || i + 1 &#x3D;&#x3D; str.length || !(str[i+1] &gt;&#x3D; &#39;0&#39; &amp;&amp; str[i+1] &lt;&#x3D; &#39;9&#39; || str[i+1] &#x3D;&#x3D; &#39;+&#39; || str[i+1] &#x3D;&#x3D; &#39;-&#39;))</span><br><span class="line">                    return false;</span><br><span class="line">                exp &#x3D; true;</span><br><span class="line">            &#125; else if (str[i] &gt;&#x3D;  &#39;0&#39; &amp;&amp; str[i] &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; else </span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test55"><a href="#Test55" class="headerlink" title="Test55"></a>Test55</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*Test55 请实现一个函数用来找出字符流中第一个只出现一次的字符。</span><br><span class="line">例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。</span><br><span class="line">当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Test55 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 储存字符流的字符及其出现的次数 </span><br><span class="line">    HashMap&lt;Character, Integer&gt; map &#x3D; new HashMap(); </span><br><span class="line">    &#x2F;&#x2F; 储存字符流的字符</span><br><span class="line">    LinkedList&lt;Character&gt; list &#x3D; new LinkedList();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Insert one char from stringstream</span><br><span class="line">    public void Insert(char ch)  &#123;</span><br><span class="line">        if (map.containsKey(ch)) &#123;</span><br><span class="line">            map.put(ch, map.get(ch) + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.put(ch, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(ch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F;return the first appearence once char in current stringstream</span><br><span class="line">    public char FirstAppearingOnce()  &#123;</span><br><span class="line">        for(char ch : list) &#123;</span><br><span class="line">            if (map.get(ch) &#x3D;&#x3D; 1)</span><br><span class="line">                return ch;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#39;#&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test56"><a href="#Test56" class="headerlink" title="Test56"></a>Test56</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*  Test56 给一个链表，若其中包含环，</span><br><span class="line">请找出该链表的环的入口结点，否则，输出null。*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 1.判断链表中有环 -&gt; 2.得到环中节点的数目 -&gt; 3.找到环中的入口节点 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test56 &#123;</span><br><span class="line">    public ListNode EntryNodeOfLoop(ListNode pHead) &#123;</span><br><span class="line">        if (pHead &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        ListNode l &#x3D; pHead, r &#x3D; pHead; &#x2F;&#x2F; 快慢指针</span><br><span class="line">        boolean ring &#x3D; false;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断链表中是否存在环</span><br><span class="line">        while (r !&#x3D; null &amp;&amp; r.next !&#x3D; null) &#123;</span><br><span class="line">            l &#x3D; l.next;</span><br><span class="line">            r &#x3D; r.next.next;</span><br><span class="line">            if (l &#x3D;&#x3D; r) &#123;</span><br><span class="line">                ring &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!ring)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        int n &#x3D; 1; &#x2F;&#x2F; 环中节点个数 </span><br><span class="line">        r &#x3D; r.next;</span><br><span class="line">        while (r !&#x3D; l) &#123;</span><br><span class="line">            r &#x3D; r.next;</span><br><span class="line">            n ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 在得知环节点个数后，先让快指针走n个节点；</span><br><span class="line">        &#x2F;&#x2F; 再快慢指针一起走，因为环有n个节点。所以两指针会在入口处相遇</span><br><span class="line">        l &#x3D; pHead;</span><br><span class="line">        r &#x3D; pHead;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i ++) &#123;</span><br><span class="line">            r &#x3D; r.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (r !&#x3D; l) &#123;</span><br><span class="line">            l &#x3D; l.next;</span><br><span class="line">            r &#x3D; r.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test57"><a href="#Test57" class="headerlink" title="Test57"></a>Test57</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test57 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，</span><br><span class="line">重复的结点不保留，返回链表头指针。 </span><br><span class="line">例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 新增一个节点head，便于处理第一个节点就重复的情况</span><br><span class="line"></span><br><span class="line">指针l指向当前最后一个只出现一次的节点，指针r为工作节点，向后移动 *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 这题需要在好好看看 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test57 &#123;</span><br><span class="line">    public ListNode deleteDuplication(ListNode pHead) &#123;</span><br><span class="line">        if (pHead &#x3D;&#x3D; null || pHead.next &#x3D;&#x3D; null) </span><br><span class="line">            return pHead;</span><br><span class="line">        &#x2F;&#x2F; 换表头</span><br><span class="line">        ListNode head &#x3D; new ListNode(0);</span><br><span class="line">        ListNode l &#x3D; head, r &#x3D; pHead;</span><br><span class="line">        head.next &#x3D; pHead;</span><br><span class="line"></span><br><span class="line">        while (r !&#x3D; null) &#123;</span><br><span class="line">            if (r.next !&#x3D; null &amp;&amp; r.val &#x3D;&#x3D; r.next.val) &#123;</span><br><span class="line">                while (r.next !&#x3D; null &amp;&amp; r.val &#x3D;&#x3D; r.next.val) &#123;</span><br><span class="line">                    r &#x3D; r.next;</span><br><span class="line">                &#125;</span><br><span class="line">                l.next &#x3D; r.next;</span><br><span class="line">                r &#x3D; r.next;</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; r指向的节点只出现一次</span><br><span class="line">                l &#x3D; l.next;</span><br><span class="line">                r &#x3D; r.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Test58"><a href="#Test58" class="headerlink" title="Test58"></a>Test58</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test58 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。</span><br><span class="line">注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 中序遍历的下一个节点可以分为如下几种情况：</span><br><span class="line">    1.当前有点有右子树，则遍历的下一个节点为其右子树的最左侧树节点</span><br><span class="line">    2.当前节点没有右子树时，若当前节点是其父节点的左孩子，则下一个节点为父节点</span><br><span class="line">                       否则为父节点的父节点...知道当前节点作为左子树 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test58 &#123;</span><br><span class="line">    public TreeLinkNode GetNext(TreeLinkNode pNode) &#123;</span><br><span class="line">        if (pNode &#x3D;&#x3D; null) </span><br><span class="line">            return null;</span><br><span class="line">        TreeLinkNode tmp &#x3D; new TreeLinkNode(0);</span><br><span class="line">        if (pNode.right !&#x3D; null) &#123;</span><br><span class="line">            tmp &#x3D; pNode.right;</span><br><span class="line">            while (tmp.left !&#x3D; null)</span><br><span class="line">                tmp &#x3D; tmp.left;</span><br><span class="line">            return tmp;</span><br><span class="line">        &#125; </span><br><span class="line">        tmp &#x3D; pNode.next;</span><br><span class="line">        while (tmp !&#x3D; null) &#123;</span><br><span class="line">            if (pNode &#x3D;&#x3D; tmp.left)</span><br><span class="line">                return tmp;</span><br><span class="line">            tmp &#x3D; tmp.next;</span><br><span class="line">            pNode &#x3D; pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test59"><a href="#Test59" class="headerlink" title="Test59"></a>Test59</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test59 请实现一个函数，用来判断一棵二叉树是不是对称的。</span><br><span class="line">注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 对称二叉树的左右子树相同，首先是根节点及其左右子树。</span><br><span class="line">    然后左子树的根节点和右子树的根节点相同，左子树的左子树和右子树的右子树同理 </span><br><span class="line">    采用递归法 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test59 &#123;</span><br><span class="line">    boolean isSymmetrical(TreeNode pRoot) &#123;</span><br><span class="line">        if (pRoot &#x3D;&#x3D; null)</span><br><span class="line">            return true;</span><br><span class="line">        return isSymmetricalHelper(pRoot.left, pRoot.right); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean isSymmetricalHelper(TreeNode leftRoot, TreeNode rightRoot) &#123;</span><br><span class="line">        if (leftRoot &#x3D;&#x3D; null)</span><br><span class="line">            return rightRoot &#x3D;&#x3D; null;</span><br><span class="line">        else if(rightRoot &#x3D;&#x3D; null)</span><br><span class="line">            return false;</span><br><span class="line">        if (leftRoot.val !&#x3D; rightRoot.val)</span><br><span class="line">            return false;</span><br><span class="line">        return isSymmetricalHelper(leftRoot.left, rightRoot.right)</span><br><span class="line">            &amp;&amp; isSymmetricalHelper(leftRoot.right, rightRoot.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test60"><a href="#Test60" class="headerlink" title="Test60"></a>Test60</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test60 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，</span><br><span class="line">第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 两个栈，分别存奇数层和偶数层 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test60 &#123;</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack1 &#x3D; new Stack();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack2 &#x3D; new Stack();</span><br><span class="line">        if (pRoot !&#x3D; null) </span><br><span class="line">            stack1.push(pRoot);</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list &#x3D; new ArrayList();</span><br><span class="line"></span><br><span class="line">        while(!stack1.empty() || !stack2.empty()) &#123;</span><br><span class="line">            if (!stack1.empty()) &#123; &#x2F;&#x2F; 将偶数层放入栈2</span><br><span class="line">                ArrayList&lt;Integer&gt; tmp &#x3D; new ArrayList();</span><br><span class="line">                int size &#x3D; stack1.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size; i ++) &#123; &#x2F;&#x2F; 这里不能直接用stack1.size，因为pop会改变其值</span><br><span class="line">                    TreeNode top &#x3D; stack1.pop();</span><br><span class="line">                    tmp.add(top.val);</span><br><span class="line">                    if (top.left !&#x3D; null)</span><br><span class="line">                        stack2.push(top.left);</span><br><span class="line">                    if (top.right !&#x3D; null)</span><br><span class="line">                        stack2.push(top.right);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(tmp);</span><br><span class="line">            &#125;    </span><br><span class="line">            if (!stack2.empty()) &#123; &#x2F;&#x2F; 根据栈2的节点，将下一层放入stack1中</span><br><span class="line">                ArrayList&lt;Integer&gt; tmp &#x3D; new ArrayList();</span><br><span class="line">                int size &#x3D; stack2.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                    TreeNode top &#x3D; stack2.pop();</span><br><span class="line">                    tmp.add(top.val);</span><br><span class="line">                    if (top.right !&#x3D; null)</span><br><span class="line">                        stack1.push(top.right);</span><br><span class="line">                    if (top.left !&#x3D; null)</span><br><span class="line">                        stack1.push(top.left);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(tmp);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test61"><a href="#Test61" class="headerlink" title="Test61"></a>Test61</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test61 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。*&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Queue;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class Test61 &#123;</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; </span><br><span class="line">        Queue&lt;TreeNode&gt; q1 &#x3D; new LinkedList();</span><br><span class="line">        Queue&lt;TreeNode&gt; q2 &#x3D; new LinkedList();</span><br><span class="line">        if (pRoot !&#x3D; null) </span><br><span class="line">            q1.add(pRoot);</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list &#x3D; new ArrayList();</span><br><span class="line"></span><br><span class="line">        while(!q1.isEmpty() || !q2.isEmpty()) &#123;</span><br><span class="line">            if (!q1.isEmpty()) &#123; &#x2F;&#x2F; 将偶数层放入q2</span><br><span class="line">                ArrayList&lt;Integer&gt; tmp &#x3D; new ArrayList();</span><br><span class="line">                int size &#x3D; q1.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size; i ++) &#123; &#x2F;&#x2F; 这里不能直接用stack1.size，因为pop会改变其值</span><br><span class="line">                    TreeNode top &#x3D; q1.remove();</span><br><span class="line">                    tmp.add(top.val);</span><br><span class="line">                    if (top.left !&#x3D; null)</span><br><span class="line">                        q2.add(top.left);</span><br><span class="line">                    if (top.right !&#x3D; null)</span><br><span class="line">                        q2.add(top.right);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(tmp);</span><br><span class="line">            &#125;    </span><br><span class="line">            if (!q2.isEmpty()) &#123; &#x2F;&#x2F; 根据栈2的节点，将下一层放入stack1中</span><br><span class="line">                ArrayList&lt;Integer&gt; tmp &#x3D; new ArrayList();</span><br><span class="line">                int size &#x3D; q2.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                    TreeNode top &#x3D; q2.remove();</span><br><span class="line">                    tmp.add(top.val);</span><br><span class="line">                    if (top.left !&#x3D; null)</span><br><span class="line">                        q1.add(top.left);</span><br><span class="line">                    if (top.right !&#x3D; null)</span><br><span class="line">                        q1.add(top.right);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                list.add(tmp);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test62"><a href="#Test62" class="headerlink" title="Test62"></a>Test62</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test62 请实现两个函数，分别用来序列化和反序列化二叉树</span><br><span class="line">二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，</span><br><span class="line">从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序</span><br><span class="line">的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），</span><br><span class="line">以 ！ 表示一个结点值的结束（value!）。</span><br><span class="line">二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</span><br><span class="line">例如，我们可以把一个只有根节点为1的二叉树序列化为&quot;1,&quot;，然后通过自己的函数来解析回这个二叉树 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 层序遍历 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Queue;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class Test62 &#123;</span><br><span class="line">    String Serialize(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q &#x3D; new LinkedList();</span><br><span class="line">        StringBuilder str &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">        if (root !&#x3D; null) </span><br><span class="line">            q.add(root);</span><br><span class="line"></span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode tmp &#x3D; q.poll();</span><br><span class="line">            if (tmp !&#x3D; null) &#123; &#x2F;&#x2F; 节点为null</span><br><span class="line">                str.append(tmp.val + &quot;!&quot;);</span><br><span class="line">                q.add(tmp.left);</span><br><span class="line">                q.add(tmp.right);</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; 不为null插入 #</span><br><span class="line">                str.append(&quot;#&quot; + &quot;!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        if (str.length() !&#x3D; 0) &#x2F;&#x2F; 删掉最后一个null后的！</span><br><span class="line">            str.deleteCharAt(str.length() - 1); </span><br><span class="line">        return str.toString();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">    TreeNode Deserialize(String str) &#123;</span><br><span class="line">        TreeNode root &#x3D; null;</span><br><span class="line">           if (str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D; 0)</span><br><span class="line">               return root;</span><br><span class="line">        String[] vals &#x3D; str.split(&quot;!&quot;); &#x2F;&#x2F; 按！分割得到每个节点的值</span><br><span class="line">        TreeNode[] nodes &#x3D; new TreeNode[vals.length];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 根据str构造 所有节点</span><br><span class="line">        for (int i &#x3D; 0; i &lt; vals.length; i ++) &#123;</span><br><span class="line">            if (!vals[i].equals(&quot;#&quot;))</span><br><span class="line">                nodes[i] &#x3D; new TreeNode(Integer.valueOf(vals[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 按照层序链接节点</span><br><span class="line">        root &#x3D; nodes[0];</span><br><span class="line">        for (int i &#x3D; 0, j &#x3D; 1; i &lt; nodes.length; i ++) &#123;</span><br><span class="line">            if (nodes[i] !&#x3D; null) &#123;</span><br><span class="line">                nodes[i].left &#x3D; nodes[j ++];</span><br><span class="line">                nodes[i].right &#x3D; nodes[j ++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test63"><a href="#Test63" class="headerlink" title="Test63"></a>Test63</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test63 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， </span><br><span class="line">（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 按中序遍历二叉搜索树得到递增的序列 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Test63 &#123;</span><br><span class="line">    TreeNode KthNode(TreeNode pRoot, int k) &#123;</span><br><span class="line">        if (pRoot &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack();</span><br><span class="line">        TreeNode tmp &#x3D; pRoot;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        while (tmp !&#x3D; null || !stack.empty()) &#123;</span><br><span class="line">            if (tmp !&#x3D; null)&#123;</span><br><span class="line">                stack.push(tmp);</span><br><span class="line">                tmp &#x3D; tmp.left;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                tmp &#x3D; stack.pop();</span><br><span class="line">                if(++ i &#x3D;&#x3D; k)</span><br><span class="line">                    return tmp;</span><br><span class="line">                tmp &#x3D; tmp.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test64"><a href="#Test64" class="headerlink" title="Test64"></a>Test64</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test64 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，</span><br><span class="line">那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，</span><br><span class="line">那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，</span><br><span class="line">使用GetMedian()方法获取当前读取数据的中位数。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 用两个PriorityQueue分别作为大顶堆和小顶堆 </span><br><span class="line">https:&#x2F;&#x2F;www.nowcoder.com&#x2F;questionTerminal&#x2F;9be0172896bd43948f8a32fb954e1be1?f&#x3D;discussion*&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">public class Test64 &#123;</span><br><span class="line">    &#x2F;&#x2F; 默认PriorityQueue为小顶堆</span><br><span class="line">    private PriorityQueue&lt;Integer&gt; minHeap &#x3D; new PriorityQueue&lt;Integer&gt;();</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;大顶堆</span><br><span class="line">    private PriorityQueue&lt;Integer&gt; maxHeap &#x3D; new PriorityQueue&lt;Integer&gt;(15, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            return o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    int count &#x3D; 0; &#x2F;&#x2F; 当前数字流中数字个数</span><br><span class="line">    &#x2F;&#x2F;每次插入小顶堆的是当前大顶堆中最大的数</span><br><span class="line">    &#x2F;&#x2F;每次插入大顶堆的是当前小顶堆中最小的数</span><br><span class="line">    &#x2F;&#x2F;这样保证小顶堆中的数永远大于等于大顶堆中的数</span><br><span class="line">    &#x2F;&#x2F;中位数就可以方便地从两者的根结点中获取了</span><br><span class="line"></span><br><span class="line">    public void Insert(Integer num) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当前数字个数为偶数，则先插入大顶堆，再把大顶堆中最大的数字插入到小顶堆</span><br><span class="line">        if (count % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">            int max &#x3D; maxHeap.poll();</span><br><span class="line">            minHeap.offer(max);</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 为奇数时则先插入小顶堆，再把小顶堆中最小的数字插入大顶堆</span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">            int min &#x3D; minHeap.poll();</span><br><span class="line">            maxHeap.offer(min);</span><br><span class="line">        &#125;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double GetMedian() &#123;</span><br><span class="line">        if (count % 2 &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 当前数字流中数字有偶数个，返回大、小顶堆头平均值</span><br><span class="line">            return new Double(minHeap.peek() + maxHeap.peek()) &#x2F; 2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new Double(minHeap.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test65"><a href="#Test65" class="headerlink" title="Test65"></a>Test65</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test65 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。</span><br><span class="line">例如，如果输入数组&#123;2,3,4,2,6,2,5,1&#125;及滑动窗口的大小3，那么一共存在6个滑动窗口，</span><br><span class="line">他们的最大值分别为&#123;4,4,6,6,6,5&#125;； 针对数组&#123;2,3,4,2,6,2,5,1&#125;的滑动窗口有以下6个：</span><br><span class="line"> &#123;[2,3,4],2,6,2,5,1&#125;， &#123;2,[3,4,2],6,2,5,1&#125;， &#123;2,3,[4,2,6],2,5,1&#125;，</span><br><span class="line">  &#123;2,3,4,[2,6,2],5,1&#125;， &#123;2,3,4,2,[6,2,5],1&#125;， &#123;2,3,4,2,6,[2,5,1]&#125;。</span><br><span class="line">窗口大于数组长度的时候，返回空 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test65 &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList();</span><br><span class="line">        if (size &gt; num.length || size &#x3D;&#x3D; 0)</span><br><span class="line">            return list;</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; num.length - size; i ++) &#123;</span><br><span class="line">            int tmp &#x3D; num[i];</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; i + size; j ++) &#123;</span><br><span class="line">                if (num[j] &gt; tmp)</span><br><span class="line">                    tmp &#x3D; num[j];</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test66"><a href="#Test66" class="headerlink" title="Test66"></a>Test66</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test66 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</span><br><span class="line">路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。</span><br><span class="line">如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 回溯法 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test66 &#123;</span><br><span class="line">    public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123;</span><br><span class="line">        &#x2F;&#x2F; 矩阵元素的标志位，表示其是否被遍历</span><br><span class="line">        boolean[] flag &#x3D; new boolean[matrix.length];</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; rows; i ++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; cols; j ++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 遍历整个矩阵元素作为第一个字符的情况</span><br><span class="line">                if (search(matrix, rows, cols, i, j, str, flag, 0))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; k表示搜索的str中的第k号字符</span><br><span class="line">    public boolean search(char[] matrix, int rows, int cols, int i, int j, char[] str, boolean[] flag, int k) &#123;</span><br><span class="line">        int index &#x3D; i * cols + j; &#x2F;&#x2F; 矩阵索引</span><br><span class="line">        &#x2F;&#x2F; 递归终止</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i  &gt;&#x3D; rows || j &gt;&#x3D; cols || matrix[index] !&#x3D; str[k] || flag[index] &#x3D;&#x3D; true)</span><br><span class="line">            return false;</span><br><span class="line">        flag[index] &#x3D; true; &#x2F;&#x2F; 矩阵走过的位置设置为true</span><br><span class="line">        &#x2F;&#x2F; 最后一个字符正确</span><br><span class="line">        if (k &#x3D;&#x3D; str.length - 1)</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 递归查找i，j四周的元素是否为第k个元素</span><br><span class="line">        if (search(matrix, rows, cols, i - 1, j, str, flag, k + 1) ||</span><br><span class="line">            search(matrix, rows, cols, i + 1, j, str, flag, k + 1) ||</span><br><span class="line">            search(matrix, rows, cols, i, j + 1, str, flag, k + 1) ||</span><br><span class="line">            search(matrix, rows, cols, i, j - 1, str, flag, k + 1)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 四周元素都没吻合的，说明当前元素选错了，进行回退</span><br><span class="line">        flag[index] &#x3D; false;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test67"><a href="#Test67" class="headerlink" title="Test67"></a>Test67</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test67 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，</span><br><span class="line">每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和</span><br><span class="line">大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 &#x3D; 18。</span><br><span class="line">但是，它不能进入方格（35,38），因为3+5+3+8 &#x3D; 19。请问该机器人能够达到多少个格子？*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test67 &#123;</span><br><span class="line">    public int movingCount(int threshold, int rows, int cols) &#123;</span><br><span class="line">        int[][] matrix &#x3D; new int[rows][cols];</span><br><span class="line">        boolean[][] flag &#x3D; new boolean[rows][cols];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; rows; i ++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; cols; j ++) &#123;</span><br><span class="line">                matrix[i][j] &#x3D; numSum(i) + numSum(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int count &#x3D; movingCountHelper(threshold, matrix, rows, cols, 0, 0, flag);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int movingCountHelper(int threshold, int[][] matrix, int rows, int cols, int i, int j, boolean[][] flag) &#123;</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; rows || j &gt;&#x3D; cols || matrix[i][j] &gt; threshold || flag[i][j] &#x3D;&#x3D; true)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        flag[i][j] &#x3D; true;</span><br><span class="line"></span><br><span class="line">        return 1 + movingCountHelper(threshold, matrix, rows, cols, i - 1, j, flag) </span><br><span class="line">                 + movingCountHelper(threshold, matrix, rows, cols, i + 1, j, flag) </span><br><span class="line">                 + movingCountHelper(threshold, matrix, rows, cols, i, j - 1, flag) </span><br><span class="line">                 + movingCountHelper(threshold, matrix, rows, cols, i, j + 1, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int numSum(int i) &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        do&#123;</span><br><span class="line">            sum +&#x3D; i%10;</span><br><span class="line">        &#125; while((i &#x3D; i&#x2F;10) &gt; 0);</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test68"><a href="#Test68" class="headerlink" title="Test68"></a>Test68</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test68 给你一根长度为n的绳子，请把绳子剪成整数长的m段</span><br><span class="line">（m、n都是整数，n&gt;1并且m&gt;1，m&lt;&#x3D;n），每段绳子的长度记为</span><br><span class="line">k[1],...,k[m]。请问k[1]x...xk[m]可能的最大乘积是多少？</span><br><span class="line">例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，</span><br><span class="line">此时得到的最大乘积是18。 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.lang.Math;</span><br><span class="line"></span><br><span class="line">public class Test68 &#123;</span><br><span class="line">    public int cutRope(int target) &#123;</span><br><span class="line">        &#x2F;&#x2F; target &lt;&#x3D; 3时必须分段</span><br><span class="line">        if (target &#x3D;&#x3D; 2)</span><br><span class="line">            return 1;</span><br><span class="line">        if (target &#x3D;&#x3D; 3)</span><br><span class="line">            return 2;</span><br><span class="line"></span><br><span class="line">        int[] dp &#x3D; new int[target + 1];</span><br><span class="line">        &#x2F;&#x2F; target&gt;&#x3D;4时分段，分段中有1、2、3时该部分最大乘积如下</span><br><span class="line">        dp[1] &#x3D; 1;</span><br><span class="line">        dp[2] &#x3D; 2;</span><br><span class="line">        dp[3] &#x3D; 3;</span><br><span class="line">        int tmp &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 4; i &lt;&#x3D; target; i ++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; i &#x2F; 2; j ++) &#123;</span><br><span class="line">                tmp &#x3D; Math.max(tmp, dp[j] * dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#剑指Offer</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Test31&quot;&gt;&lt;a href=&quot;#Test31&quot; class=&quot;headerlink&quot; title=&quot;Test31&quot;&gt;&lt;/a&gt;Test31&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    
    <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer Test02-Test30</title>
    <link href="http://yoursite.com/2020/08/24/%E5%89%91%E6%8C%87Offer-Test02-Test30/"/>
    <id>http://yoursite.com/2020/08/24/%E5%89%91%E6%8C%87Offer-Test02-Test30/</id>
    <published>2020-08-24T13:41:47.000Z</published>
    <updated>2020-08-24T13:45:40.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Test2"><a href="#Test2" class="headerlink" title="Test2"></a>Test2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Test02 设计一个类，我们只能生成该类的一个实例。</span><br><span class="line"></span><br><span class="line">&#x2F;* 饿汉式 *&#x2F;</span><br><span class="line">class A &#123;</span><br><span class="line">    private A() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private static final A instance &#x3D; new A();</span><br><span class="line"></span><br><span class="line">    public static A getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 懒汉式 *&#x2F;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">    private B() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static B instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static getInstance() &#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null) </span><br><span class="line">            instance &#x3D; new B();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Test3"><a href="#Test3" class="headerlink" title="Test3"></a>Test3</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test03 在一个二维数组中，每一行都按照从左到右递增的顺序排序，</span><br><span class="line">    每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的</span><br><span class="line">    一个二维数组和一个整数，判断数组中是否函数该整数。*&#x2F;</span><br><span class="line"></span><br><span class="line">class Test03 &#123;</span><br><span class="line">    public boolean search(int target, int[][] array) &#123;</span><br><span class="line">        int length1 &#x3D; array[0].length; &#x2F;&#x2F; 列数</span><br><span class="line">        int length2 &#x3D; array.length; &#x2F;&#x2F; 行数</span><br><span class="line"></span><br><span class="line">        int row &#x3D; 0;</span><br><span class="line">        int col &#x3D; length1 - 1;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 从第一行最后一列找起</span><br><span class="line">        while (row &lt; length2 &amp;&amp; col &gt;&#x3D; 0) &#123;</span><br><span class="line">            if(array[row][col] &#x3D;&#x3D; target)</span><br><span class="line">                return true;</span><br><span class="line">            else if (target &lt; array[row][col]) &#123;</span><br><span class="line">                col --;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                row ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test4"><a href="#Test4" class="headerlink" title="Test4"></a>Test4</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test04 请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。</span><br><span class="line">    例如输入&quot;We are happy&quot;，则输出&quot;We%20are%20happy&quot; *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test04 &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">        StringBuffer tmp &#x3D; new StringBuffer();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">            char c &#x3D; str.charAt(i);</span><br><span class="line">            if (c &#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">                tmp.append(&quot;%20&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tmp.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test5"><a href="#Test5" class="headerlink" title="Test5"></a>Test5</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test05 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 *&#x2F;</span><br><span class="line">public class Test05 &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">        while (listNode !&#x3D; null) &#123;</span><br><span class="line">            arraylist.add(0, listNode.val);</span><br><span class="line">            listNode &#x3D; listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return arraylist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test6"><a href="#Test6" class="headerlink" title="Test6"></a>Test6</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test06 根据某二叉树前序遍历和中序遍历的结果重建二叉树 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays</span><br><span class="line"></span><br><span class="line">public class Test06 &#123;</span><br><span class="line">    public TreeNode reConstructBinaryTree(int [] pre, int [] in) &#123;</span><br><span class="line">        if (pre.length &#x3D;&#x3D; 0 || in.length &#x3D;&#x3D; 0) </span><br><span class="line">            return null;</span><br><span class="line">        TreeNode root &#x3D; new TreeNode(pre[0]);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; in.length; i ++) &#123;</span><br><span class="line">            if (pre[0] &#x3D;&#x3D; in[i]) &#123;</span><br><span class="line">                &#x2F;&#x2F; copyOfRange函数左闭右开</span><br><span class="line">                root.left &#x3D; reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));</span><br><span class="line"></span><br><span class="line">                root.right &#x3D; reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test7"><a href="#Test7" class="headerlink" title="Test7"></a>Test7</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test07 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 *&#x2F;</span><br><span class="line">&#x2F;* Push直接push到stack1中，</span><br><span class="line">    Pop：若stack2中没有数据，则先将stack1中数据都push进去再pop stack2；</span><br><span class="line">    若stack2中有数据则直接Pop stack2 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Test07 &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    public void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if (stack2.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            while (stack1.size() !&#x3D; 0) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test8"><a href="#Test8" class="headerlink" title="Test8"></a>Test8</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test08 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</span><br><span class="line">输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</span><br><span class="line">例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为1。</span><br><span class="line">NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 二分法：</span><br><span class="line">    右断点看作target，mid与target比较，</span><br><span class="line">    mid &lt; target，last &#x3D; mid</span><br><span class="line">    mid &gt; target，first &#x3D; mid+1</span><br><span class="line">    *&#x2F;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test08 &#123;</span><br><span class="line">    public int minNumberInRotateArray(int[] array) &#123;</span><br><span class="line">        if (array.length &#x3D;&#x3D; 0) return 0;</span><br><span class="line"></span><br><span class="line">        int target &#x3D; array[array.length - 1];</span><br><span class="line">        int first &#x3D; 0;</span><br><span class="line">        int last &#x3D; array.length - 1;</span><br><span class="line">        int mid &#x3D; (first + last) &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F; 不能等</span><br><span class="line">        while (first &lt; last) &#123;</span><br><span class="line">            if (array[first] &lt; array[last]) </span><br><span class="line">                return array[first];</span><br><span class="line">            if (array[mid] &lt; target) &#123;</span><br><span class="line">                last &#x3D; mid;</span><br><span class="line">            &#125; else if (array[mid] &gt; target) &#123;</span><br><span class="line">                first &#x3D; mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                last --;</span><br><span class="line">            &#125;</span><br><span class="line">            mid &#x3D; (first + last) &#x2F; 2;</span><br><span class="line">            target &#x3D; array[last];</span><br><span class="line">        &#125;</span><br><span class="line">        return array[first];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test9"><a href="#Test9" class="headerlink" title="Test9"></a>Test9</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test09 现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</span><br><span class="line">n&lt;&#x3D;39 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 递归法，时间 复杂度 O(n2)。*&#x2F;</span><br><span class="line">public class Test09 &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        if (n &#x3D;&#x3D; 0) return 0;</span><br><span class="line">        if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">        return Fibonacci(n - 2) + Fibonacci(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 递归法会重复计算，因此可以迭代计算，每次保存下次需要的数据</span><br><span class="line">    sum 存储第 n 项的值</span><br><span class="line">    one 存储第 n-1 项的值</span><br><span class="line">    two 存储第 n-2 项的值</span><br><span class="line"> *&#x2F;</span><br><span class="line">public in Fibonacci(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1) return n;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    int one &#x3D; 1;</span><br><span class="line">    int two &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        sum &#x3D; one + two;</span><br><span class="line">        two &#x3D; one;</span><br><span class="line">        one &#x3D; sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test10"><a href="#Test10" class="headerlink" title="Test10"></a>Test10</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test10 一只青蛙一次可以跳上1级台阶，也可以跳上2级。</span><br><span class="line">求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 上n层台阶有f(n)种，</span><br><span class="line">    第一步有两种选择：1.先上1层再上n-1层有f(n-1)</span><br><span class="line">                  2.先上2层再上n-2层有f(n-2)</span><br><span class="line">    所以f(n) &#x3D; f(n-1) + f(n-2)是个斐波那契</span><br><span class="line">    f(1)&#x3D;1 f(2)&#x3D;2 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test10 &#123;</span><br><span class="line">    public int JumpFloor(int target) &#123;</span><br><span class="line">        if (target &#x3D;&#x3D; 1 || target &#x3D;&#x3D; 2) return n;</span><br><span class="line">        return JumpFloor(target-1) + JumpFloor(target-2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test11"><a href="#Test11" class="headerlink" title="Test11"></a>Test11</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test11 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。</span><br><span class="line">    求该青蛙跳上一个n级的台阶总共有多少种跳法。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 设跳上n级台阶有f(n)种跳法，</span><br><span class="line">    跳上n级可以分为n种，在第1级跳n-1步，...在第n-1级跳1步</span><br><span class="line">    所以f(n) &#x3D; f(1) + f(2)+...+f(n-1) *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test11 &#123;</span><br><span class="line">    public int JumpFloorII(int target) &#123;</span><br><span class="line">        if (target &#x3D;&#x3D; 1 || target &#x3D;&#x3D; 2)  return target;</span><br><span class="line">        return 2*JumpFloorII(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="Test12"><a href="#Test12" class="headerlink" title="Test12"></a>Test12</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test12 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。</span><br><span class="line">请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* f(n)&#x3D;f(n-1)+f(n-2) f(1)&#x3D;1 f(2)&#x3D;2 *&#x2F;</span><br><span class="line">public class Test12 &#123;</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">        if (target &#x3D;&#x3D; 0 || target &#x3D;&#x3D; 1 || target &#x3D;&#x3D; 2) return target;</span><br><span class="line">        return RectCover(target - 1) + RectCover(target - 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test13"><a href="#Test13" class="headerlink" title="Test13"></a>Test13</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test13 输入一个整数，输出该数32位二进制表示中1的个数。</span><br><span class="line">    其中负数用补码表示。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* val &amp; (val-1) 得到的值的二进制形式正好是val最低位的1变为0 </span><br><span class="line">    例：val :1101000, val-1: 1100111 那么val &amp; （val-1） : 1100000</span><br><span class="line">    *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test13 &#123;</span><br><span class="line">    public int NumberOf1(int n) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while (n !&#x3D; 0) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            n &#x3D; n &amp; (n - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test14"><a href="#Test14" class="headerlink" title="Test14"></a>Test14</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test14 给定一个double类型的浮点数base和int类型的整数exponent。</span><br><span class="line">求base的exponent次方。保证base和exponent不同时为0 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 递归法快速幂 </span><br><span class="line">    偶数直接平方，奇数再乘上base *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test14 &#123;</span><br><span class="line">    public double Power(double base, int exponent) &#123;</span><br><span class="line">        &#x2F;&#x2F; 考虑e &lt; 0的情况</span><br><span class="line">        if (exponent &lt; 0) &#123;</span><br><span class="line">            base &#x3D; 1 &#x2F; base;</span><br><span class="line">            exponent &#x3D;  - exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        if (exponent &#x3D;&#x3D; 0) return 1;</span><br><span class="line">        if (exponent &#x3D;&#x3D; 1) return base;</span><br><span class="line"></span><br><span class="line">        double res;</span><br><span class="line">        res &#x3D; Power(base, exponent &gt;&gt; 1);</span><br><span class="line">        res *&#x3D; res;</span><br><span class="line">        if  (exponent &#x2F; 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            res *&#x3D; base;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test15"><a href="#Test15" class="headerlink" title="Test15"></a>Test15</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test15 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，</span><br><span class="line">所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 1.用一个临时数组，遍历原数组向新数组中存奇数和偶数，时间复杂度O(n) 空间O(n)</span><br><span class="line">   2.in-place算法</span><br><span class="line">初始化操作：记录一个变量i表示已经将奇数放好的下一个位置，显然最开始i&#x3D;0,表示还没有一个奇数放好。</span><br><span class="line">j 表示数组的下标，初始值为0， 表示从下标0开始遍历。</span><br><span class="line">如果遇到偶数，j++</span><br><span class="line">如果遇到奇数,假设位置为j，就将此奇数插入到i所指的位置，然后i往后移动一个位置，在插入之前，显然会涉及到数据的移动，也就是将[i,j-1]整体往后移动。</span><br><span class="line">直到整个数组遍历完毕，结束 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test15 &#123;</span><br><span class="line">    public void reOrderArray(int [] array) &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int tmp;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; array.length; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F; j索引位置为奇数</span><br><span class="line">            if ((array[j] &amp; 0x01) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                tmp &#x3D; array[j];</span><br><span class="line">                for (int k &#x3D; j; k &gt; i; k --) &#123;</span><br><span class="line">                    array[k] &#x3D; array[k - 1];</span><br><span class="line">                &#125;</span><br><span class="line">                array[i] &#x3D; tmp;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test16"><a href="#Test16" class="headerlink" title="Test16"></a>Test16</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test16 输入一个链表，输出该链表中倒数第k个结点。 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 倒数第k个节点与null节点间有k个指针。所以构造两个指针，slow指针到fast指针间也有k个指针，</span><br><span class="line">    这样当fast指针指向null节点时，slow指针正好指向目标节点 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test16 &#123;</span><br><span class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow &#x3D; head;</span><br><span class="line">        ListNode fast &#x3D; head;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; k; i ++) &#123;</span><br><span class="line">            if (fast &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            fast &#x3D; fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while (fast !&#x3D; null) &#123;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">            fast &#x3D; fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test17"><a href="#Test17" class="headerlink" title="Test17"></a>Test17</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test17 输入一个链表，反转链表后，输出新链表的表头。 *&#x2F;</span><br><span class="line">&#x2F;*</span><br><span class="line">初始化：3个指针</span><br><span class="line">1）pre指针指向已经反转好的链表的最后一个节点，最开始没有反转，所以指向null</span><br><span class="line">2）cur指针指向待反转链表的第一个节点，最开始第一个节点待反转，所以指向head</span><br><span class="line">3）nxt指针指向待反转链表的第二个节点，目的是保存链表，因为cur改变指向后，后面的链表则失效了，所以需要保存</span><br><span class="line"></span><br><span class="line">循环执行：</span><br><span class="line">nxt&#x3D;cur.next</span><br><span class="line">cur.next&#x3D;pre</span><br><span class="line">pre&#x3D;cur cur&#x3D;nxt</span><br><span class="line">循环条件是cur!&#x3D;null</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test17 &#123;</span><br><span class="line">    public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode pre &#x3D; null;</span><br><span class="line">        ListNode nxt;</span><br><span class="line">        while (head !&#x3D; null) &#123;</span><br><span class="line">            nxt &#x3D; head.next;</span><br><span class="line">            head.next &#x3D; pre;</span><br><span class="line">            pre &#x3D; head;</span><br><span class="line">            head &#x3D; nxt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test18"><a href="#Test18" class="headerlink" title="Test18"></a>Test18</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test18 输入两个单调递增的链表，输出两个链表合成后的链表，</span><br><span class="line">    当然我们需要合成后的链表满足单调不减规则。*&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test18 &#123;</span><br><span class="line">    public ListNode Merge(ListNode list1,ListNode list2) &#123;</span><br><span class="line">        ListNode head &#x3D;  new ListNode(-1);</span><br><span class="line">        ListNode tmp &#x3D; head;</span><br><span class="line"></span><br><span class="line">        while (list1 !&#x3D; null &amp;&amp; list2 !&#x3D; null) &#123;</span><br><span class="line">            if (list1.val &lt; list2.val) &#123;</span><br><span class="line">                tmp.next &#x3D; list1;</span><br><span class="line">                list1 &#x3D; list1.next;</span><br><span class="line">            &#125; else if (list1.val &gt; list2.val) &#123;</span><br><span class="line">                tmp.next &#x3D; list2;</span><br><span class="line">                list2 &#x3D; list2.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tmp.next &#x3D; list1;</span><br><span class="line">                list1 &#x3D; list1.next;</span><br><span class="line">                tmp &#x3D; tmp.next;</span><br><span class="line">                tmp.next &#x3D; list2;</span><br><span class="line">                list2 &#x3D; list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp &#x3D; tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (list1 !&#x3D; null) tmp.next &#x3D; list1;</span><br><span class="line">        if (list2 !&#x3D; null) tmp.next &#x3D; list2;</span><br><span class="line"></span><br><span class="line">        return head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test19"><a href="#Test19" class="headerlink" title="Test19"></a>Test19</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test19 输入两棵二叉树A，B，判断B是不是A的子结构。</span><br><span class="line">（ps：我们约定空树不是任意一个树的子结构）*&#x2F;</span><br><span class="line">&#x2F;* 递归 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test19 &#123;</span><br><span class="line">    public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123;</span><br><span class="line">        boolean res &#x3D; false;</span><br><span class="line">        if (root1 !&#x3D; null &amp;&amp; root2 !&#x3D; null) &#123;</span><br><span class="line">            if (root1.val &#x3D;&#x3D; root2.val) &#123;</span><br><span class="line">                res &#x3D; doesTree1HaveTree2(root1, root2);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!res) &#123;</span><br><span class="line">                res &#x3D; HasSubtree(root1.left, root2);</span><br><span class="line">            &#125; </span><br><span class="line">            if (!res) &#123;</span><br><span class="line">                res &#x3D; HasSubtree(root1.right, root2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean doesTree1HaveTree2(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">        if (root2 &#x3D;&#x3D; null) </span><br><span class="line">            return true;</span><br><span class="line">        if (root1 &#x3D;&#x3D; null)</span><br><span class="line">            return false;</span><br><span class="line">        if (root1.val !&#x3D; root2.val) </span><br><span class="line">            return false;</span><br><span class="line">        return doesTree1HaveTree2(root1.left, root2.left) &amp;&amp; doesTree1HaveTree2(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Test20"><a href="#Test20" class="headerlink" title="Test20"></a>Test20</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test20 操作给定的二叉树，将其变换为源二叉树的镜像。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 递归 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test20 &#123;</span><br><span class="line">    public void Mirror(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) return ;</span><br><span class="line">        TreeNode tmp &#x3D; root.left;</span><br><span class="line">        root.left &#x3D; root.right;</span><br><span class="line">        root.right &#x3D; tmp;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test21"><a href="#Test21" class="headerlink" title="Test21"></a>Test21</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test21 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，</span><br><span class="line">如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字</span><br><span class="line">1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 把矩阵外层看成一个圈，打印每个圈；</span><br><span class="line"></span><br><span class="line">定义四个变量代表范围，top、bottom、left、right</span><br><span class="line"></span><br><span class="line">向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 top 加一，同时判断是否和代表下边界的 bottom 交错</span><br><span class="line">向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错</span><br><span class="line">向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 bottom 减一，同时判断是否和代表上边界的 top 交错</span><br><span class="line">向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test21 &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList(); </span><br><span class="line">        if (matrix &#x3D;&#x3D; null || matrix.length &#x3D;&#x3D; 0 || matrix[0].length &#x3D;&#x3D; 0)</span><br><span class="line">            return list;</span><br><span class="line">        int top &#x3D; 0;</span><br><span class="line">        int bottom &#x3D; matrix.length - 1;</span><br><span class="line">        int left &#x3D; 0;</span><br><span class="line">        int right &#x3D; matrix[0].length - 1;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F; 最顶一行</span><br><span class="line">            for (int i &#x3D; left; i &lt;&#x3D; right; i ++) &#123;</span><br><span class="line">                list.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (++ top &gt; bottom)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 最右侧一行</span><br><span class="line">            for (int i &#x3D; top; i &lt;&#x3D; bottom; i ++) &#123;</span><br><span class="line">                list.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (--right &lt; left)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 最底层一行</span><br><span class="line">            for (int i &#x3D; right; i &gt;&#x3D; left; i --) &#123;</span><br><span class="line">                list.add(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (--bottom &lt; top)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 最左侧一行</span><br><span class="line">            for (int i &#x3D; bottom; i &gt;&#x3D; top; i  --) &#123;</span><br><span class="line">                list.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (++ left &gt; right)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test22"><a href="#Test22" class="headerlink" title="Test22"></a>Test22</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的</span><br><span class="line">min函数（时间复杂度应为O（1））*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 需要创建一个辅助栈来实现呢min函数，如果仅仅使用一个辅助变量min，</span><br><span class="line">则其值可能因为min元素被出栈而失效.</span><br><span class="line">    辅助栈中成员数量与栈中相同，对应着栈的最小值 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Test22 &#123;</span><br><span class="line">    private Stack&lt;Integer&gt; stack1 &#x3D; new Stack();</span><br><span class="line">    private Stack&lt;Integer&gt; stackSupport &#x3D; new Stack();</span><br><span class="line"></span><br><span class="line">    public void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        if (stackSupport.empty() || node &lt; stackSupport.peek()) &#123;</span><br><span class="line">            stackSupport.push(node);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stackSupport.push(stackSupport.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pop() &#123;</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stackSupport.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int min() &#123;</span><br><span class="line">        return stackSupport.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test23"><a href="#Test23" class="headerlink" title="Test23"></a>Test23</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test23 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为</span><br><span class="line">该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是</span><br><span class="line">某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，</span><br><span class="line">但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 新建一个栈，将数组A压入栈中，当栈顶元素等于数组B时，就将其出栈，</span><br><span class="line">当循环结束时，判断栈是否为空，若为空则返回true. *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Test23 &#123;</span><br><span class="line">    public boolean IsPopOrder(int [] pushA,int [] popA) &#123;</span><br><span class="line">        if (pushA.length &#x3D;&#x3D; 0 || popA.length &#x3D;&#x3D; 0 || pushA.length !&#x3D; popA.length)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack &#x3D; new Stack();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0, j &#x3D; 0; i &lt; pushA.length; i ++) &#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line"></span><br><span class="line">            while (!stack.empty() &amp;&amp; stack.peek() &#x3D;&#x3D; popA[j]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test24"><a href="#Test24" class="headerlink" title="Test24"></a>Test24</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test24 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。</span><br><span class="line">如果是则返回true,否则返回false。</span><br><span class="line">假设输入的数组的任意两个数字都互不相同。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 后序遍历 左-&gt;右-&gt;根，所以最后一个元素是根元素，BST要求所有左子树元素小于根，右子树元素大于根。</span><br><span class="line">那么，只需要不断地确定出左子树区间和右子树区间，并且判断：左子树区间的所有结点值 &lt; 根结点值 &lt; 右子树区间所有结点值，</span><br><span class="line">这个条件是否满足即可 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test24 &#123;</span><br><span class="line">    public boolean VerifySquenceOfBST(int [] sequence) &#123;</span><br><span class="line">        if (sequence &#x3D;&#x3D; null || sequence.length &#x3D;&#x3D; 0)</span><br><span class="line">            return false;</span><br><span class="line">        return helpVerify(sequence, 0, sequence.length - 1); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean helpVerify(int [] sequence, int start, int end) &#123;</span><br><span class="line">        &#x2F;&#x2F; 左子树空的话会&gt;</span><br><span class="line">        if (start &gt;&#x3D; end)</span><br><span class="line">            return true;</span><br><span class="line">        int root &#x3D; sequence[end];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; start - i-1为左子树</span><br><span class="line">        int i &#x3D; start;</span><br><span class="line">        for (; i &lt; end; i ++) &#123;</span><br><span class="line">            if (sequence[i] &gt; root)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j &#x3D; i; j &lt; end; j ++) &#123;</span><br><span class="line">            if (sequence[j] &lt; root)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断左右子树是否符合BST</span><br><span class="line">        return helpVerify(sequence, start, i - 1) &amp;&amp; </span><br><span class="line">                helpVerify(sequence, i, end - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test25"><a href="#Test25" class="headerlink" title="Test25"></a>Test25</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*Test25 输入一颗二叉树的根节点和一个整数，</span><br><span class="line">按字典序打印出二叉树中结点值的和为输入整数的所有路径。</span><br><span class="line">路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* </span><br><span class="line">递归三要素</span><br><span class="line">1.明白递归函数的功能：FindPath(TreeNode* root,int sum)，从root节点出发，找和为sum的路径</span><br><span class="line">2.递归终止条件：当root节点为叶子节点并且target-root.val&#x3D;&#x3D;0, 表示找到了一条符合条件的路径</span><br><span class="line">3.下一次递归：如果左子树不空，递归左子树FindPath(root-&gt;left, target),如果右子树不空，递归右子树，FindPath(root-&gt;right, target)</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test25 &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list &#x3D; new ArrayList();</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll &#x3D; new ArrayList();</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null)</span><br><span class="line">            return listAll;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target -&#x3D; root.val;</span><br><span class="line">        &#x2F;&#x2F; 当前节点为叶节点且target&#x3D;0</span><br><span class="line">        if (target &#x3D;&#x3D; 0 &amp;&amp; root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) </span><br><span class="line">            listAll.add(new ArrayList(list));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 继续递归左右子树</span><br><span class="line">        FindPath(root.left, target);</span><br><span class="line">        FindPath(root.right, target);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 删除list中最后一个节点，回退到当前节点状态</span><br><span class="line">        list.remove(list.size() - 1);</span><br><span class="line"></span><br><span class="line">        return listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test26"><a href="#Test26" class="headerlink" title="Test26"></a>Test26</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test26 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，</span><br><span class="line">另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。</span><br><span class="line">（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* step1 在旧链表中创建新链表（如1&#96;在1号节点后），不处理新链表的兄弟节点</span><br><span class="line">    step2 遍历链表，初始化新节点中的兄弟节点</span><br><span class="line">    step3 从旧链表中拆分得到新链表 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test26 &#123;</span><br><span class="line">    public RandomListNode Clone(RandomListNode pHead) &#123;</span><br><span class="line">        if (pHead &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        RandomListNode curNode &#x3D; pHead;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; step 1</span><br><span class="line">        while (curNode !&#x3D; null) &#123;</span><br><span class="line">            RandomListNode cloneNode &#x3D; new RandomListNode(curNode.label);</span><br><span class="line">            cloneNode.next &#x3D; curNode.next;</span><br><span class="line">            curNode.next &#x3D; cloneNode;</span><br><span class="line">            curNode &#x3D; cloneNode.next;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; step 2</span><br><span class="line">        curNode &#x3D; pHead;</span><br><span class="line">        while (curNode !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里要注意复制节点的random应该指向复制节点，别指向原节点了</span><br><span class="line">            curNode.next.random &#x3D; curNode.random&#x3D;&#x3D;null ? null : curNode.random.next;</span><br><span class="line">            curNode &#x3D; curNode.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; step3</span><br><span class="line">        curNode &#x3D; pHead;</span><br><span class="line">        RandomListNode pCloneHead &#x3D; pHead.next; &#x2F;&#x2F; 复制链表的头节点</span><br><span class="line">        while (curNode !&#x3D; null) &#123;</span><br><span class="line">            RandomListNode cloneNode &#x3D; curNode.next;</span><br><span class="line">            curNode.next &#x3D; cloneNode.next;</span><br><span class="line">            &#x2F;&#x2F; 尾节点的话next会是null，要进行判断</span><br><span class="line">            cloneNode.next &#x3D; cloneNode.next&#x3D;&#x3D;null ? null : cloneNode.next.next;</span><br><span class="line">            curNode &#x3D; curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test27"><a href="#Test27" class="headerlink" title="Test27"></a>Test27</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test27 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</span><br><span class="line">要求不能创建任何新的结点，只能调整树中结点指针的指向。*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 中序遍历一棵二叉搜索树得到的序列是从小到大排列的</span><br><span class="line">    中序遍历链表后再添加指针构成双向链表 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test27 &#123;</span><br><span class="line">    public TreeNode Convert(TreeNode pRootOfTree) &#123;</span><br><span class="line">        if (pRootOfTree &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; list &#x3D; new ArrayList();</span><br><span class="line">        &#x2F;&#x2F; 中序遍历，结果保存到list中</span><br><span class="line">        Convert(pRootOfTree, list);</span><br><span class="line">        return Convert(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Convert(TreeNode pRootOfTree, ArrayList list) &#123;</span><br><span class="line">        if (pRootOfTree.left !&#x3D;null) &#123;</span><br><span class="line">            Convert(pRootOfTree.left, list);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(pRootOfTree);</span><br><span class="line">        if (pRootOfTree.right !&#x3D; null) &#123;</span><br><span class="line">            Convert(pRootOfTree.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode Convert(ArrayList&lt;TreeNode&gt; list) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; list.size() - 1; i ++) &#123;</span><br><span class="line">            list.get(i).right &#x3D; list.get(i+1);</span><br><span class="line">            list.get(i+1).left &#x3D; list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return list.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test28"><a href="#Test28" class="headerlink" title="Test28"></a>Test28</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test28 输入一个字符串,按字典序打印出该字符串中字符的所有排列。</span><br><span class="line">例如输入字符串abc,则按字典序打印出由字符a,b,c</span><br><span class="line">所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。*&#x2F;</span><br><span class="line"></span><br><span class="line">还没做</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Test29"><a href="#Test29" class="headerlink" title="Test29"></a>Test29</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test29 数组中有一个数字出现的次数超过数组长度的一半，</span><br><span class="line">请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。</span><br><span class="line">由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：对数组进行顺序排列，目标数若存在肯定位于中间位置。</span><br><span class="line">    获得该数后遍历数组判断是否符合要求 *&#x2F;</span><br><span class="line">&#x2F;* 时间复杂度O(nlgn) 空间复杂度O(1) *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Test29 &#123;</span><br><span class="line">    public int MoreThanHalfNum_Solution(int [] array) &#123;</span><br><span class="line">           Arrays.sort(array);</span><br><span class="line">           int target &#x3D; array[array.length &#x2F; 2];</span><br><span class="line">           int count &#x3D; 0;</span><br><span class="line">           for (int i &#x3D; 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">               if (array[i] &#x3D;&#x3D; target)</span><br><span class="line">                   count ++;</span><br><span class="line">           &#125;</span><br><span class="line">           if (count &gt; array.length &#x2F; 2)</span><br><span class="line">               return target;</span><br><span class="line">           return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二：</span><br><span class="line">加入数组中存在众数，那么众数一定大于数组的长度的一半。</span><br><span class="line">思想就是：如果两个数不相等，就消去这两个数，最坏情况下，</span><br><span class="line">每次消去一个众数和一个非众数，那么如果存在众数，最后留下的数肯定是众数。</span><br><span class="line"></span><br><span class="line">具体做法：</span><br><span class="line"></span><br><span class="line">初始化：候选人cond &#x3D; -1， 候选人的投票次数cnt &#x3D; 0</span><br><span class="line">遍历数组，如果cnt&#x3D;0， 表示没有候选人，则选取当前数为候选人，++cnt</span><br><span class="line">否则，如果cnt &gt; 0, 表示有候选人，如果当前数&#x3D;cond，则++cnt，否则--cnt</span><br><span class="line">直到数组遍历完毕，最后检查cond是否为众数</span><br><span class="line"></span><br><span class="line">时间复杂度O(n) 空间O(1)</span><br><span class="line">*&#x2F;</span><br><span class="line">    public int MoreThanHalfNum_Solution(int [] array) &#123;</span><br><span class="line">        int cond &#x3D; -1, cnt &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">            if (cnt &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                cond &#x3D; array[i];</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (array[i] &#x3D;&#x3D; cond) </span><br><span class="line">                    ++ cnt;</span><br><span class="line">                else</span><br><span class="line">                    -- cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">               if (array[i] &#x3D;&#x3D; cond)</span><br><span class="line">                   count ++;</span><br><span class="line">           &#125;</span><br><span class="line">           if (count &gt; array.length &#x2F; 2)</span><br><span class="line">               return target;</span><br><span class="line">           return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Test30"><a href="#Test30" class="headerlink" title="Test30"></a>Test30</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Test30 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，</span><br><span class="line">    则最小的4个数字是1,2,3,4。 *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法一：排序后输出前k个数 *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Test30 &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123;</span><br><span class="line">        if (k &gt; input.length)</span><br><span class="line">            return null;</span><br><span class="line">        Arrays.sort(input);</span><br><span class="line">        ArrayList&lt;Integer&gt; list&#x3D; new ArrayList();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; k; i ++) &#123;</span><br><span class="line">            list.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 方法二：优先队列PriorityQueue *&#x2F;</span><br></pre></td></tr></table></figure><p>#剑指Offer</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Test2&quot;&gt;&lt;a href=&quot;#Test2&quot; class=&quot;headerlink&quot; title=&quot;Test2&quot;&gt;&lt;/a&gt;Test2&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    
    <category term="剑指Offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>JavaGuide笔记</title>
    <link href="http://yoursite.com/2020/08/19/JavaGuide%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/19/JavaGuide%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-19T07:04:57.000Z</published>
    <updated>2020-09-28T01:46:23.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h1><h2 id="java基本功"><a href="#java基本功" class="headerlink" title="java基本功"></a>java基本功</h2><h3 id="java和c-的区别"><a href="#java和c-的区别" class="headerlink" title="java和c++的区别"></a>java和c++的区别</h3><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li><li><em>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</em></li></ul><h3 id="Java语法"><a href="#Java语法" class="headerlink" title="Java语法"></a>Java语法</h3><h4 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h4><ol><li>泛型方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt; E &gt; void printArray( E[] inputArray )</span><br><span class="line">   &#123;         </span><br><span class="line">         for ( E element : inputArray )&#123;        </span><br><span class="line">            System.out.printf( &quot;%s &quot;, element );</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><em>常用的通配符为： T，E，K，V，？</em></p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个java类型</li><li>K V (key value) 分别代表java键值中的Key Value</li><li>E (element) 代表Element</li></ul><h4 id="hashCode-与equals"><a href="#hashCode-与equals" class="headerlink" title="hashCode()与equals()"></a>hashCode()与equals()</h4><p><a href="https://www.cnblogs.com/skywang12345/p/3324958.html">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="8种基本类型的包装类和常量池"><a href="#8种基本类型的包装类和常量池" class="headerlink" title="8种基本类型的包装类和常量池"></a>8种基本类型的包装类和常量池</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 &#x3D; 40;</span><br><span class="line">Integer i2 &#x3D; 40;</span><br><span class="line">Integer i3 &#x3D; 0;</span><br><span class="line">Integer i4 &#x3D; new Integer(40);</span><br><span class="line">Integer i5 &#x3D; new Integer(40);</span><br><span class="line">Integer i6 &#x3D; new Integer(0);</span><br><span class="line"></span><br><span class="line">System.out.println(“i1&#x3D;i2   “ + (i1 &#x3D;&#x3D; i2));</span><br><span class="line">System.out.println(“i1&#x3D;i2+i3   “ + (i1 &#x3D;&#x3D; i2 + i3));</span><br><span class="line">System.out.println(“i1&#x3D;i4   “ + (i1 &#x3D;&#x3D; i4));</span><br><span class="line">System.out.println(“i4&#x3D;i5   “ + (i4 &#x3D;&#x3D; i5));</span><br><span class="line">System.out.println(“i4&#x3D;i5+i6   “ + (i4 &#x3D;&#x3D; i5 + i6));   </span><br><span class="line">System.out.println(“40&#x3D;i5+i6   “ + (40 &#x3D;&#x3D; i5 + i6));     </span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i1&#x3D;i2   true</span><br><span class="line">i1&#x3D;i2+i3   true</span><br><span class="line">i1&#x3D;i4   false</span><br><span class="line">i4&#x3D;i5   false</span><br><span class="line">i4&#x3D;i5+i6   true</span><br><span class="line">40&#x3D;i5+i6   true</span><br></pre></td></tr></table></figure><p>解释：<br>+操作不适用于Integer对线，因此回自动拆箱操作，进行数值相加。</p><h2 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h2><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="在java中定义无参的构造方法"><a href="#在java中定义无参的构造方法" class="headerlink" title="在java中定义无参的构造方法"></a>在java中定义无参的构造方法</h4><p>Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>private修饰属性，public方法用来获得属性并返回。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><em>关于继承如下 3 点请记住：</em><br>1 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<em>只是拥有</em>。<br>2 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>3 子类可以用自己的方式实现父类的方法。（以后介绍）。</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><h2 id="Java核心技术"><a href="#Java核心技术" class="headerlink" title="Java核心技术"></a>Java核心技术</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><em>注意：</em> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>与进程不同，同类的多个线程共享同一块内存空间和一组系统资源。</p><p><em>进程是系统运行程序的基本单位</em></p><h3 id="文件与I-O流"><a href="#文件与I-O流" class="headerlink" title="文件与I/O流"></a>文件与I/O流</h3><p><em>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</em><br>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>[image:8C704DD8-7B72-4EF3-8FBF-0C6B3706B105-6931-0000695C8EBD05B1/Java-Collections.jpeg]</p><h2 id="Collection子接口List"><a href="#Collection子接口List" class="headerlink" title="Collection子接口List"></a>Collection子接口List</h2><h3 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h3><ol><li>ArrayList 是 List 的主要实现类，底层使用 Object[ ]存储，适用于频繁的查找工作，线程不安全 ；</li><li>Vector 是 List 的古老实现类，底层使用 Object[ ]存储，线程安全的。</li></ol><h3 id="ArrayLIst和LinkedList区别"><a href="#ArrayLIst和LinkedList区别" class="headerlink" title="ArrayLIst和LinkedList区别"></a>ArrayLIst和LinkedList区别</h3><ol><li><em>底层数据结构</em>：<code>Arraylist </code>底层使用的是 <code>Object</code><em>数组</em>；<code>LinkedList</code> 底层使用的是 <em>双向链表</em> 数据结构</li><li><em>插入和删除是否受元素位置的影响：</em> ① <code>ArrayList</code><em>采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</em> 比如：执行<code>add(E e)</code>方法的时候，<code> ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话<code>（add(int index, E element)）</code>时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <code>LinkedList</code><em>采用链表存储，所以对于</em><code>add(E e)</code><em>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置</em>i<em>插入和删除元素的话<code>（*(add(int index, E element)*）</code> 时间复杂度近似为</em><code>o(n))</code><em>因为需要先移动到指定位置再插入。</em></li><li><em>内存空间占用：</em> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h2 id="Collection子接口Set"><a href="#Collection子接口Set" class="headerlink" title="Collection子接口Set"></a>Collection子接口Set</h2><h3 id="Comparable和Comparator"><a href="#Comparable和Comparator" class="headerlink" title="Comparable和Comparator"></a>Comparable和Comparator</h3><ul><li><code>comparable</code> 接口实际上是出自<br><code>java.lang</code>包 它有一个<br><code>compareTo(Object obj)</code> 方法用来排序</li><li><code>comparator</code> 接口实际上是出自 <code>java.util</code> 包它有一个<br><code>compare(Object obj1, Object obj2)</code> 方法用来排序</li></ul><p><code>implements Comparable</code>接口的类重写<code>compareTo</code>来实现自定义排序</p><h3 id="set无序性和不可重复性"><a href="#set无序性和不可重复性" class="headerlink" title="set无序性和不可重复性"></a>set无序性和不可重复性</h3><ol><li>什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li><li>什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</li></ol><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>Java中不需要为每一个new操作区写对应的free</p><h3 id="二-运行时数据区域"><a href="#二-运行时数据区域" class="headerlink" title="二 运行时数据区域"></a>二 运行时数据区域</h3><p>JDK 1.8:<br>[image:B3776FAA-F613-447E-8696-6C35A25D2294-6931-00008E8C37A6B67C/2019-3Java运行时数据区域JDK1.8.png]</p><p><em>线程私有的：</em></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>线程共享的：*</li><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p><em>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</em></p><h4 id="Java虚拟机栈（虚拟机中拘捕变量表部分）"><a href="#Java虚拟机栈（虚拟机中拘捕变量表部分）" class="headerlink" title="Java虚拟机栈（虚拟机中拘捕变量表部分）"></a>Java虚拟机栈（虚拟机中拘捕变量表部分）</h4><p><em>描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</em><br>实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。</p><p><em>局部变量表主要存放了编译期可知的各种数据类型</em>（boolean、byte、char、short、int、float、long、double）、<em>对象引用</em>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p>Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。<br>Java 方法有两种返回方式：</p><ol><li>return 语句。</li><li>抛出异常。<br>不管哪种返回方式都会导致栈帧被弹出。</li></ol><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java堆多有线程共享。<em>唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</em></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<em>GC 堆（Garbage Collected Heap）</em>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<em>进一步划分的目的是更好地回收内存，或者更快地分配内存。</em></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>#Javaguide# #笔记</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础知识&quot;&gt;&lt;a href=&quot;#Java基础知识&quot; class=&quot;headerlink&quot; title=&quot;Java基础知识&quot;&gt;&lt;/a&gt;Java基础知识&lt;/h1&gt;&lt;h2 id=&quot;java基本功&quot;&gt;&lt;a href=&quot;#java基本功&quot; class=&quot;header</summary>
      
    
    
    
    <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
